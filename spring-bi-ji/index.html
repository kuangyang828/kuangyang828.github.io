<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="况杨的博客">
<meta name="description" content="记录我的学习点滴。">
<meta name="theme-color" content="#000">
<title>Spring笔记 | kuangyang&#39;s Blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1672755973728">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/themes/black/pace-theme-loading-bar.css" rel="stylesheet" />

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="Spring笔记" />
  <meta name="keywords" content="Spring" />
</head>
<body>

  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>kuangyang&#39;s Blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">记录我的学习点滴。</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                
                  <a href="/" target="_self">
                    首页
                  </a>
                
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                
                  <a href="/archives" target="_self">
                    归档
                  </a>
                
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                
                  <a href="/tags" target="_self">
                    标签
                  </a>
                
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                
                  <a href="/about" target="_self">
                    关于
                  </a>
                
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  no_compress"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#1-spring%E7%AE%80%E4%BB%8B">1、Spring简介</a>
<ul>
<li><a href="#11-spring%E6%A6%82%E8%BF%B0">1.1、Spring概述</a></li>
<li><a href="#12-spring%E5%AE%B6%E6%97%8F">1.2、Spring家族</a></li>
<li><a href="#13-spring-framework">1.3、Spring Framework</a>
<ul>
<li><a href="#131-spring-framework%E7%89%B9%E6%80%A7">1.3.1、Spring Framework特性</a></li>
<li><a href="#132-spring-framework%E4%BA%94%E5%A4%A7%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97">1.3.2、Spring Framework五大功能模块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ioc">2、IOC</a>
<ul>
<li><a href="#21-ioc%E5%AE%B9%E5%99%A8">2.1、IOC容器</a>
<ul>
<li><a href="#211-ioc%E6%80%9D%E6%83%B3">2.1.1、IOC思想</a>
<ul>
<li><a href="#1%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90%E7%9A%84%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F">①获取资源的传统方式</a></li>
<li><a href="#2%E5%8F%8D%E8%BD%AC%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90">②反转控制方式获取资源</a></li>
<li><a href="#3di">③DI</a></li>
</ul>
</li>
<li><a href="#212-ioc%E5%AE%B9%E5%99%A8%E5%9C%A8spring%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0">2.1.2、IOC容器在Spring中的实现</a>
<ul>
<li><a href="#1beanfactory">①BeanFactory</a></li>
<li><a href="#2applicationcontext">②ApplicationContext</a></li>
<li><a href="#3applicationcontext%E7%9A%84%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB">③ApplicationContext的主要实现类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#22-%E5%9F%BA%E4%BA%8Exml%E7%AE%A1%E7%90%86bean">2.2、基于XML管理bean</a>
<ul>
<li><a href="#221-%E5%AE%9E%E9%AA%8C%E4%B8%80%E5%88%9B%E5%BB%BAbean">2.2.1、实验一：创建bean</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BAmaven-module">①创建Maven Module</a></li>
<li><a href="#2%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96">②引入依赖</a></li>
<li><a href="#3%E5%88%9B%E5%BB%BA%E7%B1%BBhelloworld">③创建类HelloWorld</a></li>
<li><a href="#4%E5%88%9B%E5%BB%BAspring%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">④创建Spring的配置文件</a></li>
<li><a href="#5%E5%9C%A8spring%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AEbean">⑤在Spring的配置文件中配置bean</a></li>
<li><a href="#6%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB%E6%B5%8B%E8%AF%95">⑥创建测试类测试</a></li>
<li><a href="#7%E6%80%9D%E8%B7%AF">⑦思路</a></li>
<li><a href="#8%E6%B3%A8%E6%84%8F">⑧注意</a></li>
</ul>
</li>
<li><a href="#222-%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%8E%B7%E5%8F%96bean">2.2.2、实验二：获取bean</a>
<ul>
<li><a href="#1%E6%96%B9%E5%BC%8F%E4%B8%80%E6%A0%B9%E6%8D%AEid%E8%8E%B7%E5%8F%96">①方式一：根据id获取</a></li>
<li><a href="#2%E6%96%B9%E5%BC%8F%E4%BA%8C%E6%A0%B9%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96">②方式二：根据类型获取</a></li>
<li><a href="#3%E6%96%B9%E5%BC%8F%E4%B8%89%E6%A0%B9%E6%8D%AEid%E5%92%8C%E7%B1%BB%E5%9E%8B">③方式三：根据id和类型</a></li>
<li><a href="#4%E6%B3%A8%E6%84%8F">④注意</a></li>
<li><a href="#5%E6%89%A9%E5%B1%95">⑤扩展</a></li>
<li><a href="#6%E7%BB%93%E8%AE%BA">⑥结论</a></li>
</ul>
</li>
<li><a href="#223-%E5%AE%9E%E9%AA%8C%E4%B8%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%B9%8Bsetter%E6%B3%A8%E5%85%A5">2.2.3、实验三：依赖注入之setter注入</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E5%AD%A6%E7%94%9F%E7%B1%BBstudent">①创建学生类Student</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AEbean%E6%97%B6%E4%B8%BA%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC">②配置bean时为属性赋值</a></li>
<li><a href="#3%E6%B5%8B%E8%AF%95">③测试</a></li>
</ul>
</li>
<li><a href="#224-%E5%AE%9E%E9%AA%8C%E5%9B%9B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5">2.2.4、实验四：依赖注入之构造器注入</a>
<ul>
<li><a href="#1%E5%9C%A8student%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0">①在Student类中添加有参构造</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AEbean">②配置bean</a></li>
<li><a href="#3%E6%B5%8B%E8%AF%95-2">③测试</a></li>
</ul>
</li>
<li><a href="#225-%E5%AE%9E%E9%AA%8C%E4%BA%94%E7%89%B9%E6%AE%8A%E5%80%BC%E5%A4%84%E7%90%86">2.2.5、实验五：特殊值处理</a>
<ul>
<li><a href="#1%E5%AD%97%E9%9D%A2%E9%87%8F%E8%B5%8B%E5%80%BC">①字面量赋值</a></li>
<li><a href="#2null%E5%80%BC">②null值</a></li>
<li><a href="#3xml%E5%AE%9E%E4%BD%93">③xml实体</a></li>
<li><a href="#4cdata%E8%8A%82">④CDATA节</a></li>
</ul>
</li>
<li><a href="#226-%E5%AE%9E%E9%AA%8C%E5%85%AD%E4%B8%BA%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC">2.2.6、实验六：为类类型属性赋值</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E7%8F%AD%E7%BA%A7%E7%B1%BBclazz">①创建班级类Clazz</a></li>
<li><a href="#2%E4%BF%AE%E6%94%B9student%E7%B1%BB">②修改Student类</a></li>
<li><a href="#3%E6%96%B9%E5%BC%8F%E4%B8%80%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E5%B7%B2%E5%A3%B0%E6%98%8E%E7%9A%84bean">③方式一：引用外部已声明的bean</a></li>
<li><a href="#4%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%86%85%E9%83%A8bean">④方式二：内部bean</a></li>
<li><a href="#3%E6%96%B9%E5%BC%8F%E4%B8%89%E7%BA%A7%E8%81%94%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC">③方式三：级联属性赋值</a></li>
</ul>
</li>
<li><a href="#227-%E5%AE%9E%E9%AA%8C%E4%B8%83%E4%B8%BA%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC">2.2.7、实验七：为数组类型属性赋值</a>
<ul>
<li><a href="#1%E4%BF%AE%E6%94%B9student%E7%B1%BB">①修改Student类</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AEbean-2">②配置bean</a></li>
</ul>
</li>
<li><a href="#228-%E5%AE%9E%E9%AA%8C%E5%85%AB%E4%B8%BA%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC">2.2.8、实验八：为集合类型属性赋值</a>
<ul>
<li><a href="#1%E4%B8%BAlist%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC">①为List集合类型属性赋值</a></li>
<li><a href="#2%E4%B8%BAmap%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC">②为Map集合类型属性赋值</a></li>
<li><a href="#3%E5%BC%95%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84bean">③引用集合类型的bean</a></li>
</ul>
</li>
<li><a href="#229-%E5%AE%9E%E9%AA%8C%E4%B9%9D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%B9%8Bp%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">2.2.9、实验九：依赖注入之p命名空间</a></li>
<li><a href="#2210-%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6">2.2.10、实验十：引入外部属性文件</a>
<ul>
<li><a href="#1%E5%8A%A0%E5%85%A5%E4%BE%9D%E8%B5%96">①加入依赖</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6">②创建外部属性文件</a></li>
<li><a href="#3%E5%BC%95%E5%85%A5%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6">③引入属性文件</a></li>
<li><a href="#4%E9%85%8D%E7%BD%AEbean">④配置bean</a></li>
<li><a href="#5%E6%B5%8B%E8%AF%95">⑤测试</a></li>
</ul>
</li>
<li><a href="#2211-%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">2.2.11、实验十一：bean的作用域</a>
<ul>
<li><a href="#1%E6%A6%82%E5%BF%B5">①概念</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA%E7%B1%BBuser">②创建类User</a></li>
<li><a href="#3%E9%85%8D%E7%BD%AEbean">③配置bean</a></li>
<li><a href="#4%E6%B5%8B%E8%AF%95">④测试</a></li>
</ul>
</li>
<li><a href="#2212-%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8Cbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">2.2.12、实验十二：bean的生命周期</a>
<ul>
<li><a href="#1%E5%85%B7%E4%BD%93%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%87%E7%A8%8B">①具体的生命周期过程</a></li>
<li><a href="#2%E4%BF%AE%E6%94%B9%E7%B1%BBuser">②修改类User</a></li>
<li><a href="#3%E9%85%8D%E7%BD%AEbean-2">③配置bean</a></li>
<li><a href="#4%E6%B5%8B%E8%AF%95-2">④测试</a></li>
<li><a href="#5bean%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8">⑤bean的后置处理器</a></li>
</ul>
</li>
<li><a href="#2213-%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89factorybean">2.2.13、实验十三：FactoryBean</a>
<ul>
<li><a href="#1%E7%AE%80%E4%BB%8B">①简介</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BA%E7%B1%BBuserfactorybean">②创建类UserFactoryBean</a></li>
<li><a href="#3%E9%85%8D%E7%BD%AEbean-3">③配置bean</a></li>
<li><a href="#4%E6%B5%8B%E8%AF%95-3">④测试</a></li>
</ul>
</li>
<li><a href="#2214-%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B%E5%9F%BA%E4%BA%8Exml%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">2.2.14、实验十四：基于xml的自动装配</a>
<ul>
<li><a href="#1%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F">①场景模拟</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AEbean-3">②配置bean</a></li>
<li><a href="#3%E6%B5%8B%E8%AF%95-3">③测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#23-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%AE%A1%E7%90%86bean">2.3、基于注解管理bean</a>
<ul>
<li><a href="#231-%E5%AE%9E%E9%AA%8C%E4%B8%80%E6%A0%87%E8%AE%B0%E4%B8%8E%E6%89%AB%E6%8F%8F">2.3.1、实验一：标记与扫描</a>
<ul>
<li><a href="#1%E6%B3%A8%E8%A7%A3">①注解</a></li>
<li><a href="#2%E6%89%AB%E6%8F%8F">②扫描</a></li>
<li><a href="#3%E6%96%B0%E5%BB%BAmaven-module">③新建Maven Module</a></li>
<li><a href="#4%E5%88%9B%E5%BB%BAspring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">④创建Spring配置文件</a></li>
<li><a href="#5%E6%A0%87%E8%AF%86%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3">⑤标识组件的常用注解</a></li>
<li><a href="#6%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6">⑥创建组件</a></li>
<li><a href="#7%E6%89%AB%E6%8F%8F%E7%BB%84%E4%BB%B6">⑦扫描组件</a></li>
<li><a href="#8%E6%B5%8B%E8%AF%95">⑧测试</a></li>
<li><a href="#9%E7%BB%84%E4%BB%B6%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84bean%E7%9A%84id">⑨组件所对应的bean的id</a></li>
</ul>
</li>
<li><a href="#232-%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">2.3.2、实验二：基于注解的自动装配</a>
<ul>
<li><a href="#1%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F-2">①场景模拟</a></li>
<li><a href="#2-autowired%E6%B3%A8%E8%A7%A3">② @Autowired注解</a></li>
<li><a href="#3-autowired%E6%B3%A8%E8%A7%A3%E5%85%B6%E4%BB%96%E7%BB%86%E8%8A%82">③ @Autowired注解其他细节</a></li>
<li><a href="#4-autowired%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">④ @Autowired工作流程</a></li>
</ul>
</li>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a>
<ul>
<li><a href="#5%E6%80%BB%E7%BB%93">⑤总结</a></li>
</ul>
</li>
<li><a href="#233-%E5%AE%9E%E9%AA%8C%E4%B8%89%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91">2.3.3、实验三：完全注解开发</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E7%B1%BB">①创建配置类</a></li>
<li><a href="#2%E6%A0%B9%E6%8D%AE%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%88%9B%E5%BB%BAioc%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1">②根据配置类创建IOC容器对象</a></li>
<li><a href="#3%E5%9C%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%B8%AD%E9%85%8D%E7%BD%AEbean">③在配置类中配置bean</a></li>
<li><a href="#4%E5%9C%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%B8%AD%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E7%9A%84%E5%8C%85">④在配置类中配置自动扫描的包</a></li>
</ul>
</li>
<li><a href="#234-%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B4%E5%90%88junit4">2.3.4、实验四：整合junit4</a>
<ul>
<li><a href="#1%E6%95%B4%E5%90%88%E7%9A%84%E5%A5%BD%E5%A4%84">①整合的好处</a></li>
<li><a href="#2%E6%93%8D%E4%BD%9C">②操作</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-aop">3、AOP</a>
<ul>
<li><a href="#31-%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F">3.1、场景模拟</a>
<ul>
<li><a href="#311-%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3">3.1.1、声明接口</a></li>
<li><a href="#312-%E5%88%9B%E5%BB%BA%E5%AE%9E%E7%8E%B0%E7%B1%BB">3.1.2、创建实现类</a></li>
<li><a href="#313-%E5%88%9B%E5%BB%BA%E5%B8%A6%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB">3.1.3、创建带日志功能的实现类</a></li>
<li><a href="#314-%E6%8F%90%E5%87%BA%E9%97%AE%E9%A2%98">3.1.4、提出问题</a>
<ul>
<li><a href="#1%E7%8E%B0%E6%9C%89%E4%BB%A3%E7%A0%81%E7%BC%BA%E9%99%B7">①现有代码缺陷</a></li>
<li><a href="#2%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">②解决思路</a></li>
<li><a href="#3%E5%9B%B0%E9%9A%BE">③困难</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#32-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">3.2、代理模式</a>
<ul>
<li><a href="#321-%E6%A6%82%E5%BF%B5">3.2.1、概念</a>
<ul>
<li><a href="#1%E4%BB%8B%E7%BB%8D">①介绍</a></li>
<li><a href="#2%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86">②生活中的代理</a></li>
<li><a href="#3%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">③相关术语</a></li>
</ul>
</li>
<li><a href="#322-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">3.2.2、静态代理</a></li>
<li><a href="#323-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">3.2.3、动态代理</a></li>
<li><a href="#324-%E6%B5%8B%E8%AF%95">3.2.4、测试</a></li>
</ul>
</li>
<li><a href="#33-aop%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">3.3、AOP概念及相关术语</a>
<ul>
<li><a href="#331-%E6%A6%82%E8%BF%B0">3.3.1、概述</a></li>
<li><a href="#332-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">3.3.2、相关术语</a>
<ul>
<li><a href="#1%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%E8%BF%9E%E6%8E%A5%E7%82%B9">①横切关注点(连接点)</a></li>
<li><a href="#2%E9%80%9A%E7%9F%A5%E8%AE%B0%E4%BD%8F">②通知【记住】</a></li>
<li><a href="#3%E5%88%87%E9%9D%A2%E8%AE%B0%E4%BD%8F">③切面【记住】</a></li>
<li><a href="#4%E7%9B%AE%E6%A0%87">④目标</a></li>
<li><a href="#5%E4%BB%A3%E7%90%86">⑤代理</a></li>
<li><a href="#6%E8%BF%9E%E6%8E%A5%E7%82%B9">⑥连接点</a></li>
<li><a href="#7%E5%88%87%E5%85%A5%E7%82%B9%E8%AE%B0%E4%BD%8F">⑦切入点【记住】</a></li>
<li><a href="#8%E7%BB%87%E5%85%A5">⑧织入</a></li>
</ul>
</li>
<li><a href="#333-%E4%BD%9C%E7%94%A8">3.3.3、作用</a></li>
</ul>
</li>
<li><a href="#34-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84aop">3.4、基于注解的AOP</a>
<ul>
<li><a href="#341-%E6%8A%80%E6%9C%AF%E8%AF%B4%E6%98%8E">3.4.1、技术说明</a></li>
<li><a href="#342-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">3.4.2、准备工作</a>
<ul>
<li><a href="#1%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96">①添加依赖</a></li>
<li><a href="#2%E5%87%86%E5%A4%87%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E8%B5%84%E6%BA%90">②准备被代理的目标资源</a></li>
</ul>
</li>
<li><a href="#343-%E5%88%9B%E5%BB%BA%E5%88%87%E9%9D%A2%E7%B1%BB%E5%B9%B6%E9%85%8D%E7%BD%AE">3.4.3、创建切面类并配置</a></li>
<li><a href="#344-%E5%90%84%E7%A7%8D%E9%80%9A%E7%9F%A5">3.4.4、各种通知</a>
<ul>
<li><a href="#%E5%90%84%E7%A7%8D%E9%80%9A%E7%9F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">各种通知的执行顺序：</a></li>
</ul>
</li>
<li><a href="#345-%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95">3.4.5、切入点表达式语法</a>
<ul>
<li><a href="#1%E4%BD%9C%E7%94%A8">①作用</a></li>
<li><a href="#2%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82">②语法细节</a></li>
<li><a href="#tip">TIP</a></li>
</ul>
</li>
<li><a href="#346-%E9%87%8D%E7%94%A8%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F">3.4.6、重用切入点表达式</a>
<ul>
<li><a href="#1%E5%A3%B0%E6%98%8E">①声明</a></li>
<li><a href="#2%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2%E4%B8%AD%E4%BD%BF%E7%94%A8">②在同一个切面中使用</a></li>
<li><a href="#3%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%88%87%E9%9D%A2%E4%B8%AD%E4%BD%BF%E7%94%A8">③在不同切面中使用</a></li>
</ul>
</li>
<li><a href="#347-%E8%8E%B7%E5%8F%96%E9%80%9A%E7%9F%A5%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF">3.4.7、获取通知的相关信息</a>
<ul>
<li><a href="#1%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E7%82%B9%E4%BF%A1%E6%81%AF">①获取连接点信息</a></li>
<li><a href="#2%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">②获取目标方法的返回值</a></li>
<li><a href="#3%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%B8%B8">③获取目标方法的异常</a></li>
</ul>
</li>
<li><a href="#348-%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5">3.4.8、环绕通知</a></li>
<li><a href="#349-%E5%88%87%E9%9D%A2%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">3.4.9、切面的优先级</a>
<ul>
<li><a href="#1%E6%A6%82%E5%BF%B5-2">①概念</a></li>
<li><a href="#2%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89">②实际意义</a></li>
</ul>
</li>
<li><a href="#3410-%E6%B2%A1%E6%9C%89%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%85%E5%86%B5">3.4.10、没有接口的情况</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E7%B1%BB">①创建目标类</a></li>
<li><a href="#2%E6%B5%8B%E8%AF%95">②测试</a></li>
<li><a href="#3debug%E6%9F%A5%E7%9C%8B">③Debug查看</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#35-%E5%9F%BA%E4%BA%8Exml%E7%9A%84aop%E4%BA%86%E8%A7%A3">3.5、基于XML的AOP（了解）</a>
<ul>
<li><a href="#351-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">3.5.1、准备工作</a>
<ul>
<li><a href="#1%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96-2">①添加依赖</a></li>
<li><a href="#2%E5%87%86%E5%A4%87%E4%BB%A3%E7%A0%81">②准备代码</a></li>
</ul>
</li>
<li><a href="#352-%E5%AE%9E%E7%8E%B0">3.5.2、实现</a></li>
<li><a href="#352-%E6%B5%8B%E8%AF%95">3.5.2、测试</a></li>
</ul>
</li>
<li><a href="#36-aop-%E5%AF%B9%E8%8E%B7%E5%8F%96-bean-%E7%9A%84%E5%BD%B1%E5%93%8D">3.6、AOP 对获取 bean 的影响</a>
<ul>
<li><a href="#351-%E5%AE%9E%E9%AA%8C">3.5.1、实验</a>
<ul>
<li><a href="#1%E6%83%85%E6%99%AF%E4%B8%80">①情景一</a></li>
<li><a href="#2%E6%83%85%E6%99%AF%E4%BA%8C">②情景二</a></li>
</ul>
</li>
<li><a href="#352-%E6%80%BB%E7%BB%93">3.5.2、总结</a>
<ul>
<li><a href="#1%E5%AF%B9%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%BA%94%E7%94%A8%E5%88%87%E9%9D%A2">①对实现了接口的类应用切面</a></li>
<li><a href="#2%E5%AF%B9%E6%B2%A1%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%BA%94%E7%94%A8%E5%88%87%E9%9D%A2">②对没实现接口的类应用切面</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1">4、声明式事务</a>
<ul>
<li><a href="#41-jdbctemplate">4.1、JdbcTemplate</a>
<ul>
<li><a href="#411-%E7%AE%80%E4%BB%8B">4.1.1、简介</a></li>
<li><a href="#412-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">4.1.2、准备工作</a>
<ul>
<li><a href="#1%E5%8A%A0%E5%85%A5%E4%BE%9D%E8%B5%96-2">①加入依赖</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BAjdbcproperties">②创建jdbc.properties</a></li>
<li><a href="#3%E9%85%8D%E7%BD%AEspring%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">③配置Spring的配置文件</a></li>
</ul>
</li>
<li><a href="#413-%E6%B5%8B%E8%AF%95">4.1.3、测试</a>
<ul>
<li><a href="#1%E5%9C%A8%E6%B5%8B%E8%AF%95%E7%B1%BB%E8%A3%85%E9%85%8D-jdbctemplate">①在测试类装配 JdbcTemplate</a></li>
<li><a href="#2%E6%B5%8B%E8%AF%95%E5%A2%9E%E5%88%A0%E6%94%B9%E5%8A%9F%E8%83%BD">②测试增删改功能</a></li>
<li><a href="#3%E6%9F%A5%E8%AF%A2%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E4%B8%BA%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%AF%B9%E8%B1%A1">③查询一条数据为实体类对象</a></li>
<li><a href="#4%E6%9F%A5%E8%AF%A2%E5%A4%9A%E6%9D%A1%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%B8%80%E4%B8%AAlist%E9%9B%86%E5%90%88">④查询多条数据为一个list集合</a></li>
<li><a href="#5%E6%9F%A5%E8%AF%A2%E5%8D%95%E8%A1%8C%E5%8D%95%E5%88%97%E7%9A%84%E5%80%BC">⑤查询单行单列的值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#42-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5">4.2、声明式事务概念</a>
<ul>
<li><a href="#421-%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1">4.2.1、编程式事务</a></li>
<li><a href="#422-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1">4.2.2、声明式事务</a></li>
</ul>
</li>
<li><a href="#43-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1">4.3、基于注解的声明式事务</a>
<ul>
<li><a href="#431-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">4.3.1、准备工作</a>
<ul>
<li><a href="#1%E5%8A%A0%E5%85%A5%E4%BE%9D%E8%B5%96-3">①加入依赖</a></li>
<li><a href="#2%E5%88%9B%E5%BB%BAjdbcproperties-2">②创建jdbc.properties</a></li>
<li><a href="#3%E9%85%8D%E7%BD%AEspring%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-2">③配置Spring的配置文件</a></li>
<li><a href="#4%E5%88%9B%E5%BB%BA%E8%A1%A8">④创建表</a></li>
<li><a href="#5%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6">⑤创建组件</a></li>
</ul>
</li>
<li><a href="#432-%E6%B5%8B%E8%AF%95%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%83%85%E5%86%B5">4.3.2、测试无事务情况</a>
<ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%B1%BB">①创建测试类</a></li>
<li><a href="#2%E6%A8%A1%E6%8B%9F%E5%9C%BA%E6%99%AF">②模拟场景</a></li>
<li><a href="#3%E8%A7%82%E5%AF%9F%E7%BB%93%E6%9E%9C">③观察结果</a></li>
</ul>
</li>
<li><a href="#433-%E5%8A%A0%E5%85%A5%E4%BA%8B%E5%8A%A1">4.3.3、加入事务</a>
<ul>
<li><a href="#1%E6%B7%BB%E5%8A%A0%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE">①添加事务配置</a></li>
<li><a href="#2%E6%B7%BB%E5%8A%A0%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3">②添加事务注解</a></li>
<li><a href="#3%E8%A7%82%E5%AF%9F%E7%BB%93%E6%9E%9C-2">③观察结果</a></li>
</ul>
</li>
<li><a href="#434-transactional%E6%B3%A8%E8%A7%A3%E6%A0%87%E8%AF%86%E7%9A%84%E4%BD%8D%E7%BD%AE">4.3.4、@Transactional注解标识的位置</a>
<ul>
<li><a href="#tip-2">TIP</a></li>
</ul>
</li>
<li><a href="#435-%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E5%8F%AA%E8%AF%BB">4.3.5、事务属性：只读</a>
<ul>
<li><a href="#1%E4%BB%8B%E7%BB%8D-2">①介绍</a></li>
<li><a href="#2%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">②使用方式</a></li>
<li><a href="#3%E6%B3%A8%E6%84%8F">③注意</a></li>
</ul>
</li>
<li><a href="#436-%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E8%B6%85%E6%97%B6">4.3.6、事务属性：超时</a>
<ul>
<li><a href="#1%E4%BB%8B%E7%BB%8D-3">①介绍</a></li>
<li><a href="#2%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-2">②使用方式</a></li>
<li><a href="#3%E8%A7%82%E5%AF%9F%E7%BB%93%E6%9E%9C-3">③观察结果</a></li>
</ul>
</li>
<li><a href="#437-%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5">4.3.7、事务属性：回滚策略</a>
<ul>
<li><a href="#1%E4%BB%8B%E7%BB%8D-4">①介绍</a></li>
<li><a href="#2%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-3">②使用方式</a></li>
<li><a href="#3%E8%A7%82%E5%AF%9F%E7%BB%93%E6%9E%9C-4">③观察结果</a></li>
</ul>
</li>
<li><a href="#438-%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">4.3.8、事务属性：事务隔离级别</a>
<ul>
<li><a href="#1%E4%BB%8B%E7%BB%8D-5">①介绍</a></li>
<li><a href="#2%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-4">②使用方式</a></li>
</ul>
</li>
<li><a href="#439-%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA">4.3.9、事务属性：事务传播行为</a>
<ul>
<li><a href="#1%E4%BB%8B%E7%BB%8D-6">①介绍</a></li>
<li><a href="#2%E6%B5%8B%E8%AF%95-2">②测试</a></li>
<li><a href="#3%E8%A7%82%E5%AF%9F%E7%BB%93%E6%9E%9C-5">③观察结果</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#44-%E5%9F%BA%E4%BA%8Exml%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1">4.4、基于XML的声明式事务</a>
<ul>
<li><a href="#431-%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F">4.3.1、场景模拟</a></li>
<li><a href="#432-%E4%BF%AE%E6%94%B9spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">4.3.2、修改Spring配置文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-spring5-%E6%96%B0%E7%89%B9%E6%80%A7">5、Spring5 新特性</a>
<ul>
<li><a href="#51-jsr305%E6%A0%87%E5%87%86%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3">5.1、JSR305标准相关注解</a></li>
<li><a href="#52-%E6%95%B4%E5%90%88junit5">5.2、整合junit5</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
          
          <div class="post-body">
  
  
    <img src="https://img.icons8.com/color/96/000000/spring-logo.png" />
  
</div>

          
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://kuangyang828.github.io/spring-bi-ji/"> Spring笔记 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2022-07-21 22:50:51">2022-07-21</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://kuangyang828.github.io/tag/7J3okythe/">
        <span>Spring</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >100<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >21919<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
      
    <span
      id="/spring-bi-ji/"
      data-flag-title="Spring笔记"
      class="meta-item pc-show leancloud_visitors"
    >
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span
        ><span class="language" data-lan="view">浏览量:</span>:<span
          class="leancloud-visitors-count"
        ></span
      ></span>
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <blockquote>
<p>视频课程链接：<br>
<a href="https://www.bilibili.com/video/BV1Ya411S7aT?p=63">🔗bilibili（新版）</a><br>
<a href="https://www.bilibili.com/video/BV1Vf4y127N5">🔗bilibili（旧版）</a></p>
</blockquote>
<h1 id="1-spring简介">1、Spring简介</h1>
<h2 id="11-spring概述">1.1、Spring概述</h2>
<p>官网地址：https://spring.io/</p>
<blockquote>
<p>Spring 是<code>最受欢迎</code>的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。</p>
<p>Spring 框架是一个<code>开源</code>的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首 次在 Apache 2.0 许可下发布。</p>
<p>Spring 是<code>轻量级</code>的框架，其基础版本只有 2 MB 左右的大小。</p>
<p>Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。</p>
</blockquote>
<h2 id="12-spring家族">1.2、Spring家族</h2>
<p>项目列表：https://spring.io/projects</p>
<h2 id="13-spring-framework">1.3、Spring Framework</h2>
<p>Spring 基础框架，可以视为 Spring 基础设施，基本上任何其他 Spring 项目都是以 Spring Framework 为基础的。</p>
<h3 id="131-spring-framework特性">1.3.1、Spring Framework特性</h3>
<ul>
<li>非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。</li>
<li>控制反转：IOC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。</li>
<li>面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。</li>
<li>容器：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。</li>
<li>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。</li>
<li>声明式：很多以前需要编写代码才能实现的功能，现在只需要声明需求即可由框架代为实现。</li>
<li>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。</li>
</ul>
<h3 id="132-spring-framework五大功能模块">1.3.2、Spring Framework五大功能模块</h3>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core Container</td>
<td>核心容器，在Spring环境下使用任何功能都必须基于IOC容器。</td>
</tr>
<tr>
<td>AOP&amp;Aspects</td>
<td>面向切面编程。</td>
</tr>
<tr>
<td>Testing</td>
<td>提供了对 junit 或 TestNG 测试框架的整合。</td>
</tr>
<tr>
<td>Data Access/Integration</td>
<td>提供了对数据访问/集成的功能。</td>
</tr>
<tr>
<td>Spring MVC</td>
<td>提供了面向Web应用程序的集成功能</td>
</tr>
</tbody>
</table>
<h1 id="2-ioc">2、IOC</h1>
<h2 id="21-ioc容器">2.1、IOC容器</h2>
<h3 id="211-ioc思想">2.1.1、IOC思想</h3>
<p>IOC：Inversion of Control，翻译过来是<strong>反转控制</strong>。</p>
<h4 id="1获取资源的传统方式">①获取资源的传统方式</h4>
<p>自己做饭：买菜、洗菜、择菜、改刀、炒菜，全过程参与，费时费力，必须清楚了解资源创建整个过程中的全部细节且熟练掌握。</p>
<p>在应用程序中的组件需要获取资源时，传统的方式是组件<strong>主动</strong>的从容器中获取所需要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。</p>
<h4 id="2反转控制方式获取资源">②反转控制方式获取资源</h4>
<p>点外卖：下单、等、吃，省时省力，不必关心资源创建过程的所有细节。</p>
<p>反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向———改由容器主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的<strong>被动</strong>形式。</p>
<h4 id="3di">③DI</h4>
<p>DI：Dependency Injection，翻译过来是<strong>依赖注入</strong>。</p>
<p>DI 是 IOC 的另一种表述方式（实现方式）：即组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器的资源注入。相对于IOC而言，这种表述更直接。</p>
<p>所以结论是：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种==<strong>具体实现</strong>==。</p>
<h3 id="212-ioc容器在spring中的实现">2.1.2、IOC容器在Spring中的实现</h3>
<p>Spring 的 IOC 容器就是 IOC 思想的一个落地的产品实现。IOC 容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建 IOC 容器。Spring 提供了 IOC 容器的两种实现方式：</p>
<h4 id="1beanfactory">①BeanFactory</h4>
<ul>
<li>这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。</li>
</ul>
<h4 id="2applicationcontext">②ApplicationContext</h4>
<ul>
<li>BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</li>
</ul>
<blockquote>
<p>以后在 Spring 环境下看到一个类或接口的名称中包含 ApplicationContext，那基本就可以断定，这个类或接口与 IOC 容器有关。</p>
</blockquote>
<h4 id="3applicationcontext的主要实现类">③ApplicationContext的主要实现类</h4>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721104046.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClassPathXmlApplicationContext</td>
<td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>ConfigurableApplicationContext</td>
<td>ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文（容器）的能力。</td>
</tr>
<tr>
<td>WebApplicationContext</td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td>
</tr>
</tbody>
</table>
<h2 id="22-基于xml管理bean">2.2、基于XML管理bean</h2>
<h3 id="221-实验一创建bean">2.2.1、实验一：创建bean</h3>
<h4 id="1创建maven-module">①创建Maven Module</h4>
<h4 id="2引入依赖">②引入依赖</h4>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721105410.png" alt="" loading="lazy"></figure>
<h4 id="3创建类helloworld">③创建类HelloWorld</h4>
<pre><code class="language-java">package com.atguigu.spring.pojo;

public class HelloWorld {
    public void sayHello() {
        System.out.println(&quot;Hello Spring&quot;);
    }
}
</code></pre>
<h4 id="4创建spring的配置文件">④创建Spring的配置文件</h4>
<p>applicationContext.xml</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721110013.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721110038.png" alt="" loading="lazy"></figure>
<h4 id="5在spring的配置文件中配置bean">⑤在Spring的配置文件中配置bean</h4>
<pre><code class="language-xml">&lt;!--
		配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理
		通过bean标签配置IOC容器所管理的bean
		属性：
				id：设置bean的唯一标识
				class：设置bean所对应类型的全类名
--&gt;
&lt;bean id=&quot;helloworld&quot; class=&quot;com.atguigu.spring.bean.HelloWorld&quot;&gt;&lt;/bean&gt;
</code></pre>
<h4 id="6创建测试类测试">⑥创建测试类测试</h4>
<pre><code class="language-java">@Test
public void testHelloWorld() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    HelloWorld helloWorld = ioc.getBean(HelloWorld.class);
    helloWorld.sayHello();
}
</code></pre>
<h4 id="7思路">⑦思路</h4>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721112410.png" alt="" loading="lazy"></figure>
<h4 id="8注意">⑧注意</h4>
<p>Spring 底层默认通过反射技术调用组件类的无参构造器来创建组件对象，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出下面的异常：</p>
<blockquote>
<p>org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'helloworld' defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.atguigu.spring.bean.HelloWorld]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.atguigu.spring.bean.HelloWorld. ()</p>
</blockquote>
<h3 id="222-实验二获取bean">2.2.2、实验二：获取bean</h3>
<h4 id="1方式一根据id获取">①方式一：根据id获取</h4>
<p>由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。</p>
<h4 id="2方式二根据类型获取">②方式二：根据类型获取</h4>
<pre><code class="language-java">@Test
public void testHelloWorld() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    HelloWorld bean = ioc.getBean(HelloWorld.class);
    bean.sayHello();
}
</code></pre>
<h4 id="3方式三根据id和类型">③方式三：根据id和类型</h4>
<pre><code class="language-java">@Test
public void testHelloWorld() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    HelloWorld bean = ioc.getBean(&quot;helloworld&quot;, HelloWorld.class);
    bean.sayHello();
}
</code></pre>
<h4 id="4注意">④注意</h4>
<ul>
<li>
<p>当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个</p>
</li>
<li>
<p>当IOC容器中一共配置了两个：</p>
<pre><code class="language-xml">&lt;bean id=&quot;helloworldOne&quot; class=&quot;com.atguigu.spring.bean.HelloWorld&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;helloworldTwo&quot; class=&quot;com.atguigu.spring.bean.HelloWorld&quot;&gt;&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>根据类型获取时会抛出异常：</p>
<blockquote>
<p>org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.atguigu.spring.bean.HelloWorld' available: expected single matching bean but found 2: helloworldOne,helloworldTwo</p>
</blockquote>
</li>
</ul>
<h4 id="5扩展">⑤扩展</h4>
<p>如果组件类实现了接口，根据接口类型可以获取组件类 bean 吗？</p>
<blockquote>
<p>可以，前提是bean唯一</p>
</blockquote>
<p>如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取实现类 bean 吗？</p>
<blockquote>
<p>不行，因为bean不唯一</p>
</blockquote>
<p>如果一个父类只有一个子类，根据父类类型可以获取子类 bean 吗？</p>
<blockquote>
<p>可以，前提是bean唯一</p>
</blockquote>
<p>如果一个父类有多个子类，根据父类类型可以子类获取 bean 吗？</p>
<blockquote>
<p>不行，因为bean不唯一</p>
</blockquote>
<h4 id="6结论">⑥结论</h4>
<p>根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 <strong>instanceof</strong> 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。</p>
<h3 id="223-实验三依赖注入之setter注入">2.2.3、实验三：依赖注入之setter注入</h3>
<h4 id="1创建学生类student">①创建学生类Student</h4>
<pre><code class="language-java">public class Student {
    
    private Integer id;
    private String name;
    private Integer age;
    private String sex;

    public Student() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, sex='&quot; + sex + '\'' +
                '}';
    }

}
</code></pre>
<h4 id="2配置bean时为属性赋值">②配置bean时为属性赋值</h4>
<p>spring-di.xml</p>
<pre><code class="language-xml"> &lt;bean id=&quot;studentOne&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
     &lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt;
     &lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关）
     --&gt;
     &lt;!-- value属性：指定属性值 --&gt;
     &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
 &lt;/bean&gt;
</code></pre>
<h4 id="3测试">③测试</h4>
<pre><code class="language-java">@Test
public void testDIBySet() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;);
    Student studentOne = ioc.getBean(&quot;studentOne&quot;, Student.class);
    System.out.println(studentOne);
}
</code></pre>
<h3 id="224-实验四依赖注入之构造器注入">2.2.4、实验四：依赖注入之构造器注入</h3>
<h4 id="1在student类中添加有参构造">①在Student类中添加有参构造</h4>
<pre><code class="language-java">public Student(Integer id, String name, Integer age, String sex) {
    this.id = id;
    this.name = name;
    this.age = age;
    this.sex = sex;
}
</code></pre>
<h4 id="2配置bean">②配置bean</h4>
<pre><code class="language-xml">&lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;33&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>注意：</p>
<p>constructor-arg标签还有两个属性可以进一步描述构造器参数：</p>
<ul>
<li>index属性：指定参数所在位置的索引（从0开始）</li>
<li>name属性：指定参数名</li>
</ul>
</blockquote>
<h4 id="3测试-2">③测试</h4>
<pre><code class="language-java">@Test
public void testDIBySet() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;);
    Student studentOne = ioc.getBean(&quot;studentTwo&quot;, Student.class);
    System.out.println(studentOne);
}
</code></pre>
<h3 id="225-实验五特殊值处理">2.2.5、实验五：特殊值处理</h3>
<h4 id="1字面量赋值">①字面量赋值</h4>
<blockquote>
<p>什么是字面量？ (基本类型变量)</p>
<p>int a = 10;</p>
<p>声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。（这里10就是字面量）</p>
<p>而如果a是带引号的：'a'，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。</p>
</blockquote>
<pre><code class="language-xml">&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;
&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
</code></pre>
<h4 id="2null值">②null值</h4>
<pre><code class="language-xml"> &lt;property name=&quot;name&quot;&gt;
     &lt;null/&gt;
 &lt;/property&gt;
</code></pre>
<blockquote>
<p>注意：</p>
<pre><code class="language-xml">&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt;
</code></pre>
<p>以上写法，为name所赋的值是字符串null</p>
</blockquote>
<h4 id="3xml实体">③xml实体</h4>
<pre><code class="language-xml">&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;
&lt;!-- 解决方案一：使用XML实体来代替 --&gt;
&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt;
</code></pre>
<h4 id="4cdata节">④CDATA节</h4>
<pre><code class="language-xml">&lt;property name=&quot;expression&quot;&gt;
		&lt;!-- 解决方案二：使用CDATA节 --&gt;
		&lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt;
		&lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt;
		&lt;!-- 所以CDATA节中写什么符号都随意 --&gt;
&lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;
&lt;/property&gt;
</code></pre>
<h3 id="226-实验六为类类型属性赋值">2.2.6、实验六：为类类型属性赋值</h3>
<h4 id="1创建班级类clazz">①创建班级类Clazz</h4>
<pre><code class="language-java">public class Clazz {
    private Integer clazzId;
    private String clazzName;

    public Integer getClazzId() {
        return clazzId;
    }

    public void setClazzId(Integer clazzId) {
        this.clazzId = clazzId;
    }

    public String getClazzName() {
        return clazzName;
    }

    public void setClazzName(String clazzName) {
        this.clazzName = clazzName;
    }

    @Override
    public String toString() {
        return &quot;Clazz{&quot; +
                &quot;clazzId=&quot; + clazzId +
                &quot;, clazzName='&quot; + clazzName + '\'' +
                '}';
    }

    public Clazz() {
    }

    public Clazz(Integer clazzId, String clazzName) {
        this.clazzId = clazzId;
        this.clazzName = clazzName;
    }
}
</code></pre>
<h4 id="2修改student类">②修改Student类</h4>
<p>在Student类中添加以下代码：</p>
<pre><code class="language-java">private Clazz clazz;
public Clazz getClazz() {
    return clazz;
}
public void setClazz(Clazz clazz) {
    this.clazz = clazz;
}
</code></pre>
<h4 id="3方式一引用外部已声明的bean">③方式一：引用外部已声明的bean</h4>
<p>配置Clazz类型的bean：</p>
<pre><code class="language-xml">&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring.bean.Clazz&quot;&gt;
    &lt;property name=&quot;clazzId&quot; value=&quot;1111&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazzName&quot; value=&quot;财源滚滚班&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>为Student中的clazz属性赋值：</p>
<pre><code class="language-xml">&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;
    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>错误演示：</p>
<pre><code class="language-xml">&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazz&quot; value=&quot;clazzOne&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type 'java.lang.String' to required type 'com.atguigu.spring.bean.Clazz' for property 'clazz': no matching editors or conversion strategy found 意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值</p>
</blockquote>
<h4 id="4方式二内部bean">④方式二：内部bean</h4>
<pre><code class="language-xml">&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazz&quot;&gt;
        &lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt;
        &lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt;
        &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring.bean.Clazz&quot;&gt;
            &lt;property name=&quot;clazzId&quot; value=&quot;2222&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;clazzName&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="3方式三级联属性赋值">③方式三：级联属性赋值</h4>
<pre><code class="language-xml">&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;!-- 级联的方式，要保证提前为clazz属性赋值或者实例化 --&gt;
    &lt;!-- 所以这种方式相当于修改，一般不用级联赋值 --&gt;
    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazz.clazzId&quot; value=&quot;3333&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazz.clazzName&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="227-实验七为数组类型属性赋值">2.2.7、实验七：为数组类型属性赋值</h3>
<h4 id="1修改student类">①修改Student类</h4>
<p>在Student类中添加以下代码：</p>
<pre><code class="language-java">private String[] hobbies;
public String[] getHobbies() {
    return hobbies;
}
public void setHobbies(String[] hobbies) {
    this.hobbies = hobbies;

</code></pre>
<h4 id="2配置bean-2">②配置bean</h4>
<pre><code class="language-xml">&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;
    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;抽烟&lt;/value&gt;
            &lt;value&gt;喝酒&lt;/value&gt;
            &lt;value&gt;烫头&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="228-实验八为集合类型属性赋值">2.2.8、实验八：为集合类型属性赋值</h3>
<h4 id="1为list集合类型属性赋值">①为List集合类型属性赋值</h4>
<p>在Clazz类中添加以下代码：</p>
<pre><code class="language-java">private List&lt;Student&gt; students;
public List&lt;Student&gt; getStudents() {
    return students;
}
public void setStudents(List&lt;Student&gt; students) {
    this.students = students;
}
</code></pre>
<p>配置bean：</p>
<pre><code class="language-xml">&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring.bean.Clazz&quot;&gt;
    &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;students&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可</p>
</blockquote>
<h4 id="2为map集合类型属性赋值">②为Map集合类型属性赋值</h4>
<p>创建教师类Teacher：</p>
<pre><code class="language-java">public class Teacher {
    private Integer teacherId;

    private String teacherName;

    public Teacher() {
    }

    public Teacher(Integer teacherId, String teacherName) {
        this.teacherId = teacherId;
        this.teacherName = teacherName;
    }

    public Integer getTeacherId() {
        return teacherId;
    }

    public void setTeacherId(Integer teacherId) {
        this.teacherId = teacherId;
    }

    public String getTeacherName() {
        return teacherName;
    }

    public void setTeacherName(String teacherName) {
        this.teacherName = teacherName;
    }

    @Override
    public String toString() {
        return &quot;Teacher{&quot; +
                &quot;teacherId=&quot; + teacherId +
                &quot;, teacherName='&quot; + teacherName + '\'' +
                '}';
    }
}
</code></pre>
<p>在Student类中添加以下代码：</p>
<pre><code class="language-java">private Map&lt;String, Teacher&gt; teacherMap;
public Map&lt;String, Teacher&gt; getTeacherMap() {
    return teacherMap;
}
public void setTeacherMap(Map&lt;String, Teacher&gt; teacherMap) {
    this.teacherMap = teacherMap;
}
</code></pre>
<p>配置bean：</p>
<pre><code class="language-xml">&lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring.bean.Teacher&quot;&gt;
    &lt;property name=&quot;teacherId&quot; value=&quot;10010&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;teacherName&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring.bean.Teacher&quot;&gt;
    &lt;property name=&quot;teacherId&quot; value=&quot;10086&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;teacherName&quot; value=&quot;二宝&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;
    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;抽烟&lt;/value&gt;
            &lt;value&gt;喝酒&lt;/value&gt;
            &lt;value&gt;烫头&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name=&quot;teacherMap&quot;&gt;
        &lt;map&gt;
            &lt;entry&gt;
                &lt;key&gt;
                    &lt;value&gt;10010&lt;/value&gt;
                &lt;/key&gt;
                &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt;
            &lt;/entry&gt;
            &lt;entry&gt;
                &lt;key&gt;
                    &lt;value&gt;10086&lt;/value&gt;
                &lt;/key&gt;
                &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean
</code></pre>
<h4 id="3引用集合类型的bean">③引用集合类型的bean</h4>
<pre><code class="language-xml">&lt;!--list集合类型的bean--&gt;
&lt;util:list id=&quot;students&quot;&gt;
    &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt;
    &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt;
    &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;
&lt;/util:list&gt;
&lt;!--map集合类型的bean--&gt;
&lt;util:map id=&quot;teacherMap&quot;&gt;
    &lt;entry&gt;
        &lt;key&gt;
            &lt;value&gt;10010&lt;/value&gt;
        &lt;/key&gt;
        &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
        &lt;key&gt;
            &lt;value&gt;10086&lt;/value&gt;
        &lt;/key&gt;
        &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt;
    &lt;/entry&gt;
&lt;/util:map&gt;
&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring.bean.Clazz&quot;&gt;
    &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;students&quot; ref=&quot;students&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;
    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;抽烟&lt;/value&gt;
            &lt;value&gt;喝酒&lt;/value&gt;
            &lt;value&gt;烫头&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name=&quot;teacherMap&quot; ref=&quot;teacherMap&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>使用util:list、util:map标签必须引入相应的命名空间，可以通过idea的提示功能选择</p>
</blockquote>
<h3 id="229-实验九依赖注入之p命名空间">2.2.9、实验九：依赖注入之p命名空间</h3>
<p>引入p命名空间后，可以通过以下方式为bean的各个属性赋值</p>
<pre><code class="language-xml">&lt;bean id=&quot;studentSix&quot; class=&quot;com.atguigu.spring.bean.Student&quot;
		p:id=&quot;1006&quot; p:name=&quot;小明&quot; p:clazz-ref=&quot;clazzOne&quot; p:teacherMapref=&quot;teacherMap&quot;&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="2210-实验十引入外部属性文件">2.2.10、实验十：引入外部属性文件</h3>
<h4 id="1加入依赖">①加入依赖</h4>
<pre><code class="language-xml">&lt;!-- MySQL驱动 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.16&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 数据源 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.0.31&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="2创建外部属性文件">②创建外部属性文件</h4>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721151535.png" alt="" loading="lazy"></figure>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/ssm?characterEncoding=utf8&amp;useUnicode=true
jdbc.username=root
jdbc.password=
</code></pre>
<h4 id="3引入属性文件">③引入属性文件</h4>
<pre><code class="language-xml">&lt;!-- 引入外部属性文件 --&gt;
&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;
</code></pre>
<h4 id="4配置bean">④配置bean</h4>
<pre><code class="language-xml">&lt;!-- 配置数据源 --&gt;
&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="5测试">⑤测试</h4>
<pre><code class="language-java">@Test
public void testDataSource() throws SQLException {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;springdatasource.xml&quot;);
    DataSource dataSource = ioc.getBean(DataSource.class);
    Connection connection = dataSource.getConnection();
    System.out.println(connection);
}
</code></pre>
<h3 id="2211-实验十一bean的作用域">2.2.11、实验十一：bean的作用域</h3>
<h4 id="1概念">①概念</h4>
<ul>
<li>在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton（默认）</td>
<td>在IOC容器中，这个bean的对象始终为单实例</td>
<td>IOC容器初始化时</td>
</tr>
<tr>
<td>prototype</td>
<td>这个bean在IOC容器中有多个实例</td>
<td>获取bean时</td>
</tr>
</tbody>
</table>
<ul>
<li>如果是在WebApplicationContext环境下还会有另外三个作用域（但不常用）：</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>在一个请求范围内有效</td>
</tr>
<tr>
<td>session</td>
<td>在一个会话范围内有效</td>
</tr>
<tr>
<td>global-session</td>
<td>一般用于Portlet应用环境</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Portlet是可以复用的Web模块,用于管理和显示用户界面。</p>
<p>各作用域范围大小对比<br>
prototype &lt; request &lt; session &lt; global-session &lt; singleton</p>
</blockquote>
<h4 id="2创建类user">②创建类User</h4>
<pre><code class="language-java">public class User {
    
    private Integer id;
    private String username;
    private String password;
    private Integer age;

    public User() {
    }

    public User(Integer id, String username, String password, Integer age) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.age = age;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, username='&quot; + username + '\'' +
                &quot;, password='&quot; + password + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<h4 id="3配置bean">③配置bean</h4>
<p>springscope.xml</p>
<pre><code class="language-xml">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;
&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;
&lt;bean class=&quot;com.atguigu.bean.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
</code></pre>
<h4 id="4测试">④测试</h4>
<pre><code class="language-java">@Test
public void testBeanScope() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;springscope.xml&quot;);
    User user1 = ioc.getBean(User.class);
    User user2 = ioc.getBean(User.class);
    System.out.println(user1 == user2);
}
</code></pre>
<h3 id="2212-实验十二bean的生命周期">2.2.12、实验十二：bean的生命周期</h3>
<h4 id="1具体的生命周期过程">①具体的生命周期过程</h4>
<ul>
<li>bean对象创建（调用无参构造器）</li>
<li>给bean对象设置属性</li>
<li>bean对象初始化之前操作（由bean的后置处理器负责）</li>
<li>bean对象初始化（需在配置bean时指定初始化方法）</li>
<li>bean对象初始化之后操作（由bean的后置处理器负责）</li>
<li>bean对象就绪可以使用</li>
<li>bean对象销毁（需在配置bean时指定销毁方法）</li>
<li>IOC容器关闭</li>
</ul>
<h4 id="2修改类user">②修改类User</h4>
<pre><code class="language-java">public class User {
    private Integer id;
    private String username;
    private String password;
    private Integer age;

    public User() {
        System.out.println(&quot;生命周期：1、创建对象&quot;);
    }

    public User(Integer id, String username, String password, Integer age) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.age = age;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        System.out.println(&quot;生命周期：2、依赖注入&quot;);
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public void initMethod() {
        System.out.println(&quot;生命周期：3、初始化&quot;);
    }

    public void destroyMethod() {
        System.out.println(&quot;生命周期：5、销毁&quot;);
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, username='&quot; + username + '\'' +
                &quot;, password='&quot; + password + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<blockquote>
<p>注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法</p>
</blockquote>
<h4 id="3配置bean-2">③配置bean</h4>
<p>spring-lifecycle.xml</p>
<pre><code class="language-xml">&lt;!-- 使用init-method属性指定初始化方法 --&gt;
&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;
&lt;bean class=&quot;com.atguigu.bean.User&quot; scope=&quot;prototype&quot; init-method=&quot;initMethod&quot;
destroy-method=&quot;destroyMethod&quot;&gt;
		&lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4测试-2">④测试</h4>
<pre><code class="language-java">@Test
public void testLife() {
    ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;);
    User bean = ioc.getBean(User.class);
    System.out.println(&quot;生命周期：4、通过IOC容器获取bean并使用&quot;);
    ioc.close();
}
</code></pre>
<h4 id="5bean的后置处理器">⑤bean的后置处理器</h4>
<ul>
<li>bean的后置处理器会在生命周期的初始化前后添加额外的操作，</li>
<li>需要实现BeanPostProcessor接口，且配置到IOC容器中，</li>
<li>需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行</li>
</ul>
<p>创建bean的后置处理器：</p>
<pre><code class="language-java">package com.atguigu.spring.process;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class MyBeanProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName)
            throws BeansException {
        System.out.println(&quot;☆☆☆&quot; + beanName + &quot; = &quot; + bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName)
            throws BeansException {
        System.out.println(&quot;★★★&quot; + beanName + &quot; = &quot; + bean);
        return bean;
    }
}
</code></pre>
<p>在IOC容器中配置后置处理器：</p>
<pre><code class="language-xml">&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;
&lt;bean id=&quot;myBeanProcessor&quot; class=&quot;com.atguigu.spring.process.MyBeanProcessor&quot;/&gt;
</code></pre>
<h3 id="2213-实验十三factorybean">2.2.13、实验十三：FactoryBean</h3>
<h4 id="1简介">①简介</h4>
<ul>
<li>
<p>FactoryBean是Spring提供的一种整合第三方框架的常用机制。</p>
</li>
<li>
<p>和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。</p>
</li>
<li>
<p>通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。</p>
</li>
<li>
<p>将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。</p>
</li>
</ul>
<pre><code class="language-java">/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory;

import org.springframework.lang.Nullable;

/**
 * Interface to be implemented by objects used within a {@link BeanFactory} which
 * are themselves factories for individual objects. If a bean implements this
 * interface, it is used as a factory for an object to expose, not directly as a
 * bean instance that will be exposed itself.
 *
 * &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a normal bean.&lt;/b&gt;
 * A FactoryBean is defined in a bean style, but the object exposed for bean
 * references ({@link #getObject()}) is always the object that it creates.
 *
 * &lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create
 * objects lazily on demand or eagerly on startup. The {@link SmartFactoryBean}
 * interface allows for exposing more fine-grained behavioral metadata.
 *
 * &lt;p&gt;This interface is heavily used within the framework itself, for example for
 * the AOP {@link org.springframework.aop.framework.ProxyFactoryBean} or the
 * {@link org.springframework.jndi.JndiObjectFactoryBean}. It can be used for
 * custom components as well; however, this is only common for infrastructure code.
 *
 * &lt;p&gt;&lt;b&gt;{@code FactoryBean} is a programmatic contract. Implementations are not
 * supposed to rely on annotation-driven injection or other reflective facilities.&lt;/b&gt;
 * {@link #getObjectType()} {@link #getObject()} invocations may arrive early in the
 * bootstrap process, even ahead of any post-processor setup. If you need access to
 * other beans, implement {@link BeanFactoryAware} and obtain them programmatically.
 *
 * &lt;p&gt;&lt;b&gt;The container is only responsible for managing the lifecycle of the FactoryBean
 * instance, not the lifecycle of the objects created by the FactoryBean.&lt;/b&gt; Therefore,
 * a destroy method on an exposed bean object (such as {@link java.io.Closeable#close()}
 * will &lt;i&gt;not&lt;/i&gt; be called automatically. Instead, a FactoryBean should implement
 * {@link DisposableBean} and delegate any such close call to the underlying object.
 *
 * &lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory's
 * synchronization of bean creation. There is usually no need for internal
 * synchronization other than for purposes of lazy initialization within the
 * FactoryBean itself (or the like).
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @since 08.03.2003
 * @param &lt;T&gt; the bean type
 * @see org.springframework.beans.factory.BeanFactory
 * @see org.springframework.aop.framework.ProxyFactoryBean
 * @see org.springframework.jndi.JndiObjectFactoryBean
 */
public interface FactoryBean&lt;T&gt; {

	/**
	 * The name of an attribute that can be
	 * {@link org.springframework.core.AttributeAccessor#setAttribute set} on a
	 * {@link org.springframework.beans.factory.config.BeanDefinition} so that
	 * factory beans can signal their object type when it can't be deduced from
	 * the factory bean class.
	 * @since 5.2
	 */
	String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;;


	/**
	 * Return an instance (possibly shared or independent) of the object
	 * managed by this factory.
	 * &lt;p&gt;As with a {@link BeanFactory}, this allows support for both the
	 * Singleton and Prototype design pattern.
	 * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of
	 * the call (for example because it is involved in a circular reference),
	 * throw a corresponding {@link FactoryBeanNotInitializedException}.
	 * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return {@code null}
	 * objects. The factory will consider this as normal value to be used; it
	 * will not throw a FactoryBeanNotInitializedException in this case anymore.
	 * FactoryBean implementations are encouraged to throw
	 * FactoryBeanNotInitializedException themselves now, as appropriate.
	 * @return an instance of the bean (can be {@code null})
	 * @throws Exception in case of creation errors
	 * @see FactoryBeanNotInitializedException
	 */
	@Nullable
	T getObject() throws Exception;

	/**
	 * Return the type of object that this FactoryBean creates,
	 * or {@code null} if not known in advance.
	 * &lt;p&gt;This allows one to check for specific types of beans without
	 * instantiating objects, for example on autowiring.
	 * &lt;p&gt;In the case of implementations that are creating a singleton object,
	 * this method should try to avoid singleton creation as far as possible;
	 * it should rather estimate the type in advance.
	 * For prototypes, returning a meaningful type here is advisable too.
	 * &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has
	 * been fully initialized. It must not rely on state created during
	 * initialization; of course, it can still use such state if available.
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return
	 * {@code null} here. Therefore it is highly recommended to implement
	 * this method properly, using the current state of the FactoryBean.
	 * @return the type of object that this FactoryBean creates,
	 * or {@code null} if not known at the time of the call
	 * @see ListableBeanFactory#getBeansOfType
	 */
	@Nullable
	Class&lt;?&gt; getObjectType();

	/**
	 * Is the object managed by this factory a singleton? That is,
	 * will {@link #getObject()} always return the same object
	 * (a reference that can be cached)?
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; If a FactoryBean indicates to hold a singleton object,
	 * the object returned from {@code getObject()} might get cached
	 * by the owning BeanFactory. Hence, do not return {@code true}
	 * unless the FactoryBean always exposes the same reference.
	 * &lt;p&gt;The singleton status of the FactoryBean itself will generally
	 * be provided by the owning BeanFactory; usually, it has to be
	 * defined as singleton there.
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This method returning {@code false} does not
	 * necessarily indicate that returned objects are independent instances.
	 * An implementation of the extended {@link SmartFactoryBean} interface
	 * may explicitly indicate independent instances through its
	 * {@link SmartFactoryBean#isPrototype()} method. Plain {@link FactoryBean}
	 * implementations which do not implement this extended interface are
	 * simply assumed to always return independent instances if the
	 * {@code isSingleton()} implementation returns {@code false}.
	 * &lt;p&gt;The default implementation returns {@code true}, since a
	 * {@code FactoryBean} typically manages a singleton instance.
	 * @return whether the exposed object is a singleton
	 * @see #getObject()
	 * @see SmartFactoryBean#isPrototype()
	 */
	default boolean isSingleton() {
		return true;
	}

}
</code></pre>
<h4 id="2创建类userfactorybean">②创建类UserFactoryBean</h4>
<pre><code class="language-java">public class UserFactoryBean implements FactoryBean&lt;User&gt; {
    @Override
    public User getObject() throws Exception {
        return new User();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return User.class;
    }
}
</code></pre>
<h4 id="3配置bean-3">③配置bean</h4>
<p>springfactorybean.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.bean.UserFactoryBean&quot;&gt;&lt;/bean&gt;
</code></pre>
<h4 id="4测试-3">④测试</h4>
<pre><code class="language-java">@Test
public void testUserFactoryBean() {
    //获取IOC容器
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;springfactorybean.xml&quot;);
    User user = (User) ioc.getBean(&quot;user&quot;);
    System.out.println(user);
}
</code></pre>
<h3 id="2214-实验十四基于xml的自动装配">2.2.14、实验十四：基于xml的自动装配</h3>
<blockquote>
<p>自动装配：</p>
<p>根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值</p>
</blockquote>
<h4 id="1场景模拟">①场景模拟</h4>
<p>创建类UserController</p>
<pre><code class="language-java">public class UserController {
    private UserService userService;

    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public void saveUser() {
        userService.saveUser();
    }
}
</code></pre>
<p>创建接口UserService</p>
<pre><code class="language-java">public interface UserService {
    
    void saveUser();
    
}
</code></pre>
<p>创建类UserServiceImpl实现接口UserService</p>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
    private UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void saveUser() {
        userDao.saveUser();
    }
}
</code></pre>
<p>创建接口UserDao</p>
<pre><code class="language-java">public interface UserDao {

    void saveUser();
    
}
</code></pre>
<p>创建类UserDaoImpl实现接口UserDao</p>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {

    @Override
    public void saveUser() {
        System.out.println(&quot;保存成功&quot;);
    }
    
}
</code></pre>
<h4 id="2配置bean-3">②配置bean</h4>
<p>autowirexml.xml</p>
<blockquote>
<p>使用bean标签的autowire属性设置自动装配效果</p>
<p>自动装配方式：byType</p>
<p>byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值</p>
<p>若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值 null</p>
<p>若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionException</p>
</blockquote>
<pre><code class="language-xml">&lt;bean id=&quot;userController&quot;
class=&quot;com.atguigu.autowire.xml.controller.UserController&quot; autowire=&quot;byType&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userService&quot;
class=&quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
</code></pre>
<blockquote>
<p>自动装配方式：byName</p>
<p>byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值</p>
</blockquote>
<pre><code class="language-xml">&lt;bean id=&quot;userController&quot;
class=&quot;com.atguigu.autowire.xml.controller.UserController&quot; autowire=&quot;byName&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userService&quot;
class=&quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userServiceImpl&quot;
class=&quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&quot;&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="3测试-3">③测试</h4>
<pre><code class="language-java">@Test
public void testAutoWireByXML() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;autowirexml.xml&quot;);
    UserController userController = ioc.getBean(UserController.class);
    userController.saveUser();
}
</code></pre>
<h2 id="23-基于注解管理bean">2.3、基于注解管理bean</h2>
<h3 id="231-实验一标记与扫描">2.3.1、实验一：标记与扫描</h3>
<h4 id="1注解">①注解</h4>
<ul>
<li>和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。</li>
<li>本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。</li>
<li>举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721171841.png" alt="" loading="lazy"></figure>
<ul>
<li>班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们 做的工作，相当于框架的具体操作。</li>
</ul>
<h4 id="2扫描">②扫描</h4>
<ul>
<li>Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。</li>
</ul>
<h4 id="3新建maven-module">③新建Maven Module</h4>
<pre><code class="language-xml">&lt;dependencies&gt;

    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    
&lt;/dependencies&gt;
</code></pre>
<h4 id="4创建spring配置文件">④创建Spring配置文件</h4>
<ul>
<li>applicationContext.xml</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721172818.png" alt="" loading="lazy"></figure>
<h4 id="5标识组件的常用注解">⑤标识组件的常用注解</h4>
<blockquote>
<p>@Component：将类标识为普通组件</p>
<p>@Controller：将类标识为控制层组件</p>
<p>@Service：将类标识为业务层组件</p>
<p>@Repository：将类标识为持久层组件</p>
</blockquote>
<p>问：以上四个注解有什么关系和区别？</p>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721173246.png" alt="" loading="lazy"></figure>
<ul>
<li>通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。</li>
<li>对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。</li>
<li>注意：虽然它们本质上一样，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。</li>
</ul>
<h4 id="6创建组件">⑥创建组件</h4>
<p>创建控制层组件</p>
<pre><code class="language-java">@Controller
public class UserController {

}
</code></pre>
<p>创建接口UserService</p>
<pre><code class="language-java">public interface UserService {

}
</code></pre>
<p>创建业务层组件UserServiceImpl</p>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {
  
}
</code></pre>
<p>创建接口UserDao</p>
<pre><code class="language-java">public interface UserDao {
  
}
</code></pre>
<p>创建持久层组件UserDaoImpl</p>
<pre><code class="language-java">@Repository
public class UserDaoImpl implements UserDao {

}
</code></pre>
<h4 id="7扫描组件">⑦扫描组件</h4>
<p>情况一：最基本的扫描方式</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;
&lt;/context:component-scan&gt;
</code></pre>
<p>情况二：指定要排除的组件</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;
    &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;
    &lt;!--
            type：设置排除或包含的依据
            type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名
            type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名
    --&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot;
                            expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.controller.UserController&quot;/&gt;--&gt;
&lt;/context:component-scan&gt;
</code></pre>
<p>情况三：仅扫描指定组件</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt;
    &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;
    &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;
    &lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt;
    &lt;!--
            type：设置排除或包含的依据
            type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名
            type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名
    --&gt;
    &lt;context:include-filter type=&quot;annotation&quot;
                            expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;!--&lt;context:include-filter type=&quot;assignable&quot;
        expression=&quot;com.atguigu.controller.UserController&quot;/&gt;--&gt;
&lt;/context:component-scan&gt;
</code></pre>
<h4 id="8测试">⑧测试</h4>
<pre><code class="language-java">@Test
public void testAutowireByAnnotation() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    UserController userController = ioc.getBean(UserController.class);
    System.out.println(userController);
    UserService userService = ioc.getBean(UserService.class);
    System.out.println(userService);
    UserDao userDao = ioc.getBean(UserDao.class);
    System.out.println(userDao);
}
</code></pre>
<h4 id="9组件所对应的bean的id">⑨组件所对应的bean的id</h4>
<p>在我们使用XML方式管理bean的时候，每个bean都有一个唯一标识，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。</p>
<blockquote>
<p>默认情况</p>
<p>类名首字母小写就是bean的id。例如：UserController类对应的bean的id就是userController。</p>
<p>自定义bean的id</p>
<p>可通过标识组件的注解的value属性设置自定义的bean的id</p>
<p>@Service(&quot;userService&quot;)//默认为userServiceImpl public class UserServiceImpl implements UserService {}</p>
</blockquote>
<h3 id="232-实验二基于注解的自动装配">2.3.2、实验二：基于注解的自动装配</h3>
<h4 id="1场景模拟-2">①场景模拟</h4>
<blockquote>
<p>参考基于xml的自动装配</p>
<p>在UserController中声明UserService对象</p>
<p>在UserServiceImpl中声明UserDao对象</p>
</blockquote>
<h4 id="2-autowired注解">② @Autowired注解</h4>
<p>在成员变量上直接标记@Autowired注解即可完成自动装配，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。</p>
<pre><code class="language-java">@Controller
public class UserController {
  
    @Autowired
    private UserService userService;
  
    public void saveUser() {
        userService.saveUser();
    }
  
}
</code></pre>
<pre><code class="language-java">public interface UserService {
    void saveUser();
}
</code></pre>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {
  
    @Autowired
    private UserDao userDao;
  
    @Override
    public void saveUser() {
        userDao.saveUser();
    }
  
}
</code></pre>
<pre><code class="language-java">public interface UserDao {
    void saveUser();
}
</code></pre>
<pre><code class="language-java">@Repository
public class UserDaoImpl implements UserDao {
    @Override
    public void saveUser() {
        System.out.println(&quot;保存成功&quot;);
    }
}
</code></pre>
<h4 id="3-autowired注解其他细节">③ @Autowired注解其他细节</h4>
<blockquote>
<p>@Autowired注解可以标记在<code>构造器</code>和<code>set方法</code>上</p>
</blockquote>
<pre><code class="language-java">@Controller
public class UserController {
    private UserService userService;
    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }
    public void saveUser() {
        userService.saveUser();
    }
}
</code></pre>
<pre><code class="language-java">@Controller
public class UserController {
  
    private UserService userService;
  
    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
  
    public void saveUser() {
        userService.saveUser();
    }
}
</code></pre>
<h4 id="4-autowired工作流程">④ @Autowired工作流程</h4>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721193212.png" alt="" loading="lazy"></figure>
<ul>
<li>首先根据所需要的组件类型到IOC容器中查找
<ul>
<li>能够找到唯一的bean：直接执行装配</li>
<li>如果完全找不到匹配这个类型的bean：装配失败</li>
<li>和所需类型匹配的bean不止一个
<ul>
<li>没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配
<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
<li>使用@Qualifier注解：根据@Qualifier注解中指定的名称作为bean的id进行匹配
<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Controller
public class UserController {
  
    @Autowired
    @Qualifier(&quot;userServiceImpl&quot;)
    private UserService userService;
  
    public void saveUser() {
        userService.saveUser();
    }
}
</code></pre>
<blockquote>
<p><strong>佛系装配</strong></p>
<p>@Autowired中有属性required，默认值为true，因此在自动装配无法找到相应的bean时，会装配失败</p>
<p>可以将属性required的值设置为false，则表示能装就装，装不上就不装.</p>
<p>但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性。</p>
<p>如果类中同时存在装配属性的 setXxx() 方法会使 required = false 设定失效。</p>
</blockquote>
<blockquote>
<h3 id="注意">注意</h3>
<ul>
<li>在使用@Autowire的过程中会发现IDEA提示<code>不建议使用字段注入</code>，我们查看检查描述可以看到这样容易抛出 <code>NullPointerException</code>,提供的解决方案是将字段使用<code>final</code>修饰，通过<code>构造器</code>注入.</li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727184152.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727184929.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>我们点击自动修复</p>
<figure data-type="image" tabindex="13"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727185722.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>在完成修复后我们注意到没有了任何注解，并且UserService能够正常的注入进来</p>
<p><code>UserController{userService=com.atguigu.service.impl.UserServiceImpl@4ac3c60d}</code></p>
</li>
<li>
<p>这是因为从 Spring Framework 4.3 开始，<code>@Autowired</code>如果<code>目标 bean 仅定义一个构造函数</code>，则<code>不再需要</code>对此类构造函数进行<code>注解声明</code>。</p>
<ul>
<li>即上述代码等价于</li>
</ul>
<pre><code class="language-java">@Controller
public class UserController {
  
    private final UserService userService;

    @Autowired //这里IDEA不会报警告
    public UserController(UserService userService) {
        this.userService = userService;
    }
  
}
</code></pre>
<ul>
<li>
<p>也即每个需要注入的属性需要<code>final</code>修饰且要有相应的<code>参数构造器</code>，自然当前类也只能有参数构造器不能有空参构造器。</p>
<p>假设当前类有两个需要注入的属性字段：</p>
<p>正确的代码：</p>
<pre><code class="language-java">private final CommonComponent commonComponent;
private final UserService userService;

public UserController(UserService userService, CommonComponent commonComponent) {
    this.userService = userService;
    this.commonComponent = commonComponent;
}
</code></pre>
<p>错误的代码:</p>
<pre><code class="language-java">private final CommonComponent commonComponent;
private final UserService userService;


//错误开始
public UserController() {
  
}
//错误结束


/*
a. 因为空参构造器会造成commonComponent或userService尚未初始化。（final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化）
b. 同理也不能有只含commonComponent或userService的单参构造器。
*/


public UserController(UserService userService, CommonComponent commonComponent) {
    this.userService = userService;
    this.commonComponent = commonComponent;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="5总结">⑤总结</h4>
<p>基于注解的自动装配</p>
<ul>
<li>
<p>方式一：使用<code>构造器注入</code></p>
<ul>
<li>使用IDEA自动修复功能完成</li>
</ul>
<pre><code class="language-java">@Controller
public class UserController {
  
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }
  
}
</code></pre>
</li>
<li>
<p>方式二：使用<code>@Resource</code>替代@Autowired</p>
<ul>
<li>@Resource和@Autowired和都可以用于来实现依赖注入，但前者为JDK（JSR-250标准）自带的，后者是Spring提供的。</li>
<li>使用这种方式IDEA不会抱警告，但这种方式本质仍然是Field注入。</li>
<li>Field注入的缺点很明显，比如不能像构造器注入那样注入不可变的对象，依赖对外部不可见（构造器和Setter可见，而private的属性不可见），会导致组件与IoC容器（比如Spring）紧密耦合，单元测试也需要使用IoC容器，依赖过多时相对构造器注入不能够明显的看出依赖过多（违反单一职责原则）。</li>
<li>既然Field注入这么多缺点，但为什么大家还是习惯使用呢？主要原因：太方便了，极大的缩减了代码。而且大多数业务并不需要用构造器强绑定，同时换IoC容器的可能性也极低。所以，虽然Spring及IDE一直强调和提醒，但貌似并没有阻止程序员的使用。</li>
<li>为什么只对@Autowired警告？</li>
<li>最主要的原因可能是：@Autowired是Spring提供的，是特定IoC提供的特定注解，与框架形成了强绑定，一旦换用其他IoC框架，是无法支持注入的。而@Resource是JSR-250提供的，IoC容器应当去兼容它，即使更换容器，也可以正常工作。</li>
</ul>
<pre><code class="language-java">@Resource
private UserService userService;
</code></pre>
</li>
<li>
<p>方式三：使用Lombok的<code>@RequiredArgsConstructor</code>配合<code>final field</code></p>
<pre><code class="language-java">@Controller
@RequiredArgsConstructor
public class UserController {
    
    private final UserService userService;

}
</code></pre>
</li>
</ul>
<h3 id="233-实验三完全注解开发">2.3.3、实验三：完全注解开发</h3>
<p>体验完全注解开发，是为了给将来学习 SpringBoot 打基础。因为在 SpringBoot 中，就是完全舍弃 XML 配置文件，全面使用注解来完成主要的配置。</p>
<h4 id="1创建配置类">①创建配置类</h4>
<p>使用 @Configuration 注解将一个普通的类标记为 Spring 的配置类。</p>
<pre><code class="language-java">package com.atguigu.ioc.configuration;
    
import org.springframework.context.annotation.Configuration;
    
@Configuration
public class MyConfiguration {
  
}
</code></pre>
<h4 id="2根据配置类创建ioc容器对象">②根据配置类创建IOC容器对象</h4>
<pre><code class="language-java">// ClassPathXmlApplicationContext 根据 XML 配置文件创建 IOC 容器对象
private ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象
private ApplicationContext ioc = new AnnotationConfigApplicationContext(MyConfiguration.class);
</code></pre>
<h4 id="3在配置类中配置bean">③在配置类中配置bean</h4>
<p>使用@Bean注解</p>
<pre><code class="language-java">@Configuration
public class MyConfiguration {
  
    // @Bean 注解相当于 XML 配置文件中的 bean 标签
    // @Bean 注解标记的方法的返回值会被放入 IOC 容器
    // 默认以方法名作为 bean 的 id
    @Bean
    public CommonComponent getComponent() {
      
        CommonComponent commonComponent = new CommonComponent();
      
        commonComponent.setComponentName(&quot;created by annotation config&quot;);
      
        return commonComponent;
    }
}
</code></pre>
<h4 id="4在配置类中配置自动扫描的包">④在配置类中配置自动扫描的包</h4>
<p>使用@ComponentScan注解</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.atguigu.ioc.component&quot;)
public class MyConfiguration {
    ……
}
</code></pre>
<h3 id="234-实验四整合junit4">2.3.4、实验四：整合junit4</h3>
<h4 id="1整合的好处">①整合的好处</h4>
<ul>
<li>好处1：不需要自己创建IOC容器对象了</li>
<li>好处2：任何需要的bean都可以在测试类中直接享受自动装配</li>
</ul>
<h4 id="2操作">②操作</h4>
<p>加入依赖</p>
<pre><code class="language-xml">&lt;!-- Spring的测试包 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>创建测试类</p>
<pre><code class="language-java">// junit的@RunWith注解：指定Spring为Junit提供的运行器
@RunWith(SpringJUnit4ClassRunner.class)

// Spring的@ContextConfiguration指定Spring配置文件的位置
@ContextConfiguration(value = {&quot;classpath:applicationContext.xml&quot;})
public class JunitIntegrationSpring {
    
    @Autowired
    private SoldierController soldierController;
    
    @Test
    public void testIntegration() {
        System.out.println(&quot;soldierController = &quot; + soldierController);
    }
    
}
</code></pre>
<h1 id="3-aop">3、AOP</h1>
<h2 id="31-场景模拟">3.1、场景模拟</h2>
<h3 id="311-声明接口">3.1.1、声明接口</h3>
<p>声明计算器接口Calculator，包含加减乘除的抽象方法</p>
<pre><code class="language-java">public interface Calculator {
    
    int add(int i, int j);
  
    int sub(int i, int j);
  
    int mul(int i, int j);
  
    int div(int i, int j);
    
}
</code></pre>
<h3 id="312-创建实现类">3.1.2、创建实现类</h3>
<figure data-type="image" tabindex="14"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721205610.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">public class CalculatorPureImpl implements Calculator {
    
    @Override
    public int add(int i, int j) {
        int result = i + j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        int result = i - j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        int result = i * j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        int result = i / j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
}
</code></pre>
<h3 id="313-创建带日志功能的实现类">3.1.3、创建带日志功能的实现类</h3>
<figure data-type="image" tabindex="15"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721205850.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">public class CalculatorLogImpl implements Calculator {
    
    @Override
    public int add(int i, int j) {
        System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);
        int result = i + j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        System.out.println(&quot;[日志] sub 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);
        int result = i - j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        System.out.println(&quot;[日志] sub 方法结束了，结果是：&quot; + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);
        int result = i * j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        System.out.println(&quot;[日志] div 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);
        int result = i / j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        System.out.println(&quot;[日志] div 方法结束了，结果是：&quot; + result);
        return result;
    }
  
}
</code></pre>
<h3 id="314-提出问题">3.1.4、提出问题</h3>
<h4 id="1现有代码缺陷">①现有代码缺陷</h4>
<p>针对带日志功能的实现类，我们发现有如下缺陷：</p>
<ul>
<li>对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力</li>
<li>附加功能分散在各个业务功能方法中，不利于统一维护</li>
</ul>
<h4 id="2解决思路">②解决思路</h4>
<p>解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。</p>
<h4 id="3困难">③困难</h4>
<p>解决问题的困难：要抽取的代码在方法内部，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。</p>
<h2 id="32-代理模式">3.2、代理模式</h2>
<h3 id="321-概念">3.2.1、概念</h3>
<h4 id="1介绍">①介绍</h4>
<p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类<strong>间接</strong>调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——<strong>解耦</strong>。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p>
<figure data-type="image" tabindex="16"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721210816.png" alt="" loading="lazy"></figure>
<p>使用代理后：</p>
<figure data-type="image" tabindex="17"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721210900.png" alt="" loading="lazy"></figure>
<h4 id="2生活中的代理">②生活中的代理</h4>
<ul>
<li>广告商找大明星拍广告需要经过经纪人</li>
<li>合作伙伴找大老板谈合作要约见面时间需要经过秘书</li>
<li>房产中介是买卖双方的代理</li>
</ul>
<h4 id="3相关术语">③相关术语</h4>
<ul>
<li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。</li>
<li>目标：<strong>被代理</strong>“套用”了非核心逻辑代码的类、对象、方法。</li>
</ul>
<h3 id="322-静态代理">3.2.2、静态代理</h3>
<p>创建静态代理类：</p>
<pre><code class="language-java">public class CalculatorStaticProxy implements Calculator {
  
    // 将被代理的目标对象声明为成员变量
    private Calculator target;
  
    public CalculatorStaticProxy(Calculator target) {
        this.target = target;
    }
  
    @Override
    public int add(int i, int j) {
      
        // 附加功能由代理类中的代理方法来实现
        System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);
      
        // 通过目标对象来实现核心业务逻辑
        int addResult = target.add(i, j);
      
        System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + addResult);
      
        return addResult;
    }
  
}
</code></pre>
<blockquote>
<p>静态代理确实实现了解耦，但是由于代码都<strong>写死了</strong>，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。</p>
<p>提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。</p>
</blockquote>
<h3 id="323-动态代理">3.2.3、动态代理</h3>
<figure data-type="image" tabindex="18"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721211704.png" alt="" loading="lazy"></figure>
<p>生产代理对象的工厂类：</p>
<pre><code class="language-java">public class ProxyFactory {
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    public Object getProxy() {

        /**
         * newProxyInstance()：创建一个代理实例
         * 其中有三个参数：
         * 1、classLoader：加载动态生成的代理类的类加载器
         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组
         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法
         */

        ClassLoader classLoader = target.getClass().getClassLoader();
        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();
        InvocationHandler invocationHandler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args)
                    throws Throwable {
                /**
                 * proxy：代理对象
                 * method：代理对象需要实现的方法，即其中需要重写的方法
                 * args：method所对应方法的参数
                 */
                Object result = null;
                try {
                    System.out.println(&quot;[动态代理][日志] &quot; + method.getName() + &quot;，参数：&quot; + Arrays.toString(args));
                    result = method.invoke(target, args);
                    System.out.println(&quot;[动态代理][日志] &quot; + method.getName() + &quot;，结果：&quot; + result);
                } catch (Exception e) {
                    e.printStackTrace();
                    System.out.println(&quot;[动态代理][日志] &quot; + method.getName() + &quot;，异常：&quot; + e.getMessage());
                } finally {
                    System.out.println(&quot;[动态代理][日志] &quot; + method.getName() + &quot;，方法执行完毕&quot;);
                }
                return result;
            }
        };
        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
    }
}
</code></pre>
<h3 id="324-测试">3.2.4、测试</h3>
<pre><code class="language-java">@Test
public void testDynamicProxy() {
    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());
    Calculator proxy = (Calculator) factory.getProxy();
    proxy.div(1, 0);
    //proxy.div(1,1);
}
</code></pre>
<h2 id="33-aop概念及相关术语">3.3、AOP概念及相关术语</h2>
<h3 id="331-概述">3.3.1、概述</h3>
<ul>
<li>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术。</li>
<li>AOP的核心套路</li>
</ul>
<figure data-type="image" tabindex="19"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721215952.png" alt="" loading="lazy"></figure>
<h3 id="332-相关术语">3.3.2、相关术语</h3>
<figure data-type="image" tabindex="20"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722120920.png" alt="" loading="lazy"></figure>
<h4 id="1横切关注点连接点">①横切关注点(连接点)</h4>
<ul>
<li>从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。</li>
<li>这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：<strong>有十个附加功能，就有十个横切关注点。</strong></li>
</ul>
<figure data-type="image" tabindex="21"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721220106.png" alt="" loading="lazy"></figure>
<h4 id="2通知记住">②通知【记住】</h4>
<p>每一个横切关注点上要做的事情都需要写一个方法（<strong>实际增强的逻辑部分</strong>）来实现，这样的方法就叫<strong>通知方法</strong>。</p>
<ul>
<li>前置通知：在被代理的目标方法<strong>前</strong>执行</li>
<li>返回通知：在被代理的目标方法<strong>成功结束</strong>后执行</li>
<li>异常通知：在被代理的目标方法<strong>异常结束</strong>后执行</li>
<li>后置通知：在被代理的目标方法<strong>最终结束</strong>后执行</li>
<li>环绕通知：使用try...catch...finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<figure data-type="image" tabindex="22"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721220834.png" alt="" loading="lazy"></figure>
<h4 id="3切面记住">③切面【记住】</h4>
<p>封装通知方法的<strong>类</strong>。</p>
<figure data-type="image" tabindex="23"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721221150.png" alt="" loading="lazy"></figure>
<h4 id="4目标">④目标</h4>
<p>被代理的<strong>目标对象</strong>。</p>
<h4 id="5代理">⑤代理</h4>
<p>向目标对象应用通知之后创建的<strong>代理对象</strong>。</p>
<h4 id="6连接点">⑥连接点</h4>
<ul>
<li><strong>类里面哪些方法可以被增强，这些方法称为连接点</strong></li>
</ul>
<p>这也是一个纯逻辑概念，不是语法定义的。</p>
<p>把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。</p>
<figure data-type="image" tabindex="24"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721221557.png" alt="" loading="lazy"></figure>
<h4 id="7切入点记住">⑦切入点【记住】</h4>
<ul>
<li><strong>实际被增强的方法，称为切入点。</strong></li>
</ul>
<p>定位连接点的方式。</p>
<p>每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。</p>
<p>如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。</p>
<p>Spring 的 AOP 技术可以通过切入点定位到特定的连接点。</p>
<p>切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p>
<h4 id="8织入">⑧织入</h4>
<ul>
<li>织入是动作，就是把通知应用到切入点来创建代理对象的<strong>过程</strong>。</li>
</ul>
<h3 id="333-作用">3.3.3、作用</h3>
<ul>
<li>简化代码：把方法中固定位置的重复的代码<strong>抽取</strong>出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。</li>
<li>代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被<strong>套用</strong>了切面逻辑的方法就被切面给增强了。</li>
</ul>
<h2 id="34-基于注解的aop">3.4、基于注解的AOP</h2>
<h3 id="341-技术说明">3.4.1、技术说明</h3>
<img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722142959.png"/>
<ul>
<li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式）。</li>
<li>cglib：通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</li>
<li>AspectJ：本质上是静态代理，<strong>将代理逻辑“织入”被代理的目标类编译得到的字节码文件</strong>，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。</li>
</ul>
<h3 id="342-准备工作">3.4.2、准备工作</h3>
<h4 id="1添加依赖">①添加依赖</h4>
<p>在IOC所需依赖基础上再加入下面依赖即可：</p>
<pre><code class="language-xml">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;
&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
		&lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="2准备被代理的目标资源">②准备被代理的目标资源</h4>
<p>接口：</p>
<pre><code class="language-java">public interface Calculator {
    
    int add(int i, int j);
  
    int sub(int i, int j);
  
    int mul(int i, int j);
  
    int div(int i, int j);
    
}
</code></pre>
<p>实现类：</p>
<pre><code class="language-java">public class CalculatorPureImpl implements Calculator {
    
    @Override
    public int add(int i, int j) {
        int result = i + j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        int result = i - j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        int result = i * j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        int result = i / j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
}
</code></pre>
<h3 id="343-创建切面类并配置">3.4.3、创建切面类并配置</h3>
<pre><code class="language-java">// @Aspect表示这个类是一个切面类
@Aspect
// @Component注解保证这个切面类能够放入IOC容器
@Component
public class LogAspect {

    // @Before注解：声明当前方法是前置通知方法
    // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上
    @Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)
    public void printLogBeforeCore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());
        System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot; + methodName + &quot;，参数：&quot; + args);
    }

    @Afterr(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)
    public void printLogFinallyEnd() {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot; + methodName);
    }

    @AfterReturningg(value = &quot;execution(*
            com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)

    public void printLogAfterException(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot; + methodName + &quot;，结果：&quot; + result);
    }


    @AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)
    public void printLogAfterSuccess(JoinPoint joinPoint, Throwable ex) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot; + methodName + &quot;，异常：&quot; + ex);
    }


    @Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)
    public Object aroundMethod(ProceedingJoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());
        Object result = null;
        try {
            System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);
            //目标对象（连接点）方法的执行
            result = joinPoint.proceed();
            System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);
        } finally {
            System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);
        }
        return result;
    }

}
</code></pre>
<p>在Spring的配置文件中配置：</p>
<pre><code class="language-xml">&lt;!--
基于注解的AOP的实现：
1、将目标对象和切面交给IOC容器管理（注解+扫描）
2、开启基于注解的AOP功能 (开启AspectJ的自动代理，为目标对象自动生成代理)
3、将切面类通过注解@Aspect标识
 --&gt;

&lt;!-- 配置自动扫描的包 --&gt;
&lt;context:component-scan base-package=&quot;com.atguigu.aop.annotation&quot;/&gt;

&lt;!-- 开启基于注解的AOP功能 --&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<h3 id="344-各种通知">3.4.4、各种通知</h3>
<ul>
<li>前置通知：使用@Before注解标识，在被代理的目标方法<strong>前</strong>执行</li>
<li>返回通知：使用@AfterReturning注解标识，在被代理的目标方法<strong>成功结束</strong>后执行</li>
<li>异常通知：使用@AfterThrowing注解标识，在被代理的目标方法<strong>异常结束</strong>后执行</li>
<li>后置通知：使用@After注解标识，在被代理的目标方法<strong>最终结束</strong>后执行</li>
<li>环绕通知：使用@Around注解标识，使用try...catch...finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<blockquote>
<h4 id="各种通知的执行顺序">各种通知的执行顺序：</h4>
<ul>
<li>Spring版本5.3.x以前：
<ul>
<li>前置通知</li>
<li>目标操作</li>
<li>后置通知</li>
<li>返回通知或异常通知</li>
</ul>
</li>
<li>Spring版本5.3.x以后：
<ul>
<li>前置通知</li>
<li>目标操作</li>
<li>返回通知或异常通知</li>
<li>后置通知</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="345-切入点表达式语法">3.4.5、切入点表达式语法</h3>
<h4 id="1作用">①作用</h4>
<figure data-type="image" tabindex="25"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722165001.png" alt="" loading="lazy"></figure>
<h4 id="2语法细节">②语法细节</h4>
<ul>
<li>用 * 号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限</li>
<li>在包名的部分，一个 * 号只能代表包的层次结构中的一层，表示这一层是任意的。
<ul>
<li>例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello</li>
</ul>
</li>
<li>在包名的部分，使用“*..”表示包名任意、包的层次深度任意</li>
<li>在类名的部分，类名部分整体用*号代替，表示类名任意</li>
<li>在类名的部分，可以使用*号代替类名的一部分
<ul>
<li>例如：*Service匹配所有名称以Service结尾的类或接口</li>
</ul>
</li>
<li>在方法名部分，可以使用*号表示方法名任意</li>
<li>在方法名部分，可以使用*号代替方法名的一部分
<ul>
<li>例如：*Operation匹配所有方法名以Operation结尾的方法</li>
</ul>
</li>
<li>在方法参数列表部分，使用(..)表示参数列表任意</li>
<li>在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头</li>
<li>在方法参数列表部分，基本数据类型和对应的包装类型是不一样的
<ul>
<li>切入点表达式中使用 int 和实际方法中 Integer 是不匹配的</li>
</ul>
</li>
<li>在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符
<ul>
<li>例如：execution(public int ..Service.*(.., int)) <code>正确</code></li>
<li>例如：execution(* int ..Service.*(.., int)) <code>错误</code></li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="26"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722170459.png" alt="" loading="lazy"></figure>
<blockquote>
<h4 id="tip">TIP</h4>
<p>虽然我们上面介绍过的切入点表达式语法细节很多，有很多变化，但是实际上具体在项目中应用时有比较固定的写法。</p>
<p>典型场景：在基于 XML 的声明式事务配置中需要指定切入点表达式。这个切入点表达式通常都会套用到所有 Service 类（接口）的所有方法。那么切入点表达式将如下所示：</p>
<p><code>execution(* *..*Service.*(..))</code></p>
</blockquote>
<h3 id="346-重用切入点表达式">3.4.6、重用切入点表达式</h3>
<h4 id="1声明">①声明</h4>
<pre><code class="language-java">@Pointcut(&quot;execution(* com.atguigu.aop.annotation.*.*(..))&quot;)
public void pointCut(){}
</code></pre>
<h4 id="2在同一个切面中使用">②在同一个切面中使用</h4>
<pre><code class="language-java">@Before(&quot;pointCut()&quot;)
public void beforeMethod(JoinPoint joinPoint) {
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot; + methodName + &quot;，参数：&quot; + args);
}
</code></pre>
<h4 id="3在不同切面中使用">③在不同切面中使用</h4>
<pre><code class="language-java">@Before(&quot;com.atguigu.aop.CommonPointCut.pointCut()&quot;)
public void beforeMethod(JoinPoint joinPoint) {
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot; + methodName + &quot;，参数：&quot; + args);
}
</code></pre>
<h3 id="347-获取通知的相关信息">3.4.7、获取通知的相关信息</h3>
<h4 id="1获取连接点信息">①获取连接点信息</h4>
<p>获取连接点信息可以在通知方法的参数位置设置<code>JoinPoint</code>类型的形参</p>
<pre><code class="language-java">@Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)
public void beforeMethod(JoinPoint joinPoint) {
    //获取连接点的签名信息
    String methodName = joinPoint.getSignature().getName();
    //获取目标方法到的实参信息
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot; + methodName + &quot;，参数：&quot; + args);
}
</code></pre>
<h4 id="2获取目标方法的返回值">②获取目标方法的返回值</h4>
<p><code>@AfterReturning</code>中的属性<code>returning</code>，用来将通知方法的某个形参，接收目标方法的返回值</p>
<pre><code class="language-java">@AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.* (..))&quot;, returning = &quot;result&quot;)
public void afterReturningMethod(JoinPoint joinPoint, Object result) {
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot; + methodName + &quot;，结果：&quot; + result);
}
</code></pre>
<h4 id="3获取目标方法的异常">③获取目标方法的异常</h4>
<p><code>@AfterThrowing</code>中的属性<code>throwing</code>，用来将通知方法的某个形参，接收目标方法的异常</p>
<pre><code class="language-java">@AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.* (..))&quot;, throwing = &quot;ex&quot;)
public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex) {
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot; + methodName + &quot;，异常：&quot; + ex);
}
</code></pre>
<h3 id="348-环绕通知">3.4.8、环绕通知</h3>
<ul>
<li>环绕通知类似于动态代理的具体实现</li>
<li>注意环绕通知的JoinPoint类型是<code>ProceedingJoinPoint</code></li>
</ul>
<pre><code class="language-java">@Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)
public Object aroundMethod(ProceedingJoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    Object result = null;
    try {
        System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);
        //目标对象（连接点）方法的执行
        result = joinPoint.proceed();
        System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);
    } catch (Throwable throwable) {
        throwable.printStackTrace();
        System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);
    } finally {
        System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);
    }
    return result;
}
</code></pre>
<h3 id="349-切面的优先级">3.4.9、切面的优先级</h3>
<h4 id="1概念-2">①概念</h4>
<p>相同目标方法上同时存在多个切面时，切面的优先级控制按照切面的<code>内外嵌套</code>顺序。</p>
<ul>
<li>优先级高的切面：外面</li>
<li>优先级低的切面：里面</li>
</ul>
<p>使用<code>@Order</code>注解可以控制切面的优先级：</p>
<ul>
<li>@Order(较小的数)：优先级高</li>
<li>@Order(较大的数)：优先级低</li>
</ul>
<figure data-type="image" tabindex="27"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722173445.png" alt="" loading="lazy"></figure>
<h4 id="2实际意义">②实际意义</h4>
<p>实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。</p>
<figure data-type="image" tabindex="28"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722174955.png" alt="" loading="lazy"></figure>
<p>此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。</p>
<figure data-type="image" tabindex="29"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722175037.png" alt="" loading="lazy"></figure>
<h3 id="3410-没有接口的情况">3.4.10、没有接口的情况</h3>
<ul>
<li>在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。为了证明这一点，我们做下面的测试：</li>
</ul>
<h4 id="1创建目标类">①创建目标类</h4>
<p>请确保这个类在自动扫描的包下，同时确保切面的切入点表达式能够覆盖到类中的方法。</p>
<pre><code class="language-java">@Service
public class EmployeeService {
    
    public void getEmpList() {
        System.out.println(&quot;方法内部 com.atguigu.aop.imp.EmployeeService.getEmpList&quot;);
    }
    
}
</code></pre>
<h4 id="2测试">②测试</h4>
<pre><code class="language-java">@Autowired
private EmployeeService employeeService;

@Test
public void testNoInterfaceProxy() {
    employeeService.getEmpList();
    System.out.println();
}
</code></pre>
<h4 id="3debug查看">③Debug查看</h4>
<ul>
<li>
<p>没有实现接口情况</p>
<figure data-type="image" tabindex="30"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722180742.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>有实现接口的情况</p>
<figure data-type="image" tabindex="31"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722180811.png" alt="" loading="lazy"></figure>
</li>
</ul>
<p>同时我们发现：Mybatis 调用的 Mapper 接口类型的对象其实也是动态代理机制</p>
<figure data-type="image" tabindex="32"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722180853.png" alt="" loading="lazy"></figure>
<h2 id="35-基于xml的aop了解">3.5、基于XML的AOP（了解）</h2>
<h3 id="351-准备工作">3.5.1、准备工作</h3>
<h4 id="1添加依赖-2">①添加依赖</h4>
<p>和基于注解的 AOP 时一样。</p>
<h4 id="2准备代码">②准备代码</h4>
<p>把测试基于注解功能时的Java类复制到新module中，去除所有注解。</p>
<h3 id="352-实现">3.5.2、实现</h3>
<pre><code class="language-xml">&lt;!-- 配置目标类的bean --&gt;
&lt;bean id=&quot;calculatorPure&quot; class=&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;/&gt;
    
&lt;!-- 配置切面类的bean --&gt;
&lt;bean id=&quot;logAspect&quot; class=&quot;com.atguigu.aop.aspect.LogAspect&quot;/&gt;
    
&lt;!-- 配置AOP --&gt;
&lt;aop:config&gt;
    
    &lt;!-- 配置切入点表达式 --&gt;
    &lt;aop:pointcut id=&quot;logPointCut&quot; expression=&quot;execution(* *..*.*(..))&quot;/&gt;
    
    &lt;!-- aop:aspect标签：配置切面 --&gt;
    &lt;!-- ref属性：关联切面类的bean --&gt;
    &lt;aop:aspect ref=&quot;logAspect&quot;&gt;
        &lt;!-- aop:before标签：配置前置通知 --&gt;
        &lt;!-- method属性：指定前置通知的方法名 --&gt;
        &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt;
        &lt;aop:before method=&quot;printLogBeforeCore&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;
    
        &lt;!-- aop:after-returning标签：配置返回通知 --&gt;
        &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt;
        &lt;aop:after-returning
                method=&quot;printLogAfterCoreSuccess&quot;
                pointcut-ref=&quot;logPointCut&quot;
                returning=&quot;targetMethodReturnValue&quot;/&gt;
    
        &lt;!-- aop:after-throwing标签：配置异常通知 --&gt;
        &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt;
        &lt;aop:after-throwing
                method=&quot;printLogAfterCoreException&quot;
                pointcut-ref=&quot;logPointCut&quot;
                throwing=&quot;targetMethodException&quot;/&gt;
    
        &lt;!-- aop:after标签：配置后置通知 --&gt;
        &lt;aop:after method=&quot;printLogCoreFinallyEnd&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;
    
        &lt;!-- aop:around标签：配置环绕通知 --&gt;
        &lt;!--&lt;aop:around method=&quot;……&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;--&gt;
    &lt;/aop:aspect&gt;
    
&lt;/aop:config&gt;
</code></pre>
<h3 id="352-测试">3.5.2、测试</h3>
<pre><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(value = {&quot;classpath:spring-context.xml&quot;})
public class AOPTest {
    
    @Autowired
    private Calculator calculator;
    
    @Test
    public void testLogAspect() {
        int add = calculator.add(10, 2);
        System.out.println(&quot;add = &quot; + add);
    }
}
</code></pre>
<h2 id="36-aop-对获取-bean-的影响">3.6、AOP 对获取 bean 的影响</h2>
<h3 id="351-实验">3.5.1、实验</h3>
<h4 id="1情景一">①情景一</h4>
<ul>
<li>声明一个接口</li>
<li>接口有一个实现类</li>
<li>创建一个切面类，对上面接口的实现类应用通知
<ul>
<li>测试：根据接口类型获取bean</li>
<li>测试：根据类获取bean</li>
</ul>
</li>
</ul>
<p>原因分析：</p>
<p>应用了切面后，真正放在IOC容器中的是代理类的对象</p>
<p>目标类并没有被放到IOC容器中，所以<code>根据目标类的类型从IOC容器中是找不到的</code></p>
<figure data-type="image" tabindex="33"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722191357.png" alt="" loading="lazy"></figure>
<p>从内存分析的角度来说，IOC容器中引用的是代理对象，代理对象引用的是目标对象。IOC容器并没有直接引用目标对象，所以根据目标类本身在IOC容器范围内查找不到。</p>
<figure data-type="image" tabindex="34"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722191614.png" alt="" loading="lazy"></figure>
<p>debug查看代理类的类型：</p>
<figure data-type="image" tabindex="35"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722191640.png" alt="" loading="lazy"></figure>
<h4 id="2情景二">②情景二</h4>
<ul>
<li>
<p>声明一个类</p>
</li>
<li>
<p>创建一个切面类，对上面的类应用通知</p>
<ul>
<li>测试：根据类获取 bean，能获取到。（实际上相当于根据父类类型获取子类bean，前提保证只有一个子类）</li>
</ul>
<figure data-type="image" tabindex="36"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722192250.png" alt="" loading="lazy"></figure>
<p>debug查看实际类型：</p>
<figure data-type="image" tabindex="37"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722192327.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h3 id="352-总结">3.5.2、总结</h3>
<h4 id="1对实现了接口的类应用切面">①对实现了接口的类应用切面</h4>
<p><code>应用切面后的代理类</code>放入IOC容器</p>
<figure data-type="image" tabindex="38"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722190152.png" alt="" loading="lazy"></figure>
<h4 id="2对没实现接口的类应用切面">②对没实现接口的类应用切面</h4>
<p><code>CGLIB生成的代理类</code>放入IOC容器</p>
<figure data-type="image" tabindex="39"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722190211.png" alt="" loading="lazy"></figure>
<h1 id="4-声明式事务">4、声明式事务</h1>
<h2 id="41-jdbctemplate">4.1、JdbcTemplate</h2>
<h3 id="411-简介">4.1.1、简介</h3>
<p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p>
<h3 id="412-准备工作">4.1.2、准备工作</h3>
<h4 id="1加入依赖-2">①加入依赖</h4>
<pre><code class="language-xml">&lt;dependencies&gt;

    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Spring 持久化层支持jar包 --&gt;
    &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;
    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Spring 测试相关 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- MySQL驱动 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 数据源 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.0.31&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<h4 id="2创建jdbcproperties">②创建jdbc.properties</h4>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/ssm?characterEncoding=utf8&amp;useUnicode=true
jdbc.username=root
jdbc.password=
</code></pre>
<h4 id="3配置spring的配置文件">③配置Spring的配置文件</h4>
<p>spring-jdbc.xml</p>
<pre><code class="language-xml">&lt;!-- 导入外部属性文件 --&gt;
&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;

&lt;!-- 配置数据源 --&gt;
&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
		&lt;property name=&quot;url&quot; value=&quot;${atguigu.url}&quot;/&gt;
		&lt;property name=&quot;driverClassName&quot; value=&quot;${atguigu.driver}&quot;/&gt;
		&lt;property name=&quot;username&quot; value=&quot;${atguigu.username}&quot;/&gt;
		&lt;property name=&quot;password&quot; value=&quot;${atguigu.password}&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 配置 JdbcTemplate --&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
		&lt;!-- 装配数据源 --&gt;
		&lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="413-测试">4.1.3、测试</h3>
<h4 id="1在测试类装配-jdbctemplate">①在测试类装配 JdbcTemplate</h4>
<pre><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:spring-jdbc.xml&quot;)
public class JDBCTemplateTest {
  
    @Autowired
    private JdbcTemplate jdbcTemplate;
  
}
</code></pre>
<h4 id="2测试增删改功能">②测试增删改功能</h4>
<pre><code class="language-java">@Test
//测试增删改功能
public void testUpdate() {
    String sql = &quot;insert into t_emp values(null,?,?,?)&quot;;
    int result = jdbcTemplate.update(sql, &quot;张三&quot;, 23, &quot;男&quot;);
    System.out.println(result);
}
</code></pre>
<h4 id="3查询一条数据为实体类对象">③查询一条数据为实体类对象</h4>
<pre><code class="language-java">@Test
//查询一条数据为一个实体类对象
public void testSelectEmpById() {
    String sql = &quot;select * from t_emp where id = ?&quot;;
    Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class), 1);
    System.out.println(emp);
}
</code></pre>
<h4 id="4查询多条数据为一个list集合">④查询多条数据为一个list集合</h4>
<pre><code class="language-java">@Test
//查询多条数据为一个list集合
public void testSelectList() {
    String sql = &quot;select * from t_emp&quot;;
    List&lt;Emp&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class));
    list.forEach(emp -&gt; System.out.println(emp));
}
</code></pre>
<h4 id="5查询单行单列的值">⑤查询单行单列的值</h4>
<pre><code class="language-java">@Test
//查询单行单列的值
public void selectCount() {
    String sql = &quot;select count(id) from t_emp&quot;;
    Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
    System.out.println(count);
}
</code></pre>
<h2 id="42-声明式事务概念">4.2、声明式事务概念</h2>
<h3 id="421-编程式事务">4.2.1、编程式事务</h3>
<p>事务功能的相关操作全部通过自己编写代码来实现：</p>
<pre><code class="language-java">Connection conn = ...;
	
try {
	
	// 开启事务：关闭事务的自动提交
	conn.setAutoCommit(false);
	
	// 核心操作
	
	// 提交事务
	conn.commit();
	
}catch(Exception e){
	
	// 回滚事务
	conn.rollBack();
	
}finally{
	
	// 释放数据库连接
	conn.close();
	
}
</code></pre>
<p>编程式的实现方式存在缺陷：</p>
<ul>
<li>细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。</li>
<li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。</li>
</ul>
<h3 id="422-声明式事务">4.2.2、声明式事务</h3>
<p>既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。</p>
<p>封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。</p>
<ul>
<li>好处1：提高开发效率</li>
<li>好处2：消除了冗余的代码</li>
<li>好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化</li>
</ul>
<p>所以，我们可以总结下面两个概念：</p>
<ul>
<li><strong>编程式</strong>：<strong>自己写代码</strong>实现功能</li>
<li><strong>声明式</strong>：通过<strong>配置</strong>让<strong>框架</strong>实现功能</li>
</ul>
<h2 id="43-基于注解的声明式事务">4.3、基于注解的声明式事务</h2>
<h3 id="431-准备工作">4.3.1、准备工作</h3>
<h4 id="1加入依赖-3">①加入依赖</h4>
<pre><code class="language-xml">&lt;dependencies&gt;

    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Spring 持久化层支持jar包 --&gt;
    &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;
    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Spring 测试相关 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- MySQL驱动 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 数据源 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.0.31&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<h4 id="2创建jdbcproperties-2">②创建jdbc.properties</h4>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/ssm?characterEncoding=utf8&amp;useUnicode=true
jdbc.username=root
jdbc.password=
</code></pre>
<h4 id="3配置spring的配置文件-2">③配置Spring的配置文件</h4>
<p>tx-annotation.xml</p>
<pre><code class="language-xml">&lt;!--扫描组件--&gt;
&lt;context:component-scan base-package=&quot;com.atguigu.spring.tx.annotation&quot;&gt;
&lt;/context:component-scan&gt;

&lt;!-- 导入外部属性文件 --&gt;
&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;

&lt;!-- 配置数据源 --&gt;
&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${atguigu.url}&quot;/&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${atguigu.driver}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${atguigu.username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${atguigu.password}&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 配置 JdbcTemplate --&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;!-- 装配数据源 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4创建表">④创建表</h4>
<pre><code class="language-sql">CREATE TABLE `t_book` (
	`book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
	`book_name` varchar(20) DEFAULT NULL COMMENT '图书名称',
	`price` int(11) DEFAULT NULL COMMENT '价格',
	`stock` int(10) unsigned DEFAULT NULL COMMENT '库存（无符号）',
PRIMARY KEY (`book_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,'斗破苍
穹',80,100),(2,'斗罗大陆',50,100);

CREATE TABLE `t_user` (
	`user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
	`username` varchar(20) DEFAULT NULL COMMENT '用户名',
	`balance` int(10) unsigned DEFAULT NULL COMMENT '余额（无符号）',
PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

insert into `t_user`(`user_id`,`username`,`balance`) values (1,'admin',50);
</code></pre>
<h4 id="5创建组件">⑤创建组件</h4>
<p>创建BookController</p>
<pre><code class="language-java">@Controller
public class BookController {
  
    @Autowired
    private BookService bookService;
  
    public void buyBook(Integer bookId, Integer userId) {
        bookService.buyBook(bookId, userId);
    }
  
}
</code></pre>
<p>创建接口BookService</p>
<pre><code class="language-java">public interface BookService {
  
    void buyBook(Integer bookId, Integer userId);
  
}
</code></pre>
<p>创建实现类BookServiceImpl</p>
<pre><code class="language-java">@Service
public class BookServiceImpl implements BookService {
  
    @Autowired
    private BookDao bookDao;
  
    @Override
    public void buyBook(Integer bookId, Integer userId) {
        //查询图书的价格
        Integer price = bookDao.getPriceByBookId(bookId);
        //更新图书的库存
        bookDao.updateStock(bookId);
        //更新用户的余额
        bookDao.updateBalance(userId, price);
    }
  
}
</code></pre>
<p>创建接口BookDao</p>
<pre><code class="language-java">public interface BookDao {

    Integer getPriceByBookId(Integer bookId);
    
    void updateStock(Integer bookId);
    
    void updateBalance(Integer userId, Integer price);
    
}
</code></pre>
<p>创建实现类BookDaoImpl</p>
<pre><code class="language-java">@Repository
public class BookDaoImpl implements BookDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Override
    public Integer getPriceByBookId(Integer bookId) {
        String sql = &quot;select price from t_book where book_id = ?&quot;;
        return jdbcTemplate.queryForObject(sql, Integer.class, bookId);
    }
    @Override
    public void updateStock(Integer bookId) {
        String sql = &quot;update t_book set stock = stock - 1 where book_id = ?&quot;;
        jdbcTemplate.update(sql, bookId);
    }
    @Override
    public void updateBalance(Integer userId, Integer price) {
        String sql = &quot;update t_user set balance = balance - ? where user_id = ? &quot;;
        jdbcTemplate.update(sql, price, userId);
    }
}
</code></pre>
<h3 id="432-测试无事务情况">4.3.2、测试无事务情况</h3>
<h4 id="1创建测试类">①创建测试类</h4>
<pre><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:tx-annotation.xml&quot;)
public class TxByAnnotationTest {
  
    @Autowired
    private BookController bookController;
  
    @Test
    public void testBuyBook() {
        bookController.buyBook(1, 1);
    }
 
}
</code></pre>
<h4 id="2模拟场景">②模拟场景</h4>
<ul>
<li>
<p>用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额</p>
</li>
<li>
<p>假设用户id为1的用户，购买id为1的图书</p>
</li>
<li>
<p>用户余额为50，而图书价格为80</p>
</li>
<li>
<p>购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段</p>
</li>
<li>
<p>此时执行sql语句会抛出SQLException</p>
</li>
</ul>
<h4 id="3观察结果">③观察结果</h4>
<ul>
<li>因为没有添加事务，图书的库存更新了，但是用户的余额没有更新</li>
<li>显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败</li>
</ul>
<h3 id="433-加入事务">4.3.3、加入事务</h3>
<h4 id="1添加事务配置">①添加事务配置</h4>
<p>在Spring的配置文件中添加配置：</p>
<pre><code class="language-xml">&lt;!--创建事务管理器bean--&gt;
&lt;bean id=&quot;transactionManager&quot;
      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!--
 开启事务的注解驱动
 通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务
--&gt;
&lt;!--
 transaction-manager属性的默认值是transactionManager，
 如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性
--&gt;
&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<p>注意：导入的名称空间需要 <strong>tx 结尾</strong>的那个。</p>
<figure data-type="image" tabindex="40"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220723004522.png" alt="" loading="lazy"></figure>
<blockquote>
<p>该配置对应的注解方式为</p>
<p><code>@EnableTransactionManagement //启用事务管理</code></p>
</blockquote>
<h4 id="2添加事务注解">②添加事务注解</h4>
<p>因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理 在BookServiceImpl的buybook()添加注解<code>@Transactional</code></p>
<h4 id="3观察结果-2">③观察结果</h4>
<p>由于使用了Spring的声明式事务，更新库存和更新余额都没有执行</p>
<h3 id="434-transactional注解标识的位置">4.3.4、@Transactional注解标识的位置</h3>
<ul>
<li>@Transactional标识在方法上，则只会影响该方法</li>
<li>@Transactional标识的类上，则会影响类中所有的方法</li>
</ul>
<blockquote>
<h4 id="tip-2">TIP</h4>
<p>Spring 环境下很多场合都有类似设定，一个注解如果标记了类的每一个方法那么通常就可以提取到类级别。</p>
</blockquote>
<h3 id="435-事务属性只读">4.3.5、事务属性：只读</h3>
<h4 id="1介绍-2">①介绍</h4>
<p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这 样数据库就能够针对查询操作来进行优化。</p>
<h4 id="2使用方式">②使用方式</h4>
<pre><code class="language-java">@Transactional(readOnly = true)
public void buyBook(Integer bookId, Integer userId) {
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}
</code></pre>
<h4 id="3注意">③注意</h4>
<ul>
<li>
<p>对增删改操作设置只读属性会抛出下面异常：</p>
</li>
<li>
<p>Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed</p>
</li>
</ul>
<h3 id="436-事务属性超时">4.3.6、事务属性：超时</h3>
<h4 id="1介绍-3">①介绍</h4>
<ul>
<li>
<p>事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间 占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。</p>
</li>
<li>
<p>此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p>
</li>
<li>
<p>概括来说就是一句话：超时就要回滚，释放资源。</p>
</li>
</ul>
<h4 id="2使用方式-2">②使用方式</h4>
<pre><code class="language-java">@Transactional(timeout = 3)
public void buyBook(Integer bookId, Integer userId) {
    try {
        TimeUnit.SECONDS.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
  
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}
</code></pre>
<h4 id="3观察结果-3">③观察结果</h4>
<ul>
<li>执行过程中抛出异常：</li>
<li>org.springframework.transaction.<strong>TransactionTimedOutException</strong>: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2022</li>
</ul>
<h3 id="437-事务属性回滚策略">4.3.7、事务属性：回滚策略</h3>
<h4 id="1介绍-4">①介绍</h4>
<p>声明式事务默认只针对运行时异常回滚，编译时异常不回滚。</p>
<p>可以通过@Transactional中相关属性设置回滚策略</p>
<ul>
<li><code>rollbackFor</code>属性：需要设置一个Class类型的对象</li>
<li><code>rollbackForClassName</code>属性：需要设置一个字符串类型的全类名</li>
<li><code>noRollbackFor</code>属性：需要设置一个Class类型的对象</li>
<li><code>noRollbackFoClassNamer</code>属性：需要设置一个字符串类型的全类名</li>
</ul>
<h4 id="2使用方式-3">②使用方式</h4>
<pre><code class="language-java">@Transactional(noRollbackFor = ArithmeticException.class)
//@Transactional(noRollbackForClassName = &quot;java.lang.ArithmeticException&quot;)
public void buyBook(Integer bookId, Integer userId) {
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
  
    //更新图书的库存
    bookDao.updateStock(bookId);
  
    //更新用户的余额
    bookDao.updateBalance(userId, price);
  
    System.out.println(1 / 0);
}
</code></pre>
<h4 id="3观察结果-4">③观察结果</h4>
<p>虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当出现ArithmeticException不发生回滚，因此购买图书的操作正常执行</p>
<h3 id="438-事务属性事务隔离级别">4.3.8、事务属性：事务隔离级别</h3>
<h4 id="1介绍-5">①介绍</h4>
<p>数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p>
<p>隔离级别一共有四种：</p>
<ul>
<li>
<p>读未提交：READ UNCOMMITTED</p>
<p>允许Transaction01读取Transaction02未提交的修改。</p>
</li>
<li>
<p>读已提交：READ COMMITTED</p>
<p>要求Transaction01只能读取Transaction02已提交的修改。</p>
</li>
<li>
<p>可重复读：REPEATABLE READ</p>
<p>确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。</p>
</li>
<li>
<p>串行化：SERIALIZABLE</p>
<p>确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。</p>
</li>
</ul>
<p>各个隔离级别解决并发问题的能力见下表：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>无</td>
<td>无</td>
<td>有（MySQL无）</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>各种数据库产品对事务隔离级别的支持程度：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>Oracle</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>√(默认)</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>×</td>
<td>√(默认)</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<h4 id="2使用方式-4">②使用方式</h4>
<pre><code class="language-java">@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别
@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交
@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交
@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读
@Transactional(isolation = Isolation.SERIALIZABLE)//串行化
</code></pre>
<h3 id="439-事务属性事务传播行为">4.3.9、事务属性：事务传播行为</h3>
<h4 id="1介绍-6">①介绍</h4>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<h4 id="2测试-2">②测试</h4>
<p>创建接口CheckoutService</p>
<pre><code class="language-java">public interface CheckoutService {

    void checkout(Integer[] bookIds, Integer userId);
    
}
</code></pre>
<p>创建实现类CheckoutServiceImpl</p>
<pre><code class="language-java">@Service
public class CheckoutServiceImpl implements CheckoutService {
  
    @Autowired
    private BookService bookService;
  
    @Override
    @Transactional
    //一次购买多本图书
    public void checkout(Integer[] bookIds, Integer userId) {
        for (Integer bookId : bookIds) {
            bookService.buyBook(bookId, userId);
        }
    }
  
}
</code></pre>
<p>在BookController中添加方法</p>
<pre><code class="language-java">@Autowired
private CheckoutService checkoutService;

public void checkout(Integer[] bookIds, Integer userId) {
    checkoutService.checkout(bookIds, userId);
}
</code></pre>
<p>在数据库中将用户的余额修改为100元</p>
<h4 id="3观察结果-5">③观察结果</h4>
<p>可以通过@Transactional中的<code>propagation属性</code>设置事务传播行为</p>
<p>修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性</p>
<ul>
<li>@Transactional(propagation = Propagation.<code>REQUIRED</code>)，<strong>默认</strong>情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，<strong>即只要有一本书买不了，就都买不了</strong></li>
<li>@Transactional(propagation = Propagation.<code>REQUIRES_NEW</code>)，<code>建议使用</code>。表示不管当前线程上是否有已经开启的事务，都要开启新事务。同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不影响，<strong>即能买几本就买几本</strong></li>
</ul>
<h2 id="44-基于xml的声明式事务">4.4、基于XML的声明式事务</h2>
<h3 id="431-场景模拟">4.3.1、场景模拟</h3>
<p>参考基于注解的声明式事务</p>
<h3 id="432-修改spring配置文件">4.3.2、修改Spring配置文件</h3>
<p>将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置</p>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;!-- 配置事务通知和切入点表达式 --&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot;
                 pointcut=&quot;execution(* com.atguigu.spring.tx.xml.service.impl.*.*(..))&quot;&gt;&lt;/aop:advisor&gt;
&lt;/aop:config&gt;
&lt;!-- tx:advice标签：配置事务通知 --&gt;
&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;
&lt;!-- transaction-manager属性：关联事务管理器 --&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!-- tx:method标签：配置具体的事务方法 --&gt;
        &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt;
        &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
        &lt;!-- read-only属性：设置只读属性 --&gt;
        &lt;!-- rollback-for属性：设置回滚的异常 --&gt;
        &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt;
        &lt;!-- isolation属性：设置事务的隔离级别 --&gt;
        &lt;!-- timeout属性：设置事务的超时属性 --&gt;
        &lt;!-- propagation属性：设置事务的传播行为 --&gt;
        &lt;tx:method name=&quot;save*&quot; read-only=&quot;false&quot; rollbackfor=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
        &lt;tx:method name=&quot;update*&quot; read-only=&quot;false&quot; rollbackfor=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
        &lt;tx:method name=&quot;delete*&quot; read-only=&quot;false&quot; rollbackfor=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<blockquote>
<p>注意：基于xml实现的声明式事务，必须引入aspectJ的依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
    &lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</blockquote>
<h1 id="5-spring5-新特性">5、Spring5 新特性</h1>
<h2 id="51-jsr305标准相关注解">5.1、JSR305标准相关注解</h2>
<h2 id="52-整合junit5">5.2、整合junit5</h2>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      况杨
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://kuangyang828.github.io/spring-bi-ji/" title="Spring笔记">https://kuangyang828.github.io/spring-bi-ji/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://kuangyang828.github.io/tag/7J3okythe/"># Spring</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Mac设置JAVA_HOME环境变量" href="https://kuangyang828.github.io/mac-she-zhi-java_home-huan-jing-bian-liang/">Mac设置JAVA_HOME环境变量</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Mac设置JAVA_HOME环境变量" href="https://kuangyang828.github.io/mac-she-zhi-java_home-huan-jing-bian-liang/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="SpringMVC笔记" href="https://kuangyang828.github.io/springmvc-bi-ji/">SpringMVC笔记</a>
        <a class="nav-mobile-next" title="SpringMVC笔记" href="https://kuangyang828.github.io/springmvc-bi-ji/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "true";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
            <img id="zfb" class="reward-img" src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220723142251.png" alt="赞赏码">
          
          
            <img id="wx" class="reward-img" src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220723142302.png" alt="赞赏码">
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      <div id="zfbBtn" class="pay-text">
        支付宝
      </div>
      
      
      <div id="wxBtn" class="pay-text">
        微信支付
      </div>
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/dubbo-bi-ji/"" data-c="
          &lt;p&gt;https://www.bilibili.com/video/BV1ns411c7jV&lt;/p&gt;
">Dubbo 笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/zookeeper-bi-ji/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1to4y1C7gw&#34;&gt;视频地址 🔗bilibili&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220914153034.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;zookeeper-入门&#34;&gt;Zookeeper 入门&lt;/h1&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。&lt;br&gt;
（Zookeeper 是一个为其他分布式框架提供服务的分布式框架）&lt;/p&gt;
&lt;h2 id=&#34;工作机制&#34;&gt;工作机制&lt;/h2&gt;
&lt;p&gt;Zookeeper从设计模式角度来理解：是一个基于&lt;code&gt;观察者模式&lt;/code&gt;设计的分布式服务管理框架，它&lt;code&gt;负责存储和管理大家都关心的数据&lt;/code&gt;，然后&lt;code&gt;接受观察者的注册&lt;/code&gt;，&lt;code&gt;一旦&lt;/code&gt;这些&lt;code&gt;数据&lt;/code&gt;的状态发生&lt;code&gt;变化&lt;/code&gt;，Zookeeper就将&lt;code&gt;负责通知已经在Zookeeper上注册的那些观察者&lt;/code&gt;做出相应的反应。&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;code&gt;Zookeeper=文件系统+通知机制&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220914155529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1）	Zookeeper：一个领导者（Leader），多个跟随者（Follower）组成的集群。&lt;br&gt;
2）	集群中只要有&lt;code&gt;半数&lt;/code&gt;以上节点存活，Zookeeper集群就能正常服务。所以 Zookeeper 适合安装&lt;code&gt;奇数&lt;/code&gt;台服务器。&lt;br&gt;
3）	全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。&lt;br&gt;
4）	更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。&lt;br&gt;
5）	数据更新原子性，一次数据更新要么成功，要么失败。&lt;/p&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;ZooKeeper 数据模型的结构与 &lt;code&gt;Unix 文件系统很类似&lt;/code&gt;，&lt;code&gt;整体&lt;/code&gt;上可以看作是一棵&lt;code&gt;树&lt;/code&gt;，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 &lt;code&gt;1MB&lt;/code&gt; 的数据，每个 ZNode 都可以&lt;code&gt;通过其路径唯一标识&lt;/code&gt;。&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220914160014.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;p&gt;提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。&lt;/p&gt;
&lt;h1 id=&#34;面试重点&#34;&gt;面试重点&lt;/h1&gt;
&lt;h2 id=&#34;选举机制&#34;&gt;选举机制&lt;/h2&gt;
&lt;p&gt;半数机制，超过半数的投票通过，即通过。&lt;br&gt;
（1）第一次启动选举规则：&lt;br&gt;
投票过半数时，服务器 id 大的胜出。&lt;br&gt;
即每台机器会先投给自己，不行再投给 id 大的，依此类推，直到某台机器获得超过半数的票，它就成为Leader。所以一般是排在中间服务器当 Leader。&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220914161440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;（2）第二次启动选举规则：&lt;br&gt;
①	EPOCH 大的直接胜出&lt;br&gt;
②	EPOCH 相同，事务 id 大的胜出&lt;br&gt;
③	事务 id 相同，服务器 id 大的胜出&lt;/p&gt;
&lt;h2 id=&#34;监听器客户端原理&#34;&gt;监听器（客户端）原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220914162750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;生产集群安装多少zk合适&#34;&gt;生产集群安装多少zk合适？&lt;/h2&gt;
&lt;p&gt;安装奇数台。&lt;br&gt;
&lt;code&gt;生产经验：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10 台服务器：3 台 zk；&lt;/li&gt;
&lt;li&gt;20 台服务器：5 台 zk；&lt;/li&gt;
&lt;li&gt;100 台服务器：11 台 zk；&lt;/li&gt;
&lt;li&gt;200 台服务器：11 台 zk&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;服务器台数多：好处，提高可靠性；坏处：提高通信延时&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;p&gt;ls、get、create、delete&lt;/p&gt;
&lt;h1 id=&#34;随堂笔记&#34;&gt;随堂笔记&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kuangyang828/share_doc/blob/master/Zookeeper%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0.pdf&#34;&gt;https://github.com/kuangyang828/share_doc/blob/master/Zookeeper随堂笔记.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;课件&#34;&gt;课件&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kuangyang828/share_doc/blob/master/08_%E5%B0%9A%E7%A1%85%E8%B0%B7%E6%8A%80%E6%9C%AF%E4%B9%8BZookeeperV3.3.pdf&#34;&gt;https://github.com/kuangyang828/share_doc/blob/master/08_尚硅谷技术之ZookeeperV3.3.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;源码分析&#34;&gt;源码分析&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kuangyang828/share_doc/blob/master/08_%E5%B0%9A%E7%A1%85%E8%B0%B7%E6%8A%80%E6%9C%AF%E4%B9%8BZookeeper%EF%BC%88%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%89V3.3.pdf&#34;&gt;https://github.com/kuangyang828/share_doc/blob/master/08_尚硅谷技术之Zookeeper（源码解析）V3.3.pdf&lt;/a&gt;&lt;/p&gt;
">Zookeeper 笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/redis-6-bi-ji/"" data-c="
          &lt;p&gt;1&lt;/p&gt;
">Redis 6 笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/maven-bi-ji/"" data-c="
          &lt;p&gt;1&lt;/p&gt;
">Maven 笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/flutter-bi-ji/"" data-c="
          &lt;h1 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h1&gt;
&lt;h2 id=&#34;安装-flutter-sdk&#34;&gt;安装 Flutter SDK&lt;/h2&gt;
&lt;h2 id=&#34;运行-flutter-doctor-命令&#34;&gt;运行 flutter doctor 命令&lt;/h2&gt;
&lt;p&gt;https://flutter.cn/docs/get-started/install/macos#update-your-path&lt;/p&gt;
&lt;h3 id=&#34;配置环境变量&#34;&gt;配置环境变量&lt;/h3&gt;
&lt;p&gt;https://flutter.cn/docs/get-started/install/macos#update-your-path&lt;/p&gt;
&lt;h2 id=&#34;配置-ios-环境&#34;&gt;配置 iOS 环境&lt;/h2&gt;
&lt;h2 id=&#34;配置-android-环境&#34;&gt;配置 Android 环境&lt;/h2&gt;
">Flutter 笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/springboot-ying-yong-pian-bi-ji/"" data-c="
          &lt;p&gt;https://youtube.com/playlist?list=PLD3Xyx6ef38xcNhCaCV_fUqB9vjTDA7hX&lt;/p&gt;
&lt;h1 id=&#34;文件上传与下载&#34;&gt;文件上传与下载&lt;/h1&gt;
&lt;h2 id=&#34;文件上传&#34;&gt;文件上传&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Spring Boot 实现文件上传与下载功能本质还是依靠 Spring MVC&lt;/li&gt;
&lt;li&gt;需要注意的是，获取存放上传与下载文件的目录的方式不同&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/uploadDocument&amp;quot;)
public Result uploadDocument(MultipartFile uploadFile) throws IOException {
    // 获取上传的文件的文件名
    String fileName = uploadFile.getOriginalFilename();
    // 处理文件重名问题
    String suffixName = fileName.substring(fileName.lastIndexOf(&amp;quot;.&amp;quot;));
    String prefixName = fileName.substring(0, fileName.lastIndexOf(&amp;quot;.&amp;quot;));
    fileName = prefixName + &amp;quot;-&amp;quot; + UUID.randomUUID() + suffixName;
    // 获取服务器中 Document 目录的路径
    File documentPath = new File(ResourceUtils.getURL(&amp;quot;classpath:static/uploadPath/document&amp;quot;).getPath());
    if (!documentPath.exists()) {
        documentPath.mkdir();
    }
    String finalPath = documentPath + File.separator + fileName;
    // 实现上传功能
    uploadFile.transferTo(new File(finalPath));
    return Result.OK(&amp;quot;/uploadPath/document/&amp;quot; + fileName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文件下载&#34;&gt;文件下载&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GetMapping(&amp;quot;/downloadDocument/{fileName}&amp;quot;)
public ResponseEntity&amp;lt;byte[]&amp;gt; downloadDocument(@PathVariable(&amp;quot;fileName&amp;quot;) String fileName) throws IOException {
    // 获取服务器中文件的真实路径
    String realPath = ResourceUtils.getURL(&amp;quot;classpath:static/uploadPath/document/&amp;quot;).getPath() + fileName;
    // 创建输入流
    //InputStream is = new FileInputStream(realPath);
    InputStream is = Files.newInputStream(Paths.get(realPath));
    // 创建字节数组
    byte[] bytes = new byte[is.available()];
    // 将流读到字节数组中
    is.read(bytes);
    // 创建HttpHeaders对象设置响应头信息
    MultiValueMap&amp;lt;String, String&amp;gt; headers = new HttpHeaders();
    // 对文件名重新编码，防止中文乱码
    fileName = new String(fileName.getBytes(StandardCharsets.UTF_8), StandardCharsets.ISO_8859_1);
    // 设置要下载方式以及下载文件的名字
    headers.add(&amp;quot;Content-Disposition&amp;quot;, &amp;quot;attachment;filename=&amp;quot; + fileName);
    // 设置响应状态码
    HttpStatus statusCode = HttpStatus.OK;
    // 创建ResponseEntity对象
    ResponseEntity&amp;lt;byte[]&amp;gt; responseEntity = new ResponseEntity&amp;lt;&amp;gt;(bytes, headers, statusCode);
    // 关闭输入流
    is.close();
    return responseEntity;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-整合第三方技术&#34;&gt;5-整合第三方技术&lt;/h1&gt;
&lt;h2 id=&#34;5-2-定时任务&#34;&gt;5-2 定时任务&lt;/h2&gt;
&lt;p&gt;定时任务是企业级开发中必不可少的组成部分，诸如长周期业务数据的计算，例如年度报表，诸如系统脏数据的处理，再比如系统性能监控报告，还有抢购类活动的商品上架，这些都离不开定时任务。本节将介绍两种不同的定时任务技术。&lt;/p&gt;
&lt;h3 id=&#34;quartz&#34;&gt;Quartz&lt;/h3&gt;
&lt;p&gt;Quartz技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂。springboot对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。在&lt;/p&gt;
&lt;p&gt;学习springboot整合Quartz前先普及几个Quartz的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作（Job）：用于定义具体执行的工作&lt;/li&gt;
&lt;li&gt;工作明细（JobDetail）：用于描述定时工作相关的信息&lt;/li&gt;
&lt;li&gt;触发器（Trigger）：描述了工作明细与调度器的对应关系&lt;/li&gt;
&lt;li&gt;调度器（Scheduler）：用于描述触发工作的执行规则，通常使用cron表达式定义规则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;步骤①&lt;/strong&gt;：导入springboot整合Quartz的starte&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-quartz&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;步骤②&lt;/strong&gt;：定义任务Bean，按照Quartz的开发规范制作，需要继承QuartzJobBean&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意，任务Bean&lt;mark&gt;不需要&lt;/mark&gt;标注为组件交给Spring容器管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyQuartz extends QuartzJobBean {
    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        System.out.println(&amp;quot;quartz task run...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;步骤③&lt;/strong&gt;：创建Quartz配置类，定义工作明细（JobDetail）与触发器的（Trigger）bean&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class QuartzConfig {
  
  	/**
     * 工作明细
     * @return
     */
    @Bean
    public JobDetail printJobDetail(){
        //绑定具体的工作
        return JobBuilder.newJob(MyQuartz.class).storeDurably().build();
    }
  
  	/**
     * 触发器
     * @return
     */
    @Bean
    public Trigger printJobTrigger(){
        ScheduleBuilder schedBuilder = CronScheduleBuilder.cronSchedule(&amp;quot;0/5 * * * * ?&amp;quot;);
        //绑定对应的工作明细与执行时间（调度器）
        return  TriggerBuilder.newTrigger().forJob(printJobDetail()).withSchedule(schedBuilder).build();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark&gt;工作明细&lt;/mark&gt;中要设置对应的具体&lt;mark&gt;工作&lt;/mark&gt;，&lt;/li&gt;
&lt;li&gt;使用newJob()操作传入对应的工作任务类型即可。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;触发器&lt;/mark&gt;需要绑定&lt;mark&gt;任务&lt;/mark&gt;，使用forJob()操作传入绑定的工作明细对象，&lt;/li&gt;
&lt;li&gt;此处可以为工作明细设置名称，然后使用名称绑定，&lt;/li&gt;
&lt;li&gt;也可以直接调用对应方法绑定；&lt;/li&gt;
&lt;li&gt;触发器中最核心的规则是&lt;mark&gt;执行时间&lt;/mark&gt;，此处使用调度器定义执行时间，&lt;/li&gt;
&lt;li&gt;执行时间描述方式使用的是cron表达式。有关cron表达式的规则，各位小伙伴可以去参看相关课程学习，略微复杂，而且格式不能乱设置，不是写个格式就能用的，写不好就会出现冲突问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;springboot整合Quartz就是将Quartz对应的两个核心对象交给spring容器管理，包含两个对象，JobDetail和Trigger对象&lt;/li&gt;
&lt;li&gt;JobDetail对象描述的是工作的执行信息，需要绑定一个QuartzJobBean类型的对象&lt;/li&gt;
&lt;li&gt;Trigger对象定义了一个触发器，需要为其指定绑定的JobDetail是哪个，同时要设置执行周期调度器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;spring-task&#34;&gt;Spring Task&lt;/h3&gt;
&lt;p&gt;上面的操作看上去不多，但是Quartz将其中的对象划分粒度过细，导致开发的时候有点繁琐，Spring针对上述规则进行了简化，开发了自己的任务管理组件——Task，&lt;/p&gt;
&lt;p&gt;Spring根据定时任务的特征，将定时任务的开发简化到了极致。怎么说呢？要做定时任务总要告诉容器有这功能吧，然后定时执行什么任务直接告诉对应的bean什么时间执行就行了，就这么简单，一起来看怎么做&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤①&lt;/strong&gt;：开启定时任务功能，使用注解 @EnableScheduling&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
//开启定时任务功能
@EnableScheduling
public class Springboot22TaskApplication {
    public static void main(String[] args) {
        SpringApplication.run(Springboot22TaskApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;步骤②&lt;/strong&gt;：定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class MyTask {
    @Scheduled(cron = &amp;quot;0/1 * * * * ?&amp;quot;)
    public void print(){
        System.out.println(Thread.currentThread().getName()+&amp;quot; :spring task run...&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完事，这就完成了定时任务的配置。总体感觉其实什么东西都没少，只不过没有将所有的信息都抽取成bean，而是直接使用注解绑定定时执行任务的事情而已。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果想对定时任务进行相关配置，可以通过配置文件进行&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  task:
   	scheduling:
      pool:
       	size: 1							# 任务调度线程池大小 默认 1
      thread-name-prefix: spring_task_      	# 调度线程名称前缀 默认 scheduling-      
        shutdown:
          await-termination: false		# 线程池关闭时等待所有任务完成
          await-termination-period: 10s	# 调度线程关闭前最大等待时间，确保最后一定关闭
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Spring Task需要使用注解 @EnableScheduling 开启定时任务功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为定时执行的的任务设置执行周期，描述方式cron表达式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">SpringBoot 应用篇笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/chang-yong-wen-jian-he-dai-ma-mo-ban/"" data-c="
          &lt;h1 id=&#34;java&#34;&gt;Java&lt;/h1&gt;
&lt;h2 id=&#34;java-2&#34;&gt;Java&lt;/h2&gt;
&lt;h3 id=&#34;result&#34;&gt;Result&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Result.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class Result&amp;lt;T&amp;gt; implements Serializable {
    
    public Result() {
    }

    public Result(boolean success, String message, Integer code, T result, long timestamp) {
        this.success = success;
        this.message = message;
        this.code = code;
        this.result = result;
        this.timestamp = timestamp;
    }

    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public T getResult() {
        return result;
    }

    public void setResult(T result) {
        this.result = result;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }

    private static final long serialVersionUID = 1L;

    /**
     * 成功标志
     */
    private boolean success = true;

    /**
     * 返回处理消息
     */
    private String message = &amp;quot;操作成功！&amp;quot;;

    /**
     * 返回状态码
     */
    private Integer code = 0;

    /**
     * 返回数据对象
     */
    private T result;

    /**
     * 时间戳
     */
    private long timestamp = System.currentTimeMillis();

    public static &amp;lt;T&amp;gt; Result&amp;lt;T&amp;gt; OK() {
        Result&amp;lt;T&amp;gt; rs = new Result&amp;lt;T&amp;gt;();
        rs.setSuccess(true);
        rs.setCode(200);
        rs.setMessage(&amp;quot;操作成功！&amp;quot;);
        return rs;
    }

    public static &amp;lt;T&amp;gt; Result&amp;lt;T&amp;gt; OK(T data) {
        Result&amp;lt;T&amp;gt; rs = new Result&amp;lt;T&amp;gt;();
        rs.setSuccess(true);
        rs.setCode(200);
        rs.setResult(data);
        return rs;
    }

    public static &amp;lt;T&amp;gt; Result&amp;lt;T&amp;gt; OK(String msg) {
        Result&amp;lt;T&amp;gt; rs = new Result&amp;lt;T&amp;gt;();
        rs.setSuccess(true);
        rs.setCode(200);
        rs.setMessage(msg);
        return rs;
    }

    public static &amp;lt;T&amp;gt; Result&amp;lt;T&amp;gt; OK(String msg, T data) {
        Result&amp;lt;T&amp;gt; rs = new Result&amp;lt;T&amp;gt;();
        rs.setSuccess(true);
        rs.setCode(200);
        rs.setMessage(msg);
        rs.setResult(data);
        return rs;
    }

    public static Result&amp;lt;Object&amp;gt; error(String msg) {
        return error(500, msg);
    }

    public static Result&amp;lt;Object&amp;gt; error(int code, String msg) {
        Result&amp;lt;Object&amp;gt; rs = new Result&amp;lt;Object&amp;gt;();
        rs.setCode(code);
        rs.setMessage(msg);
        rs.setSuccess(false);
        return rs;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;stringutils&#34;&gt;StringUtils&lt;/h3&gt;
&lt;p&gt;StringUtils.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 字符串工具类
 */
public class StringUtils {
    /**
     * 空字符串
     */
    private static final String NULLSTR = &amp;quot;&amp;quot;;

    /**
     * 下划线
     */
    private static final char SEPARATOR = &#39;_&#39;;

    /**
     * 确保获取的参数不为空值
     *
     * @param value defaultValue 要判断的value
     * @return value 返回值
     */
    public static &amp;lt;T&amp;gt; T nvl(T value, T defaultValue) {
        return value != null ? value : defaultValue;
    }

    /**
     * 判断一个字符串是否为空串
     *
     * @param str String
     * @return true：为空 false：非空
     */
    public static boolean isEmpty(String str) {
        return null == str || NULLSTR.equals(str.trim());
    }

    /**
     * 判断一个字符串是否为非空串
     *
     * @param str String
     * @return true：非空串 false：空串
     */
    public static boolean isNotEmpty(String str) {
        return !isEmpty(str);
    }


    /**
     * 去空格
     */
    public static String trim(String str) {
        return (str == null ? &amp;quot;&amp;quot; : str.trim());
    }

    /**
     * 是否为http(s)://开头
     *
     * @param link 链接
     * @return 结果
     */
    public static boolean ishttp(String link) {
        return link.equalsIgnoreCase(&amp;quot;http&amp;quot;) || link.equalsIgnoreCase(&amp;quot;https&amp;quot;);
    }

    /**
     * 驼峰转下划线命名方式。
     * 不区分大驼峰或小驼峰
     * 例如：
     * ① HelloWorld -&amp;gt; hello_world
     * ② helloWorld -&amp;gt; hello_world
     *
     * @param str 转换前的驼峰方式命名的字符串
     * @return 转换后的下划线命名的字符串
     */
    public static String toUnderScoreCase(String str) {
        if (str == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        // 前置字符是否大写
        boolean preCharIsUpperCase = true;
        // 当前字符是否大写
        boolean curreCharIsUpperCase = true;
        // 下一字符是否大写
        boolean nexteCharIsUpperCase = true;
        for (int i = 0; i &amp;lt; str.length(); i++) {
            char c = str.charAt(i);
            if (i &amp;gt; 0) {
                preCharIsUpperCase = Character.isUpperCase(str.charAt(i - 1));
            } else {
                preCharIsUpperCase = false;
            }

            curreCharIsUpperCase = Character.isUpperCase(c);

            if (i &amp;lt; (str.length() - 1)) {
                nexteCharIsUpperCase = Character.isUpperCase(str.charAt(i + 1));
            }

            if (preCharIsUpperCase &amp;amp;&amp;amp; curreCharIsUpperCase &amp;amp;&amp;amp; !nexteCharIsUpperCase) {
                sb.append(SEPARATOR);
            } else if ((i != 0 &amp;amp;&amp;amp; !preCharIsUpperCase) &amp;amp;&amp;amp; curreCharIsUpperCase) {
                sb.append(SEPARATOR);
            }
            sb.append(Character.toLowerCase(c));
        }

        return sb.toString();
    }

    /**
     * 是否包含字符串
     *
     * @param str  验证字符串
     * @param strs 字符串组
     * @return 包含返回true
     */
    public static boolean inStringIgnoreCase(String str, String... strs) {
        if (str != null &amp;amp;&amp;amp; strs != null) {
            for (String s : strs) {
                if (str.equalsIgnoreCase(trim(s))) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 下划线方式命名的字符串或小驼峰，转换为大驼峰式。
     * 如果转换前的下划线大写方式命名的字符串为空，则返回空字符串。
     * 例如：
     * ① HELLO_WORLD -&amp;gt; HelloWorld
     * ② hello_world -&amp;gt; HelloWorld
     * ③ helloWorld -&amp;gt; HelloWorld
     *
     * @param name 转换前的下划线大写方式命名的字符串
     * @return 转换后的驼峰式命名的字符串
     */
    public static String toBigCamelCase(String name) {
        StringBuilder result = new StringBuilder();
        // 快速检查
        if (name == null || name.isEmpty()) {
            // 没必要转换
            return &amp;quot;&amp;quot;;
        } else if (!name.contains(&amp;quot;_&amp;quot;)) {
            // 不含下划线，仅将首字母大写
            return name.substring(0, 1).toUpperCase() + name.substring(1);
        }
        // 用下划线将原始字符串分割
        String[] camels = name.split(&amp;quot;_&amp;quot;);
        for (String camel : camels) {
            // 跳过原始字符串中开头、结尾的下换线或双重下划线
            if (camel.isEmpty()) {
                continue;
            }
            // 首字母大写
            result.append(camel.substring(0, 1).toUpperCase());
            result.append(camel.substring(1).toLowerCase());
        }
        return result.toString();
    }

    /**
     * 下划线方式命名的字符串转小驼峰式。
     * 例如：
     * ① USER_NAME-&amp;gt;userName
     * ② user_name-&amp;gt;userName
     *
     * @param s 转换前的下划线小写方式命名的字符串
     * @return 转换后的驼峰式命名的字符串
     */
    public static String toSmallCamelCase(String s) {
        if (s == null) {
            return null;
        }
        s = s.toLowerCase();
        StringBuilder sb = new StringBuilder(s.length());
        boolean upperCase = false;
        for (int i = 0; i &amp;lt; s.length(); i++) {
            char c = s.charAt(i);
            if (c == SEPARATOR) {
                upperCase = true;
            } else if (upperCase) {
                sb.append(Character.toUpperCase(c));
                upperCase = false;
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;uuid&#34;&gt;UUID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UUID.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 提供通用唯一识别码（universally unique identifier）（UUID）实现
 */
public final class UUID implements java.io.Serializable, Comparable&amp;lt;UUID&amp;gt;
{
    private static final long serialVersionUID = -1185015143654744140L;

    /**
     * SecureRandom 的单例
     *
     */
    private static class Holder
    {
        static final SecureRandom numberGenerator = getSecureRandom();
    }

    /** 此UUID的最高64有效位 */
    private final long mostSigBits;

    /** 此UUID的最低64有效位 */
    private final long leastSigBits;

    /**
     * 私有构造
     * 
     * @param data 数据
     */
    private UUID(byte[] data)
    {
        long msb = 0;
        long lsb = 0;
        assert data.length == 16 : &amp;quot;data must be 16 bytes in length&amp;quot;;
        for (int i = 0; i &amp;lt; 8; i++)
        {
            msb = (msb &amp;lt;&amp;lt; 8) | (data[i] &amp;amp; 0xff);
        }
        for (int i = 8; i &amp;lt; 16; i++)
        {
            lsb = (lsb &amp;lt;&amp;lt; 8) | (data[i] &amp;amp; 0xff);
        }
        this.mostSigBits = msb;
        this.leastSigBits = lsb;
    }

    /**
     * 使用指定的数据构造新的 UUID。
     *
     * @param mostSigBits 用于 {@code UUID} 的最高有效 64 位
     * @param leastSigBits 用于 {@code UUID} 的最低有效 64 位
     */
    public UUID(long mostSigBits, long leastSigBits)
    {
        this.mostSigBits = mostSigBits;
        this.leastSigBits = leastSigBits;
    }

    /**
     * 获取类型 4（伪随机生成的）UUID 的静态工厂。 使用加密的本地线程伪随机数生成器生成该 UUID。
     * 
     * @return 随机生成的 {@code UUID}
     */
    public static UUID fastUUID()
    {
        return randomUUID(false);
    }

    /**
     * 获取类型 4（伪随机生成的）UUID 的静态工厂。 使用加密的强伪随机数生成器生成该 UUID。
     * 
     * @return 随机生成的 {@code UUID}
     */
    public static UUID randomUUID()
    {
        return randomUUID(true);
    }

    /**
     * 获取类型 4（伪随机生成的）UUID 的静态工厂。 使用加密的强伪随机数生成器生成该 UUID。
     * 
     * @param isSecure 是否使用{@link SecureRandom}如果是可以获得更安全的随机码，否则可以得到更好的性能
     * @return 随机生成的 {@code UUID}
     */
    public static UUID randomUUID(boolean isSecure)
    {
        final Random ng = isSecure ? Holder.numberGenerator : getRandom();

        byte[] randomBytes = new byte[16];
        ng.nextBytes(randomBytes);
        randomBytes[6] &amp;amp;= 0x0f; /* clear version */
        randomBytes[6] |= 0x40; /* set to version 4 */
        randomBytes[8] &amp;amp;= 0x3f; /* clear variant */
        randomBytes[8] |= 0x80; /* set to IETF variant */
        return new UUID(randomBytes);
    }

    /**
     * 根据指定的字节数组获取类型 3（基于名称的）UUID 的静态工厂。
     *
     * @param name 用于构造 UUID 的字节数组。
     *
     * @return 根据指定数组生成的 {@code UUID}
     */
    public static UUID nameUUIDFromBytes(byte[] name)
    {
        MessageDigest md;
        try
        {
            md = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;);
        }
        catch (NoSuchAlgorithmException nsae)
        {
            throw new InternalError(&amp;quot;MD5 not supported&amp;quot;);
        }
        byte[] md5Bytes = md.digest(name);
        md5Bytes[6] &amp;amp;= 0x0f; /* clear version */
        md5Bytes[6] |= 0x30; /* set to version 3 */
        md5Bytes[8] &amp;amp;= 0x3f; /* clear variant */
        md5Bytes[8] |= 0x80; /* set to IETF variant */
        return new UUID(md5Bytes);
    }

    /**
     * 根据 {@link #toString()} 方法中描述的字符串标准表示形式创建{@code UUID}。
     *
     * @param name 指定 {@code UUID} 字符串
     * @return 具有指定值的 {@code UUID}
     * @throws IllegalArgumentException 如果 name 与 {@link #toString} 中描述的字符串表示形式不符抛出此异常
     *
     */
    public static UUID fromString(String name)
    {
        String[] components = name.split(&amp;quot;-&amp;quot;);
        if (components.length != 5)
        {
            throw new IllegalArgumentException(&amp;quot;Invalid UUID string: &amp;quot; + name);
        }
        for (int i = 0; i &amp;lt; 5; i++)
        {
            components[i] = &amp;quot;0x&amp;quot; + components[i];
        }

        long mostSigBits = Long.decode(components[0]).longValue();
        mostSigBits &amp;lt;&amp;lt;= 16;
        mostSigBits |= Long.decode(components[1]).longValue();
        mostSigBits &amp;lt;&amp;lt;= 16;
        mostSigBits |= Long.decode(components[2]).longValue();

        long leastSigBits = Long.decode(components[3]).longValue();
        leastSigBits &amp;lt;&amp;lt;= 48;
        leastSigBits |= Long.decode(components[4]).longValue();

        return new UUID(mostSigBits, leastSigBits);
    }

    /**
     * 返回此 UUID 的 128 位值中的最低有效 64 位。
     *
     * @return 此 UUID 的 128 位值中的最低有效 64 位。
     */
    public long getLeastSignificantBits()
    {
        return leastSigBits;
    }

    /**
     * 返回此 UUID 的 128 位值中的最高有效 64 位。
     *
     * @return 此 UUID 的 128 位值中最高有效 64 位。
     */
    public long getMostSignificantBits()
    {
        return mostSigBits;
    }

    /**
     * 与此 {@code UUID} 相关联的版本号. 版本号描述此 {@code UUID} 是如何生成的。
     * &amp;lt;p&amp;gt;
     * 版本号具有以下含意:
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;1 基于时间的 UUID
     * &amp;lt;li&amp;gt;2 DCE 安全 UUID
     * &amp;lt;li&amp;gt;3 基于名称的 UUID
     * &amp;lt;li&amp;gt;4 随机生成的 UUID
     * &amp;lt;/ul&amp;gt;
     *
     * @return 此 {@code UUID} 的版本号
     */
    public int version()
    {
        // Version is bits masked by 0x000000000000F000 in MS long
        return (int) ((mostSigBits &amp;gt;&amp;gt; 12) &amp;amp; 0x0f);
    }

    /**
     * 与此 {@code UUID} 相关联的变体号。变体号描述 {@code UUID} 的布局。
     * &amp;lt;p&amp;gt;
     * 变体号具有以下含意：
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;0 为 NCS 向后兼容保留
     * &amp;lt;li&amp;gt;2 &amp;lt;a href=&amp;quot;http://www.ietf.org/rfc/rfc4122.txt&amp;quot;&amp;gt;IETF&amp;amp;nbsp;RFC&amp;amp;nbsp;4122&amp;lt;/a&amp;gt;(Leach-Salz), 用于此类
     * &amp;lt;li&amp;gt;6 保留，微软向后兼容
     * &amp;lt;li&amp;gt;7 保留供以后定义使用
     * &amp;lt;/ul&amp;gt;
     *
     * @return 此 {@code UUID} 相关联的变体号
     */
    public int variant()
    {
        // This field is composed of a varying number of bits.
        // 0 - - Reserved for NCS backward compatibility
        // 1 0 - The IETF aka Leach-Salz variant (used by this class)
        // 1 1 0 Reserved, Microsoft backward compatibility
        // 1 1 1 Reserved for future definition.
        return (int) ((leastSigBits &amp;gt;&amp;gt;&amp;gt; (64 - (leastSigBits &amp;gt;&amp;gt;&amp;gt; 62))) &amp;amp; (leastSigBits &amp;gt;&amp;gt; 63));
    }

    /**
     * 与此 UUID 相关联的时间戳值。
     *
     * &amp;lt;p&amp;gt;
     * 60 位的时间戳值根据此 {@code UUID} 的 time_low、time_mid 和 time_hi 字段构造。&amp;lt;br&amp;gt;
     * 所得到的时间戳以 100 毫微秒为单位，从 UTC（通用协调时间） 1582 年 10 月 15 日零时开始。
     *
     * &amp;lt;p&amp;gt;
     * 时间戳值仅在在基于时间的 UUID（其 version 类型为 1）中才有意义。&amp;lt;br&amp;gt;
     * 如果此 {@code UUID} 不是基于时间的 UUID，则此方法抛出 UnsupportedOperationException。
     *
     * @throws UnsupportedOperationException 如果此 {@code UUID} 不是 version 为 1 的 UUID。
     */
    public long timestamp() throws UnsupportedOperationException
    {
        checkTimeBase();
        return (mostSigBits &amp;amp; 0x0FFFL) &amp;lt;&amp;lt; 48//
                | ((mostSigBits &amp;gt;&amp;gt; 16) &amp;amp; 0x0FFFFL) &amp;lt;&amp;lt; 32//
                | mostSigBits &amp;gt;&amp;gt;&amp;gt; 32;
    }

    /**
     * 与此 UUID 相关联的时钟序列值。
     *
     * &amp;lt;p&amp;gt;
     * 14 位的时钟序列值根据此 UUID 的 clock_seq 字段构造。clock_seq 字段用于保证在基于时间的 UUID 中的时间唯一性。
     * &amp;lt;p&amp;gt;
     * {@code clockSequence} 值仅在基于时间的 UUID（其 version 类型为 1）中才有意义。 如果此 UUID 不是基于时间的 UUID，则此方法抛出
     * UnsupportedOperationException。
     *
     * @return 此 {@code UUID} 的时钟序列
     *
     * @throws UnsupportedOperationException 如果此 UUID 的 version 不为 1
     */
    public int clockSequence() throws UnsupportedOperationException
    {
        checkTimeBase();
        return (int) ((leastSigBits &amp;amp; 0x3FFF000000000000L) &amp;gt;&amp;gt;&amp;gt; 48);
    }

    /**
     * 与此 UUID 相关的节点值。
     *
     * &amp;lt;p&amp;gt;
     * 48 位的节点值根据此 UUID 的 node 字段构造。此字段旨在用于保存机器的 IEEE 802 地址，该地址用于生成此 UUID 以保证空间唯一性。
     * &amp;lt;p&amp;gt;
     * 节点值仅在基于时间的 UUID（其 version 类型为 1）中才有意义。&amp;lt;br&amp;gt;
     * 如果此 UUID 不是基于时间的 UUID，则此方法抛出 UnsupportedOperationException。
     *
     * @return 此 {@code UUID} 的节点值
     *
     * @throws UnsupportedOperationException 如果此 UUID 的 version 不为 1
     */
    public long node() throws UnsupportedOperationException
    {
        checkTimeBase();
        return leastSigBits &amp;amp; 0x0000FFFFFFFFFFFFL;
    }

    /**
     * 返回此{@code UUID} 的字符串表现形式。
     *
     * &amp;lt;p&amp;gt;
     * UUID 的字符串表示形式由此 BNF 描述：
     * 
     * &amp;lt;pre&amp;gt;
     * {@code
     * UUID                   = &amp;lt;time_low&amp;gt;-&amp;lt;time_mid&amp;gt;-&amp;lt;time_high_and_version&amp;gt;-&amp;lt;variant_and_sequence&amp;gt;-&amp;lt;node&amp;gt;
     * time_low               = 4*&amp;lt;hexOctet&amp;gt;
     * time_mid               = 2*&amp;lt;hexOctet&amp;gt;
     * time_high_and_version  = 2*&amp;lt;hexOctet&amp;gt;
     * variant_and_sequence   = 2*&amp;lt;hexOctet&amp;gt;
     * node                   = 6*&amp;lt;hexOctet&amp;gt;
     * hexOctet               = &amp;lt;hexDigit&amp;gt;&amp;lt;hexDigit&amp;gt;
     * hexDigit               = [0-9a-fA-F]
     * }
     * &amp;lt;/pre&amp;gt;
     * 
     * &amp;lt;/blockquote&amp;gt;
     *
     * @return 此{@code UUID} 的字符串表现形式
     * @see #toString(boolean)
     */
    @Override
    public String toString()
    {
        return toString(false);
    }

    /**
     * 返回此{@code UUID} 的字符串表现形式。
     *
     * &amp;lt;p&amp;gt;
     * UUID 的字符串表示形式由此 BNF 描述：
     * 
     * &amp;lt;pre&amp;gt;
     * {@code
     * UUID                   = &amp;lt;time_low&amp;gt;-&amp;lt;time_mid&amp;gt;-&amp;lt;time_high_and_version&amp;gt;-&amp;lt;variant_and_sequence&amp;gt;-&amp;lt;node&amp;gt;
     * time_low               = 4*&amp;lt;hexOctet&amp;gt;
     * time_mid               = 2*&amp;lt;hexOctet&amp;gt;
     * time_high_and_version  = 2*&amp;lt;hexOctet&amp;gt;
     * variant_and_sequence   = 2*&amp;lt;hexOctet&amp;gt;
     * node                   = 6*&amp;lt;hexOctet&amp;gt;
     * hexOctet               = &amp;lt;hexDigit&amp;gt;&amp;lt;hexDigit&amp;gt;
     * hexDigit               = [0-9a-fA-F]
     * }
     * &amp;lt;/pre&amp;gt;
     * 
     * &amp;lt;/blockquote&amp;gt;
     *
     * @param isSimple 是否简单模式，简单模式为不带&#39;-&#39;的UUID字符串
     * @return 此{@code UUID} 的字符串表现形式
     */
    public String toString(boolean isSimple)
    {
        final StringBuilder builder = new StringBuilder(isSimple ? 32 : 36);
        // time_low
        builder.append(digits(mostSigBits &amp;gt;&amp;gt; 32, 8));
        if (!isSimple)
        {
            builder.append(&#39;-&#39;);
        }
        // time_mid
        builder.append(digits(mostSigBits &amp;gt;&amp;gt; 16, 4));
        if (!isSimple)
        {
            builder.append(&#39;-&#39;);
        }
        // time_high_and_version
        builder.append(digits(mostSigBits, 4));
        if (!isSimple)
        {
            builder.append(&#39;-&#39;);
        }
        // variant_and_sequence
        builder.append(digits(leastSigBits &amp;gt;&amp;gt; 48, 4));
        if (!isSimple)
        {
            builder.append(&#39;-&#39;);
        }
        // node
        builder.append(digits(leastSigBits, 12));

        return builder.toString();
    }

    /**
     * 返回此 UUID 的哈希码。
     *
     * @return UUID 的哈希码值。
     */
    @Override
    public int hashCode()
    {
        long hilo = mostSigBits ^ leastSigBits;
        return ((int) (hilo &amp;gt;&amp;gt; 32)) ^ (int) hilo;
    }

    /**
     * 将此对象与指定对象比较。
     * &amp;lt;p&amp;gt;
     * 当且仅当参数不为 {@code null}、而是一个 UUID 对象、具有与此 UUID 相同的 varriant、包含相同的值（每一位均相同）时，结果才为 {@code true}。
     *
     * @param obj 要与之比较的对象
     *
     * @return 如果对象相同，则返回 {@code true}；否则返回 {@code false}
     */
    @Override
    public boolean equals(Object obj)
    {
        if ((null == obj) || (obj.getClass() != UUID.class))
        {
            return false;
        }
        UUID id = (UUID) obj;
        return (mostSigBits == id.mostSigBits &amp;amp;&amp;amp; leastSigBits == id.leastSigBits);
    }

    // Comparison Operations

    /**
     * 将此 UUID 与指定的 UUID 比较。
     *
     * &amp;lt;p&amp;gt;
     * 如果两个 UUID 不同，且第一个 UUID 的最高有效字段大于第二个 UUID 的对应字段，则第一个 UUID 大于第二个 UUID。
     *
     * @param val 与此 UUID 比较的 UUID
     *
     * @return 在此 UUID 小于、等于或大于 val 时，分别返回 -1、0 或 1。
     *
     */
    @Override
    public int compareTo(UUID val)
    {
        // The ordering is intentionally set up so that the UUIDs
        // can simply be numerically compared as two numbers
        return (this.mostSigBits &amp;lt; val.mostSigBits ? -1 : //
                (this.mostSigBits &amp;gt; val.mostSigBits ? 1 : //
                        (this.leastSigBits &amp;lt; val.leastSigBits ? -1 : //
                                (this.leastSigBits &amp;gt; val.leastSigBits ? 1 : //
                                        0))));
    }

    // -------------------------------------------------------------------------------------------------------------------
    // Private method start
    /**
     * 返回指定数字对应的hex值
     * 
     * @param val 值
     * @param digits 位
     * @return 值
     */
    private static String digits(long val, int digits)
    {
        long hi = 1L &amp;lt;&amp;lt; (digits * 4);
        return Long.toHexString(hi | (val &amp;amp; (hi - 1))).substring(1);
    }

    /**
     * 检查是否为time-based版本UUID
     */
    private void checkTimeBase()
    {
        if (version() != 1)
        {
            throw new UnsupportedOperationException(&amp;quot;Not a time-based UUID&amp;quot;);
        }
    }

    /**
     * 获取{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)
     * 
     * @return {@link SecureRandom}
     */
    public static SecureRandom getSecureRandom()
    {
        try
        {
            return SecureRandom.getInstance(&amp;quot;SHA1PRNG&amp;quot;);
        }
        catch (NoSuchAlgorithmException e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * 获取随机数生成器对象&amp;lt;br&amp;gt;
     * ThreadLocalRandom是JDK 7之后提供并发产生随机数，能够解决多个线程发生的竞争争夺。
     * 
     * @return {@link ThreadLocalRandom}
     */
    public static ThreadLocalRandom getRandom()
    {
        return ThreadLocalRandom.current();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;validatecodeutils&#34;&gt;ValidateCodeUtils&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ValidateCodeUtils.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 随机生成验证码工具类
 */
public class ValidateCodeUtils {

    /**
     * 随机生成验证码
     *
     * @param length 长度为4位或者6位
     * @return
     */
    public static String generateValidateCode(int length) {
        Integer code = null;
        if (length == 4) {
            // 生成随机数，最大为9999
            code = new Random().nextInt(9999);
            if (code &amp;lt; 1000) {
                // 保证随机数为4位数字
                code = code + 1000;
            }
        } else if (length == 6) {
            // 生成随机数，最大为999999
            code = new Random().nextInt(999999);
            if (code &amp;lt; 100000) {
                // 保证随机数为6位数字
                code = code + 100000;
            }
        } else {
            throw new RuntimeException(&amp;quot;只能生成4位或6位数字验证码&amp;quot;);
        }
        return String.valueOf(code);
    }

    /**
     * 随机生成指定长度字符串验证码 带字母
     *
     * @param length 长度
     * @return
     */
    public static String generateValidateCodeString(int length) {
        Random rdm = new Random();
        String hash1 = Integer.toHexString(rdm.nextInt());
        String capstr = hash1.substring(0, length);
        return capstr;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;beanutils&#34;&gt;BeanUtils&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BeanUtils.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BeanUtils {

    /**
     * 检查JavaBean所有属性字段是否非空
     *
     * @param object
     * @return true：所有属性是空  false：所有属性非空
     */
    public static boolean checkAllFilesIsNull(Object object) {
        if (null == object) {
            return true;
        }
        //通过反射获取对象所有属性字段
        Field[] fields = object.getClass().getDeclaredFields();
        for (Field field : fields) {
            //设置字段可访问
            field.setAccessible(true);
            //判断字段是否非空
            try {
                Object fieldValue = field.get(object);
                if (null != fieldValue &amp;amp;&amp;amp; !&amp;quot;&amp;quot;.equals(fieldValue.toString())) {
                    return false;
                }
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            }
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;base64utils&#34;&gt;Base64Utils&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Base64Utils.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Base64工具类
 */
public final class Base64Utils
{
    static private final int     BASELENGTH           = 128;
    static private final int     LOOKUPLENGTH         = 64;
    static private final int     TWENTYFOURBITGROUP   = 24;
    static private final int     EIGHTBIT             = 8;
    static private final int     SIXTEENBIT           = 16;
    static private final int     FOURBYTE             = 4;
    static private final int     SIGN                 = -128;
    static private final char    PAD                  = &#39;=&#39;;
    static final private byte[]  base64Alphabet       = new byte[BASELENGTH];
    static final private char[]  lookUpBase64Alphabet = new char[LOOKUPLENGTH];

    static
    {
        for (int i = 0; i &amp;lt; BASELENGTH; ++i)
        {
            base64Alphabet[i] = -1;
        }
        for (int i = &#39;Z&#39;; i &amp;gt;= &#39;A&#39;; i--)
        {
            base64Alphabet[i] = (byte) (i - &#39;A&#39;);
        }
        for (int i = &#39;z&#39;; i &amp;gt;= &#39;a&#39;; i--)
        {
            base64Alphabet[i] = (byte) (i - &#39;a&#39; + 26);
        }

        for (int i = &#39;9&#39;; i &amp;gt;= &#39;0&#39;; i--)
        {
            base64Alphabet[i] = (byte) (i - &#39;0&#39; + 52);
        }

        base64Alphabet[&#39;+&#39;] = 62;
        base64Alphabet[&#39;/&#39;] = 63;

        for (int i = 0; i &amp;lt;= 25; i++)
        {
            lookUpBase64Alphabet[i] = (char) (&#39;A&#39; + i);
        }

        for (int i = 26, j = 0; i &amp;lt;= 51; i++, j++)
        {
            lookUpBase64Alphabet[i] = (char) (&#39;a&#39; + j);
        }

        for (int i = 52, j = 0; i &amp;lt;= 61; i++, j++)
        {
            lookUpBase64Alphabet[i] = (char) (&#39;0&#39; + j);
        }
        lookUpBase64Alphabet[62] = (char) &#39;+&#39;;
        lookUpBase64Alphabet[63] = (char) &#39;/&#39;;
    }

    private static boolean isWhiteSpace(char octect)
    {
        return (octect == 0x20 || octect == 0xd || octect == 0xa || octect == 0x9);
    }

    private static boolean isPad(char octect)
    {
        return (octect == PAD);
    }

    private static boolean isData(char octect)
    {
        return (octect &amp;lt; BASELENGTH &amp;amp;&amp;amp; base64Alphabet[octect] != -1);
    }

    /**
     * Encodes hex octects into Base64
     *
     * @param binaryData Array containing binaryData
     * @return Encoded Base64 array
     */
    public static String encode(byte[] binaryData)
    {
        if (binaryData == null)
        {
            return null;
        }

        int lengthDataBits = binaryData.length * EIGHTBIT;
        if (lengthDataBits == 0)
        {
            return &amp;quot;&amp;quot;;
        }

        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;
        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;
        int numberQuartet = fewerThan24bits != 0 ? numberTriplets + 1 : numberTriplets;
        char encodedData[] = null;

        encodedData = new char[numberQuartet * 4];

        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;

        int encodedIndex = 0;
        int dataIndex = 0;

        for (int i = 0; i &amp;lt; numberTriplets; i++)
        {
            b1 = binaryData[dataIndex++];
            b2 = binaryData[dataIndex++];
            b3 = binaryData[dataIndex++];

            l = (byte) (b2 &amp;amp; 0x0f);
            k = (byte) (b1 &amp;amp; 0x03);

            byte val1 = ((b1 &amp;amp; SIGN) == 0) ? (byte) (b1 &amp;gt;&amp;gt; 2) : (byte) ((b1) &amp;gt;&amp;gt; 2 ^ 0xc0);
            byte val2 = ((b2 &amp;amp; SIGN) == 0) ? (byte) (b2 &amp;gt;&amp;gt; 4) : (byte) ((b2) &amp;gt;&amp;gt; 4 ^ 0xf0);
            byte val3 = ((b3 &amp;amp; SIGN) == 0) ? (byte) (b3 &amp;gt;&amp;gt; 6) : (byte) ((b3) &amp;gt;&amp;gt; 6 ^ 0xfc);

            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k &amp;lt;&amp;lt; 4)];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[(l &amp;lt;&amp;lt; 2) | val3];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[b3 &amp;amp; 0x3f];
        }

        // form integral number of 6-bit groups
        if (fewerThan24bits == EIGHTBIT)
        {
            b1 = binaryData[dataIndex];
            k = (byte) (b1 &amp;amp; 0x03);
            byte val1 = ((b1 &amp;amp; SIGN) == 0) ? (byte) (b1 &amp;gt;&amp;gt; 2) : (byte) ((b1) &amp;gt;&amp;gt; 2 ^ 0xc0);
            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[k &amp;lt;&amp;lt; 4];
            encodedData[encodedIndex++] = PAD;
            encodedData[encodedIndex++] = PAD;
        }
        else if (fewerThan24bits == SIXTEENBIT)
        {
            b1 = binaryData[dataIndex];
            b2 = binaryData[dataIndex + 1];
            l = (byte) (b2 &amp;amp; 0x0f);
            k = (byte) (b1 &amp;amp; 0x03);

            byte val1 = ((b1 &amp;amp; SIGN) == 0) ? (byte) (b1 &amp;gt;&amp;gt; 2) : (byte) ((b1) &amp;gt;&amp;gt; 2 ^ 0xc0);
            byte val2 = ((b2 &amp;amp; SIGN) == 0) ? (byte) (b2 &amp;gt;&amp;gt; 4) : (byte) ((b2) &amp;gt;&amp;gt; 4 ^ 0xf0);

            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k &amp;lt;&amp;lt; 4)];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[l &amp;lt;&amp;lt; 2];
            encodedData[encodedIndex++] = PAD;
        }
        return new String(encodedData);
    }

    /**
     * Decodes Base64 data into octects
     *
     * @param encoded string containing Base64 data
     * @return Array containind decoded data.
     */
    public static byte[] decode(String encoded)
    {
        if (encoded == null)
        {
            return null;
        }

        char[] base64Data = encoded.toCharArray();
        // remove white spaces
        int len = removeWhiteSpace(base64Data);

        if (len % FOURBYTE != 0)
        {
            return null;// should be divisible by four
        }

        int numberQuadruple = (len / FOURBYTE);

        if (numberQuadruple == 0)
        {
            return new byte[0];
        }

        byte decodedData[] = null;
        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;
        char d1 = 0, d2 = 0, d3 = 0, d4 = 0;

        int i = 0;
        int encodedIndex = 0;
        int dataIndex = 0;
        decodedData = new byte[(numberQuadruple) * 3];

        for (; i &amp;lt; numberQuadruple - 1; i++)
        {

            if (!isData((d1 = base64Data[dataIndex++])) || !isData((d2 = base64Data[dataIndex++]))
                    || !isData((d3 = base64Data[dataIndex++])) || !isData((d4 = base64Data[dataIndex++])))
            {
                return null;
            } // if found &amp;quot;no data&amp;quot; just return null

            b1 = base64Alphabet[d1];
            b2 = base64Alphabet[d2];
            b3 = base64Alphabet[d3];
            b4 = base64Alphabet[d4];

            decodedData[encodedIndex++] = (byte) (b1 &amp;lt;&amp;lt; 2 | b2 &amp;gt;&amp;gt; 4);
            decodedData[encodedIndex++] = (byte) (((b2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4) | ((b3 &amp;gt;&amp;gt; 2) &amp;amp; 0xf));
            decodedData[encodedIndex++] = (byte) (b3 &amp;lt;&amp;lt; 6 | b4);
        }

        if (!isData((d1 = base64Data[dataIndex++])) || !isData((d2 = base64Data[dataIndex++])))
        {
            return null;// if found &amp;quot;no data&amp;quot; just return null
        }

        b1 = base64Alphabet[d1];
        b2 = base64Alphabet[d2];

        d3 = base64Data[dataIndex++];
        d4 = base64Data[dataIndex++];
        if (!isData((d3)) || !isData((d4)))
        {// Check if they are PAD characters
            if (isPad(d3) &amp;amp;&amp;amp; isPad(d4))
            {
                if ((b2 &amp;amp; 0xf) != 0)// last 4 bits should be zero
                {
                    return null;
                }
                byte[] tmp = new byte[i * 3 + 1];
                System.arraycopy(decodedData, 0, tmp, 0, i * 3);
                tmp[encodedIndex] = (byte) (b1 &amp;lt;&amp;lt; 2 | b2 &amp;gt;&amp;gt; 4);
                return tmp;
            }
            else if (!isPad(d3) &amp;amp;&amp;amp; isPad(d4))
            {
                b3 = base64Alphabet[d3];
                if ((b3 &amp;amp; 0x3) != 0)// last 2 bits should be zero
                {
                    return null;
                }
                byte[] tmp = new byte[i * 3 + 2];
                System.arraycopy(decodedData, 0, tmp, 0, i * 3);
                tmp[encodedIndex++] = (byte) (b1 &amp;lt;&amp;lt; 2 | b2 &amp;gt;&amp;gt; 4);
                tmp[encodedIndex] = (byte) (((b2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4) | ((b3 &amp;gt;&amp;gt; 2) &amp;amp; 0xf));
                return tmp;
            }
            else
            {
                return null;
            }
        }
        else
        { // No PAD e.g 3cQl
            b3 = base64Alphabet[d3];
            b4 = base64Alphabet[d4];
            decodedData[encodedIndex++] = (byte) (b1 &amp;lt;&amp;lt; 2 | b2 &amp;gt;&amp;gt; 4);
            decodedData[encodedIndex++] = (byte) (((b2 &amp;amp; 0xf) &amp;lt;&amp;lt; 4) | ((b3 &amp;gt;&amp;gt; 2) &amp;amp; 0xf));
            decodedData[encodedIndex++] = (byte) (b3 &amp;lt;&amp;lt; 6 | b4);

        }
        return decodedData;
    }

    /**
     * remove WhiteSpace from MIME containing encoded Base64 data.
     *
     * @param data the byte array of base64 data (with WS)
     * @return the new length
     */
    private static int removeWhiteSpace(char[] data)
    {
        if (data == null)
        {
            return 0;
        }

        // count characters that&#39;s not whitespace
        int newSize = 0;
        int len = data.length;
        for (int i = 0; i &amp;lt; len; i++)
        {
            if (!isWhiteSpace(data[i]))
            {
                data[newSize++] = data[i];
            }
        }
        return newSize;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;md5utils&#34;&gt;Md5Utils&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Md5Utils.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Md5加密方法
 */
public class Md5Utils
{
    private static final Logger log = LoggerFactory.getLogger(Md5Utils.class);

    private static byte[] md5(String s)
    {
        MessageDigest algorithm;
        try
        {
            algorithm = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;);
            algorithm.reset();
            algorithm.update(s.getBytes(&amp;quot;UTF-8&amp;quot;));
            byte[] messageDigest = algorithm.digest();
            return messageDigest;
        }
        catch (Exception e)
        {
            log.error(&amp;quot;MD5 Error...&amp;quot;, e);
        }
        return null;
    }

    private static final String toHex(byte hash[])
    {
        if (hash == null)
        {
            return null;
        }
        StringBuffer buf = new StringBuffer(hash.length * 2);
        int i;

        for (i = 0; i &amp;lt; hash.length; i++)
        {
            if ((hash[i] &amp;amp; 0xff) &amp;lt; 0x10)
            {
                buf.append(&amp;quot;0&amp;quot;);
            }
            buf.append(Long.toString(hash[i] &amp;amp; 0xff, 16));
        }
        return buf.toString();
    }

    public static String hash(String s)
    {
        try
        {
            return new String(toHex(md5(s)).getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8);
        }
        catch (Exception e)
        {
            log.error(&amp;quot;not supported charset...{}&amp;quot;, e);
            return s;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;doublearithutils&#34;&gt;DoubleArithUtils&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DoubleArithUtils.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 精确的浮点数运算
 */
public class DoubleArithUtils {

    /**
     * 默认除法运算精度
     */
    private static final int DEF_DIV_SCALE = 10;

    /**
     * 这个类不能实例化
     */
    private DoubleArithUtils() {
    }

    /**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.add(b2).doubleValue();
    }

    /**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double sub(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.subtract(b2).doubleValue();
    }

    /**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double mul(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.multiply(b2).doubleValue();
    }

    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double div(double v1, double v2) {
        return div(v1, v2, DEF_DIV_SCALE);
    }

    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double div(double v1, double v2, int scale) {
        if (scale &amp;lt; 0) {
            throw new IllegalArgumentException(
                    &amp;quot;The scale must be a positive integer or zero&amp;quot;);
        }
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        if (b1.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO.doubleValue();
        }
        return b1.divide(b2, scale, RoundingMode.HALF_UP).doubleValue();
    }

    /**
     * 提供精确的小数位四舍五入处理。
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double v, int scale) {
        if (scale &amp;lt; 0) {
            throw new IllegalArgumentException(
                    &amp;quot;The scale must be a positive integer or zero&amp;quot;);
        }
        BigDecimal b = new BigDecimal(Double.toString(v));
        BigDecimal one = BigDecimal.ONE;
        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dateutils&#34;&gt;DateUtils&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DateUtils.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 时间工具类
 */
public class DateUtils {

    /**
     * 获取服务器启动时间
     */
    public static Date getServerStartDate() {
        long time = ManagementFactory.getRuntimeMXBean().getStartTime();
        return new Date(time);
    }

    /**
     * 计算相差天数
     */
    public static int differentDaysByMillisecond(Date date1, Date date2) {
        return Math.abs((int) ((date2.getTime() - date1.getTime()) / (1000 * 3600 * 24)));
    }

    /**
     * 计算两个时间差
     */
    public static String getDatePoor(Date endDate, Date nowDate) {
        long nd = 1000 * 24 * 60 * 60;
        long nh = 1000 * 60 * 60;
        long nm = 1000 * 60;
        // long ns = 1000;
        // 获得两个时间的毫秒时间差异
        long diff = endDate.getTime() - nowDate.getTime();
        // 计算差多少天
        long day = diff / nd;
        // 计算差多少小时
        long hour = diff % nd / nh;
        // 计算差多少分钟
        long min = diff % nd % nh / nm;
        // 计算差多少秒//输出结果
        // long sec = diff % nd % nh % nm / ns;
        return day + &amp;quot;天&amp;quot; + hour + &amp;quot;小时&amp;quot; + min + &amp;quot;分钟&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;webutils&#34;&gt;WebUtils&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;WebUtils.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WebUtils {
    /**
     * 将字符串渲染到客户端
     *
     * @param response HttpServletResponse
     * @param string   待渲染的字符串
     * @return null
     */
    public static String renderString(HttpServletResponse response, String string) {
        try {
            response.setStatus(200);
            response.setContentType(&amp;quot;application/json&amp;quot;);
            response.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
            response.getWriter().print(string);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jdbc&#34;&gt;jdbc&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;jdbc.properties&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/mydb?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false
# jdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
jdbc.username=root
jdbc.password=
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;druid&#34;&gt;druid&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;druid.properties&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;pool.init=1
pool.minIdle=3
pool.maxActive=20
pool.maxWait=60000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cloud&#34;&gt;Cloud&lt;/h2&gt;
&lt;h3 id=&#34;aliyunsmsutilis&#34;&gt;AliyunSMSUtilis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AliyunSMSUtilis.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--阿里云短信--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.aliyun&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;dysmsapi20170525&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.0.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AliyunSMSUtilis {

    /**
     * 使用AK&amp;amp;SK初始化账号Client
     *
     * @param accessKeyId
     * @param accessKeySecret
     * @return Client
     * @throws Exception
     */
    public static com.aliyun.dysmsapi20170525.Client createClient(String accessKeyId, String accessKeySecret) throws Exception {
        Config config = new Config()
                // 您的 AccessKey ID
                .setAccessKeyId(String.valueOf(XXXConstant.ALIYUN_ACCESS_KEY_ID))
                // 您的 AccessKey Secret
                .setAccessKeySecret(String.valueOf(XXXConstant.ALIYUN_ACCESS_KEY_SECRET));
        // 访问的域名
        config.endpoint = XXXConstant.ALIYUN_SMS_ENDPOINT;
        return new com.aliyun.dysmsapi20170525.Client(config);
    }

    public static void sendSMS(String phoneNumber, JsonObject validateCode) throws Exception {
        // 1.发送短信
        com.aliyun.dysmsapi20170525.Client client = AliyunSMSUtilis.createClient(&amp;quot;accessKeyId&amp;quot;, &amp;quot;accessKeySecret&amp;quot;);
        SendSmsRequest sendSmsRequest = new SendSmsRequest()
                .setSignName(&amp;quot;XXXConstant.ALIYUN_SMS_SIGNNAME&amp;quot;)//阿里云短信测试
                .setTemplateCode(&amp;quot;XXXConstant.ALIYUN_SMS_TEMPLATECODE&amp;quot;)//SMS_154950909
                .setPhoneNumbers(phoneNumber)
                .setTemplateParam(validateCode.toString());// {&amp;quot;code&amp;quot;:&amp;quot;xxxx&amp;quot;}
        RuntimeOptions runtime = new RuntimeOptions();
        try {
            // 复制代码运行请自行打印 API 的返回值
            SendSmsResponse sendSmsResponse = client.sendSmsWithOptions(sendSmsRequest, runtime);
            System.out.println(&amp;quot;****************&amp;quot;);
            System.out.println(&amp;quot;sendSmsResponse.body.message=&amp;quot; + sendSmsResponse.body.message);
            System.out.println(&amp;quot;sendSmsResponse.body.code=&amp;quot; + sendSmsResponse.body.code);
            System.out.println(&amp;quot;****************&amp;quot;);
            String code = sendSmsResponse.body.code;
            if (!com.aliyun.teautil.Common.equalString(code, &amp;quot;OK&amp;quot;)) {
                String message = &amp;quot;49-SMS-错误信息: &amp;quot; + sendSmsResponse.body.message + &amp;quot;&amp;quot;;
                throw new RuntimeException(message);
            }
        } catch (TeaException error) {
            // 如有需要，请打印 error
            com.aliyun.teautil.Common.assertAsString(error.message);
            String message = &amp;quot;55-SMS-TeaException&amp;quot; + error.message;
            throw new RuntimeException(message);
        } catch (Exception _error) {
            TeaException error = new TeaException(_error.getMessage(), _error);
            // 如有需要，请打印 error
            com.aliyun.teautil.Common.assertAsString(error.message);
            String message = &amp;quot;61-SMS-Exception&amp;quot; + error.message;
            throw new RuntimeException(message);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;qiniuossutils&#34;&gt;QiniuOSSUtils&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;QiniuOSSUtils.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--七牛云--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.qiniu&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;qiniu-java-sdk&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;[7.7.0, 7.10.99]&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class QiniuOSSUtils {

    public static String uploadFile(InputStream fileInputStream, String fileName) {
        //构造一个带指定 Region 对象的配置类
        Configuration cfg = new Configuration(Region.region0());
        //创建上传对象
        UploadManager uploadManager = new UploadManager(cfg);
        //...生成上传凭证，然后准备上传
        String accessKey = String.valueOf(XXXConstant.QINIU_ACCESS_KEY);
        String secretKey = String.valueOf(XXXConstant.QINIU_SECRET_KEY);
        String bucket = XXXConstant.QINIU_BUCKET;

        //默认不指定key的情况下，以文件内容的hash值作为文件名
        String key = fileName;

        Auth auth = Auth.create(accessKey, secretKey);
        String upToken = auth.uploadToken(bucket);

        try {
            Response response = uploadManager.put(fileInputStream, key, upToken, null, null);
            //解析上传成功的结果
            DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);
            System.out.println(&amp;quot;39 - 七牛云上传成功 - putRet.key=&amp;quot; + putRet.key);
            System.out.println(&amp;quot;40 - 七牛云上传成功 - putRet.hash=&amp;quot; + putRet.hash);
            return &amp;quot;http://&amp;quot;+XXXConstant.QINIU_DOMAIN+&amp;quot;/&amp;quot; + putRet.key;
        } catch (QiniuException ex) {
            Response r = ex.response;
            System.err.println(&amp;quot;44 - 七牛云上传失败 - response=&amp;quot; + r.toString());
            try {
                System.err.println(&amp;quot;46 - 七牛云上传失败 - response.bodyString=&amp;quot; + r.bodyString());
            } catch (QiniuException ex2) {
                //ignore
                System.err.println(&amp;quot;49 - 七牛云上传失败 - response.ex2=&amp;quot; + ex2.toString());
            }
        }

        return null;
    }

    public static boolean deleteFile(String fileName) {
        //构造一个带指定 Region 对象的配置类
        Configuration cfg = new Configuration(Region.region0());

        String accessKey = String.valueOf(XXXConstant.QINIU_ACCESS_KEY);
        String secretKey = String.valueOf(XXXConstant.QINIU_SECRET_KEY);
        String bucket = XXXConstant.QINIU_BUCKET;
        String key = fileName;

        Auth auth = Auth.create(accessKey, secretKey);
        BucketManager bucketManager = new BucketManager(auth, cfg);
        try {
            bucketManager.delete(bucket, key);
            return true;
        } catch (QiniuException ex) {
            //如果遇到异常，说明删除失败
            System.err.println(ex.code());
            System.err.println(ex.response.toString());
        }
        return false;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ssm&#34;&gt;SSM&lt;/h2&gt;
&lt;h3 id=&#34;web&#34;&gt;web&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;web.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;web-app xmlns=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&amp;quot;
         version=&amp;quot;4.0&amp;quot;&amp;gt;

    &amp;lt;!--配置springMVC的编码过滤器--&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;forceResponseEncoding&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;

    &amp;lt;!-- 配置SpringMVC的前端控制器 --&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;WEB-INF/dispatcher-config.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

    &amp;lt;!-- 配置Spring的监听器 --&amp;gt;
    &amp;lt;listener&amp;gt;
        &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
    &amp;lt;/listener&amp;gt;

    &amp;lt;!-- 设置Spring的配置文件的位置和名称 --&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;classpath:spring/*.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;

    &amp;lt;!-- druid监控配置--&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;DruidStatView&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;com.alibaba.druid.support.http.StatViewServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;!-- 允许清空统计数据 --&amp;gt;
            &amp;lt;param-name&amp;gt;resetEnable&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;!--配置访问监控页面登录的用户名和密码（可选），实际开发中都会配置--&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;!-- 用户名 --&amp;gt;
            &amp;lt;param-name&amp;gt;loginUsername&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;druid&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;!-- 密码 --&amp;gt;
            &amp;lt;param-name&amp;gt;loginPassword&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;druid&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;DruidStatView&amp;lt;/servlet-name&amp;gt;
        &amp;lt;!-- 访问监控页面的映射请求，实际访问一般都在浏览器输入http://xxx/druid/index --&amp;gt;
        &amp;lt;url-pattern&amp;gt;/druid/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;log4j-config&#34;&gt;log4j-config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;log4j.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE log4j:configuration SYSTEM &amp;quot;log4j.dtd&amp;quot;&amp;gt;
&amp;lt;log4j:configuration xmlns:log4j=&amp;quot;http://jakarta.apache.org/log4j/&amp;quot;&amp;gt;
    &amp;lt;appender name=&amp;quot;STDOUT&amp;quot; class=&amp;quot;org.apache.log4j.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;param name=&amp;quot;Encoding&amp;quot; value=&amp;quot;UTF-8&amp;quot; /&amp;gt;
        &amp;lt;layout class=&amp;quot;org.apache.log4j.PatternLayout&amp;quot;&amp;gt;
         &amp;lt;param name=&amp;quot;ConversionPattern&amp;quot; value=&amp;quot;%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \n&amp;quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;logger name=&amp;quot;java.sql&amp;quot;&amp;gt;
        &amp;lt;level value=&amp;quot;debug&amp;quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&amp;quot;org.apache.ibatis&amp;quot;&amp;gt;
        &amp;lt;level value=&amp;quot;info&amp;quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;root&amp;gt;
        &amp;lt;level value=&amp;quot;debug&amp;quot; /&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/log4j:configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dispatcher-config&#34;&gt;dispatcher-config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dispatcher-config.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xmlns:mvc=&amp;quot;http://www.springframework.org/schema/mvc&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&amp;quot;&amp;gt;

    &amp;lt;!--扫描控制层组件--&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.xxx.controller&amp;quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!-- 开启MVC的注解驱动 --&amp;gt;
    &amp;lt;mvc:annotation-driven/&amp;gt;

    &amp;lt;!-- 处理CORS --&amp;gt;
    &amp;lt;mvc:cors&amp;gt;
        &amp;lt;mvc:mapping path=&amp;quot;/api/**&amp;quot; allowed-origin-patterns=&amp;quot;http://localhost:*&amp;quot; allowed-methods=&amp;quot;GET,POST&amp;quot; max-age=&amp;quot;3600&amp;quot;/&amp;gt;
    &amp;lt;/mvc:cors&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;applicationcontext&#34;&gt;applicationContext&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;applicationContext.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:content=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;

    &amp;lt;!--扫描服务层组件--&amp;gt;
    &amp;lt;content:component-scan base-package=&amp;quot;com.xxx.service.impl&amp;quot;&amp;gt;&amp;lt;/content:component-scan&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;applicationcontext-dao&#34;&gt;applicationContext-dao&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;applicationContext-dao.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:content=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;

    &amp;lt;!-- 引入jdbc.properties和druid.properties --&amp;gt;
    &amp;lt;content:property-placeholder location=&amp;quot;classpath:props/jdbc.properties,classpath:props/druid.properties&amp;quot;&amp;gt;&amp;lt;/content:property-placeholder&amp;gt;

    &amp;lt;!-- 配置Druid数据源 --&amp;gt;
    &amp;lt;bean id=&amp;quot;dataSource&amp;quot; class=&amp;quot;com.alibaba.druid.pool.DruidDataSource&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;!--数据源控制属性--&amp;gt;
        &amp;lt;!-- 配置初始化大小、最小、最大 --&amp;gt;
        &amp;lt;property name=&amp;quot;initialSize&amp;quot; value=&amp;quot;${pool.init}&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;minIdle&amp;quot; value=&amp;quot;${pool.minIdle}&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;maxActive&amp;quot; value=&amp;quot;${pool.maxActive}&amp;quot;/&amp;gt;
        &amp;lt;!-- 配置获取连接等待超时的时间 --&amp;gt;
        &amp;lt;property name=&amp;quot;maxWait&amp;quot; value=&amp;quot;${pool.maxWait}&amp;quot;/&amp;gt;
        &amp;lt;!-- 配置监控统计拦截的filters --&amp;gt;
        &amp;lt;property name=&amp;quot;filters&amp;quot; value=&amp;quot;stat&amp;quot;/&amp;gt;
        &amp;lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&amp;gt;
        &amp;lt;property name=&amp;quot;timeBetweenEvictionRunsMillis&amp;quot; value=&amp;quot;2000&amp;quot;/&amp;gt;
        &amp;lt;!--其他配置--&amp;gt;
        &amp;lt;property name=&amp;quot;minEvictableIdleTimeMillis&amp;quot; value=&amp;quot;300000&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;testWhileIdle&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;testOnBorrow&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;testOnReturn&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;poolPreparedStatements&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;maxOpenPreparedStatements&amp;quot; value=&amp;quot;20&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;applicationcontext-mybatis&#34;&gt;applicationContext-mybatis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;applicationContext-mybatis.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

    &amp;lt;!-- 配置用于创建SqlSessionFactory的工厂bean，可以直接在Spring的IOC中获取SqlSessionFactory --&amp;gt;
    &amp;lt;bean class=&amp;quot;org.mybatis.spring.SqlSessionFactoryBean&amp;quot;&amp;gt;
        &amp;lt;!-- 设置MyBatis核心配置文件的路径 --&amp;gt;
        &amp;lt;property name=&amp;quot;configLocation&amp;quot; value=&amp;quot;classpath:mybatis/mybatis-config.xml&amp;quot;&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- 设置数据源 --&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;!--设置映射文件的路径 --&amp;gt;
        &amp;lt;property name=&amp;quot;mapperLocations&amp;quot; value=&amp;quot;classpath:com/xxx/mapper/xml/*.xml&amp;quot;&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 配置mapper接口的扫描 --&amp;gt;
    &amp;lt;bean class=&amp;quot;org.mybatis.spring.mapper.MapperScannerConfigurer&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;basePackage&amp;quot; value=&amp;quot;com.xxx.mapper&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;applicationcontext-tx&#34;&gt;applicationContext-tx&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;applicationContext-tx.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&amp;quot;&amp;gt;

    &amp;lt;!--配置事务管理器--&amp;gt;
    &amp;lt;bean id=&amp;quot;transactionManager&amp;quot; class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 开启事务的注解驱动 --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&amp;quot;transactionManager&amp;quot;&amp;gt;&amp;lt;/tx:annotation-driven&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mybatis&#34;&gt;Mybatis&lt;/h2&gt;
&lt;h3 id=&#34;mybatis-config&#34;&gt;mybatis-config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mybatis-config.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;properties resource=&amp;quot;jdbc.properties&amp;quot;&amp;gt;&amp;lt;/properties&amp;gt;
    
    &amp;lt;settings&amp;gt;
        &amp;lt;!--将表中字段的下划线自动转换为驼峰--&amp;gt;
        &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;
    
    &amp;lt;!--设置类型别名--&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;package name=&amp;quot;${typeAliases_PACKAGE_NAME}&amp;quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;
    
    &amp;lt;plugins&amp;gt;
        &amp;lt;!--设置分页插件--&amp;gt;
        &amp;lt;plugin interceptor=&amp;quot;com.github.pagehelper.PageInterceptor&amp;quot;&amp;gt;
            &amp;lt;!--reasonable：分页合理化参数，默认值为false,直接根据参数进行查询。
              当该参数设置为 true 时，pageNum&amp;lt;=0 时会查询第一页， pageNum&amp;gt;pages（超过总数时），会查询最后一页。--&amp;gt;
            &amp;lt;property name=&amp;quot;reasonable&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;pageSizeZero&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
    
    &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;&amp;gt;&amp;lt;/transactionManager&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

    &amp;lt;!--引入映射文件--&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;!--        &amp;lt;mapper resource=&amp;quot;mybatisdemo/mappers/UserMapper.xml&amp;quot;/&amp;gt;--&amp;gt;
        &amp;lt;!--
        以包为单位，将包下所有的映射文件引入核心配置文件
        注意：
         1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下
         2. mapper接口要和mapper映射文件的名字一致
         &amp;lt;package name=&amp;quot;com.example.mybatis.mapper&amp;quot;/&amp;gt;
        --&amp;gt;
        &amp;lt;!--        &amp;lt;package name=&amp;quot;&amp;quot;/&amp;gt;--&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mybatis-mapper&#34;&gt;mybatis-mapper&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XxxxMapper.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;

&amp;lt;mapper namespace=&amp;quot;${NAMESPACE}&amp;quot;&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;generatorconfig&#34;&gt;generatorConfig&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;generatorConfig.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
        PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot;&amp;gt;
&amp;lt;generatorConfiguration&amp;gt;
    &amp;lt;!--
    targetRuntime: 执行生成的逆向工程的版本
    MyBatis3Simple: 生成基本的CRUD（清新简洁版）
    MyBatis3: 生成带条件的CRUD（奢华尊享版）
    --&amp;gt;
    &amp;lt;context id=&amp;quot;DB2Tables&amp;quot; targetRuntime=&amp;quot;MyBatis3&amp;quot;&amp;gt;
        &amp;lt;!-- 数据库的连接信息 --&amp;gt;
        &amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.jdbc.Driver&amp;quot;
                        connectionURL=&amp;quot;jdbc:mysql://127.0.0.1:3305/yaorange_office_ssm?characterEncoding=utf8&amp;amp;amp;useSSL=false&amp;quot;
                        userId=&amp;quot;root&amp;quot;
                        password=&amp;quot;xxx&amp;quot;&amp;gt;
        &amp;lt;/jdbcConnection&amp;gt;
        &amp;lt;!-- javaBean的生成策略--&amp;gt;
        &amp;lt;javaModelGenerator targetPackage=&amp;quot;com.xxx.entity&amp;quot; targetProject=&amp;quot;src/main/java&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
            &amp;lt;property name=&amp;quot;trimStrings&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
        &amp;lt;/javaModelGenerator&amp;gt;
        &amp;lt;!-- SQL映射文件的生成策略 --&amp;gt;
        &amp;lt;sqlMapGenerator targetPackage=&amp;quot;com.xxx.mapper&amp;quot;
                         targetProject=&amp;quot;src/main/resources&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
        &amp;lt;/sqlMapGenerator&amp;gt;
        &amp;lt;!-- Mapper接口的生成策略 --&amp;gt;
        &amp;lt;javaClientGenerator type=&amp;quot;XMLMAPPER&amp;quot;
                             targetPackage=&amp;quot;com.xxx.mapper&amp;quot; targetProject=&amp;quot;src/main/java&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
        &amp;lt;/javaClientGenerator&amp;gt;
        &amp;lt;!-- 逆向分析的表 --&amp;gt;
        &amp;lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&amp;gt;
        &amp;lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&amp;gt;
        &amp;lt;table tableName=&amp;quot;article&amp;quot; domainObjectName=&amp;quot;Article&amp;quot;/&amp;gt;
        &amp;lt;table tableName=&amp;quot;user&amp;quot; domainObjectName=&amp;quot;User&amp;quot;/&amp;gt;
    &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;spring-boot&#34;&gt;Spring Boot&lt;/h2&gt;
&lt;h3 id=&#34;banner&#34;&gt;banner&lt;/h3&gt;
&lt;p&gt;banner.txt&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Spring Boot Version: ${spring-boot.version}
////////////////////////////////////////////////////////////////////
//                          _ooOoo_                               //
//                         o8888888o                              //
//                         88&amp;quot; . &amp;quot;88                              //
//                         (| ^_^ |)                              //
//                         O\  =  /O                              //
//                      ____/`---&#39;\____                           //
//                    .&#39;  \\|     |//  `.                         //
//                   /  \\|||  :  |||//  \                        //
//                  /  _||||| -:- |||||-  \                       //
//                  |   | \\\  -  /// |   |                       //
//                  | \_|  &#39;&#39;\---/&#39;&#39;  |   |                       //
//                  \  .-\__  `-`  ___/-. /                       //
//                ___`. .&#39;  /--.--\  `. . ___                     //
//              .&amp;quot;&amp;quot; &#39;&amp;lt;  `.___\_&amp;lt;|&amp;gt;_/___.&#39;  &amp;gt;&#39;&amp;quot;&amp;quot;.                  //
//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //
//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //
//      ========`-.____`-.___\_____/___.-`____.-&#39;========         //
//                           `=---=&#39;                              //
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //
//             佛祖保佑       永不宕机      永无BUG               //
////////////////////////////////////////////////////////////////////
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;application&#34;&gt;application&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;application.yaml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  datasource:
    # 连接数据库
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3305/mydb?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false
    username: root
    password: xxx

    # 配置druid
    druid:
      initial-size: 1
      max-active: 20
      max-wait: 6000
      min-idle: 1
      filters: stat
      stat-view-servlet:
        enabled: true
        login-password: druid
        login-username: druid
        reset-enable: true
        url-pattern: /druid/*
      test-on-borrow: true

# 日志
logging:
  level:
    com.yaorange.ssm: DEBUG
    org.springframework.jdbc.datasource: DEBUG

# mybatis
mybatis:
  mapper-locations: classpath:com/xxx/mapper/xml/*Mapper.xml
  type-aliases-package: com.yaorange.entity

# 分页合理化参数
pagehelper:
  reasonable: true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;springboot-cors-congig&#34;&gt;SpringBoot-CORS-Congig&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MvcConfiguration.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration(proxyBeanMethods = false)
public class MvcConfiguration {

    /**
     * 处理CORS
     *
     * @return
     */
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping(&amp;quot;/api/**&amp;quot;)
                        .allowedOriginPatterns(&amp;quot;http://localhost:*&amp;quot;)
                        .allowedMethods(&amp;quot;GET&amp;quot;, &amp;quot;POST&amp;quot;, &amp;quot;PUT&amp;quot;, &amp;quot;DELETE&amp;quot;)
                        .allowCredentials(true)//设置是否允许客户端跨域携带验证数据，如Cookie值
                        .maxAge(3600);
            }
        };
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;
&lt;h3 id=&#34;rediscache&#34;&gt;RedisCache&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RedisCache.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Spring Redis 工具类
 **/
@SuppressWarnings(value = {&amp;quot;unchecked&amp;quot;, &amp;quot;rawtypes&amp;quot;})
@Component
public class RedisCache {

    private final RedisTemplate redisTemplate;

    public RedisCache(RedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key   缓存的键值
     * @param value 缓存的值
     */
    public &amp;lt;T&amp;gt; void setCacheObject(final String key, final T value) {
        redisTemplate.opsForValue().set(key, value);
    }

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key      缓存的键值
     * @param value    缓存的值
     * @param timeout  时间
     * @param timeUnit 时间颗粒度
     */
    public &amp;lt;T&amp;gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) {
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    /**
     * 设置有效时间
     *
     * @param key     Redis键
     * @param timeout 超时时间
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout) {
        return expire(key, timeout, TimeUnit.SECONDS);
    }

    /**
     * 设置有效时间
     *
     * @param key     Redis键
     * @param timeout 超时时间
     * @param unit    时间单位
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout, final TimeUnit unit) {
        return redisTemplate.expire(key, timeout, unit);
    }

    /**
     * 获取有效时间
     *
     * @param key Redis键
     * @return 有效时间
     */
    public long getExpire(final String key) {
        return redisTemplate.getExpire(key);
    }

    /**
     * 判断 key是否存在
     *
     * @param key 键
     * @return true 存在 false不存在
     */
    public Boolean hasKey(String key) {
        return redisTemplate.hasKey(key);
    }

    /**
     * 获得缓存的基本对象。
     *
     * @param key 缓存键值
     * @return 缓存键值对应的数据
     */
    public &amp;lt;T&amp;gt; T getCacheObject(final String key) {
        ValueOperations&amp;lt;String, T&amp;gt; operation = redisTemplate.opsForValue();
        return operation.get(key);
    }

    /**
     * 删除单个对象
     *
     * @param key
     */
    public boolean deleteObject(final String key) {
        return redisTemplate.delete(key);
    }

    /**
     * 删除集合对象
     *
     * @param collection 多个对象
     * @return
     */
    public long deleteObject(final Collection collection) {
        return redisTemplate.delete(collection);
    }

    /**
     * 缓存List数据
     *
     * @param key      缓存的键值
     * @param dataList 待缓存的List数据
     * @return 缓存的对象
     */
    public &amp;lt;T&amp;gt; long setCacheList(final String key, final List&amp;lt;T&amp;gt; dataList) {
        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);
        return count == null ? 0 : count;
    }

    /**
     * 获得缓存的list对象
     *
     * @param key 缓存的键值
     * @return 缓存键值对应的数据
     */
    public &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; getCacheList(final String key) {
        return redisTemplate.opsForList().range(key, 0, -1);
    }

    /**
     * 缓存Set
     *
     * @param key     缓存键值
     * @param dataSet 缓存的数据
     * @return 缓存数据的对象
     */
    public &amp;lt;T&amp;gt; BoundSetOperations&amp;lt;String, T&amp;gt; setCacheSet(final String key, final Set&amp;lt;T&amp;gt; dataSet) {
        BoundSetOperations&amp;lt;String, T&amp;gt; setOperation = redisTemplate.boundSetOps(key);
        Iterator&amp;lt;T&amp;gt; it = dataSet.iterator();
        while (it.hasNext()) {
            setOperation.add(it.next());
        }
        return setOperation;
    }

    /**
     * 获得缓存的set
     *
     * @param key
     * @return
     */
    public &amp;lt;T&amp;gt; Set&amp;lt;T&amp;gt; getCacheSet(final String key) {
        return redisTemplate.opsForSet().members(key);
    }

    /**
     * 缓存Map
     *
     * @param key
     * @param dataMap
     */
    public &amp;lt;T&amp;gt; void setCacheMap(final String key, final Map&amp;lt;String, T&amp;gt; dataMap) {
        if (dataMap != null) {
            redisTemplate.opsForHash().putAll(key, dataMap);
        }
    }

    /**
     * 获得缓存的Map
     *
     * @param key
     * @return
     */
    public &amp;lt;T&amp;gt; Map&amp;lt;String, T&amp;gt; getCacheMap(final String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * 往Hash中存入数据
     *
     * @param key   Redis键
     * @param hKey  Hash键
     * @param value 值
     */
    public &amp;lt;T&amp;gt; void setCacheMapValue(final String key, final String hKey, final T value) {
        redisTemplate.opsForHash().put(key, hKey, value);
    }

    /**
     * 获取Hash中的数据
     *
     * @param key  Redis键
     * @param hKey Hash键
     * @return Hash中的对象
     */
    public &amp;lt;T&amp;gt; T getCacheMapValue(final String key, final String hKey) {
        HashOperations&amp;lt;String, String, T&amp;gt; opsForHash = redisTemplate.opsForHash();
        return opsForHash.get(key, hKey);
    }

    /**
     * 删除Hash中的数据
     *
     * @param key
     * @param hKey
     */
    public void delCacheMapValue(final String key, final String hKey) {
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.delete(key, hKey);
    }

    /**
     * 获取多个Hash中的数据
     *
     * @param key   Redis键
     * @param hKeys Hash键集合
     * @return Hash对象集合
     */
    public &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; getMultiCacheMapValue(final String key, final Collection&amp;lt;Object&amp;gt; hKeys) {
        return redisTemplate.opsForHash().multiGet(key, hKeys);
    }

    /**
     * 获得缓存的基本对象列表
     *
     * @param pattern 字符串前缀
     * @return 对象列表
     */
    public Collection&amp;lt;String&amp;gt; keys(final String pattern) {
        return redisTemplate.keys(pattern);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;spring-security&#34;&gt;Spring Security&lt;/h2&gt;
&lt;h3 id=&#34;pom&#34;&gt;pom&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pom.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- Spring Security--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--redis依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--fastjson依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.83&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--jwt依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jjwt&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jwtutils&#34;&gt;JwtUtils&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JwtUtils.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * JWT工具类
 */
public class JwtUtils {

    //有效期为
    //public static final Long JWT_TTL = 60 * 60 * 1000L;// 60 * 60 * 1000  一个小时
    private static final Long JWT_TTL = 60 * 60 * 24000L;// 60 * 60 * 24000  二十四个小时

    //设置秘钥明文
    private static final char[] JWT_SECRET_KEY = &amp;quot;sangeng&amp;quot;.toCharArray();

    public static String getUUID() {
        String token = UUID.randomUUID().toString().replaceAll(&amp;quot;-&amp;quot;, &amp;quot;&amp;quot;);
        return token;
    }

    /**
     * 生成jtw
     *
     * @param subject token中要存放的数据（json格式）
     * @return
     */
    public static String createJWT(String subject) {
        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间
        return builder.compact();
    }

    /**
     * 生成jtw
     *
     * @param subject   token中要存放的数据（json格式）
     * @param ttlMillis token超时时间
     * @return
     */
    public static String createJWT(String subject, Long ttlMillis) {
        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间
        return builder.compact();
    }

    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;
        SecretKey secretKey = generalKey();
        long nowMillis = System.currentTimeMillis();
        Date now = new Date(nowMillis);
        if (ttlMillis == null) {
            ttlMillis = JwtUtils.JWT_TTL;
        }
        long expMillis = nowMillis + ttlMillis;
        Date expDate = new Date(expMillis);
        return Jwts.builder()
                .setId(uuid)              //唯一的ID
                .setSubject(subject)   // 主题  可以是JSON数据
                .setIssuer(&amp;quot;admin&amp;quot;)     // 签发者
                .setIssuedAt(now)      // 签发时间
                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥
                .setExpiration(expDate);
    }

    /**
     * 创建token
     *
     * @param id
     * @param subject
     * @param ttlMillis
     * @return
     */
    public static String createJWT(String id, String subject, Long ttlMillis) {
        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间
        return builder.compact();
    }

    /**
     * 生成加密后的秘钥 secretKey
     *
     * @return
     */
    public static SecretKey generalKey() {
        byte[] encodedKey = Base64.getDecoder().decode(new String(JWT_SECRET_KEY));
        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &amp;quot;AES&amp;quot;);
        return key;
    }

    /**
     * 解析
     *
     * @param jwt
     * @return
     * @throws Exception
     */
    public static Claims parseJWT(String jwt) throws Exception {
        SecretKey secretKey = generalKey();
        return Jwts.parser()
                .setSigningKey(secretKey)
                .parseClaimsJws(jwt)
                .getBody();
    }

    public static void main(String[] args) throws Exception {
        String token = JwtUtils.createJWT(&amp;quot;cook&amp;quot;);
        Claims claims = parseJWT(token);
        System.out.println(token);//eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI3YTI5ZTQ4OThjMmI0YjMwOTczNTc4YmZjMmQwMWE2NSIsInN1YiI6ImNvb2siLCJpc3MiOiJhZG1pbiIsImlhdCI6MTY2MTE4NzM5MywiZXhwIjoxNjYxMjczNzkzfQ.dUO663dn5SIndbPgwIedXmY2YazG4WqD4rYzgGrtHXM
        System.out.println(claims);//{jti=7a29e4898c2b4b30973578bfc2d01a65, sub=cook, iss=admin, iat=1661187393, exp=1661273793}
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fastjsonredisserializer&#34;&gt;FastJsonRedisSerializer&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FastJsonRedisSerializer.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Redis使用FastJson序列化
 */
public class FastJsonRedisSerializer&amp;lt;T&amp;gt; implements RedisSerializer&amp;lt;T&amp;gt; {

    public static final Charset DEFAULT_CHARSET = Charset.forName(&amp;quot;UTF-8&amp;quot;);

    private Class&amp;lt;T&amp;gt; clazz;

    static {
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
    }

    public FastJsonRedisSerializer(Class&amp;lt;T&amp;gt; clazz) {
        super();
        this.clazz = clazz;
    }

    @Override
    public byte[] serialize(T t) throws SerializationException {
        if (t == null) {
            return new byte[0];
        }
        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);
    }

    @Override
    public T deserialize(byte[] bytes) throws SerializationException {
        if (bytes == null || bytes.length &amp;lt;= 0) {
            return null;
        }
        String str = new String(bytes, DEFAULT_CHARSET);

        return JSON.parseObject(str, clazz);
    }
    
    protected JavaType getJavaType(Class&amp;lt;?&amp;gt; clazz) {
        return TypeFactory.defaultInstance().constructType(clazz);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;webutils-2&#34;&gt;WebUtils&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;WebUtils.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WebUtils {
    /**
     * 将字符串渲染到客户端
     *
     * @param response 渲染对象
     * @param string   待渲染的字符串
     * @return null
     */
    public static String renderString(HttpServletResponse response, String string) {
        try {
            response.setStatus(200);
            response.setContentType(&amp;quot;application/json&amp;quot;);
            response.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
            response.getWriter().print(string);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;redisconfig&#34;&gt;RedisConfig&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RedisConfig.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class RedisConfig {

    @Bean
    @SuppressWarnings(value = {&amp;quot;unchecked&amp;quot;, &amp;quot;rawtypes&amp;quot;})
    public RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&amp;lt;Object, Object&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
        template.setConnectionFactory(connectionFactory);

        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);

        // 使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(serializer);

        // Hash的key也采用StringRedisSerializer的序列化方式
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(serializer);

        template.afterPropertiesSet();

        // 开启AutoType，处理异常，com.alibaba.fastjson.JSONException: autoType is not support. org.springframework.security.core.authority.SimpleGrantedAuthority
        // 建议使用这种方式，小范围指定白名单
        ParserConfig.getGlobalInstance().addAccept(&amp;quot;org.springframework.security.core.authority.&amp;quot;);
        TypeUtils.addMapping(&amp;quot;org.springframework.security.core.authority.SimpleGrantedAuthority&amp;quot;,
                SimpleGrantedAuthority.class);

        return template;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;userdetailsbean&#34;&gt;UserDetailsBean&lt;/h3&gt;
&lt;p&gt;UserDetailsBean.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 登录用户 UserDetails
 */
public class UserDetailsBean implements UserDetails {

    /**
     * 封装用户信息
     */
    private User user;

    /**
     * 封装用户权限信息
     */
    private List&amp;lt;String&amp;gt; authorityList;

    private List&amp;lt;SimpleGrantedAuthority&amp;gt; authorities;

    @Override
    public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities() {
        // 写法一：
//        List&amp;lt;SimpleGrantedAuthority&amp;gt; authorities = authorities.stream().map(s -&amp;gt; new SimpleGrantedAuthority(s)).collect(Collectors.toList());
        // 写法二：
        authorities = authorityList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());
        // 写法三：
//        Collection&amp;lt;SimpleGrantedAuthority&amp;gt; authorities = null;
//        for (String s : authorities) {
//            authorities.add(new SimpleGrantedAuthority(s));
//        }
        return authorities;
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUserName();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return user.getStatus().equals(&amp;quot;0&amp;quot;);
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public List&amp;lt;String&amp;gt; getAuthorityList() {
        return authorityList;
    }

    public void setAuthorityList(List&amp;lt;String&amp;gt; authorityList) {
        this.authorityList = authorityList;
    }

    public void setAuthorities(List&amp;lt;SimpleGrantedAuthority&amp;gt; authorities) {
        this.authorities = authorities;
    }

    public UserDetailsBean() {
    }

    public UserDetailsBean(User user, List&amp;lt;String&amp;gt; authorityList) {
        this.user = user;
        this.authorityList = authorityList;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;userdetailsserviceimpl&#34;&gt;UserDetailsServiceImpl&lt;/h3&gt;
&lt;p&gt;UserDetailsServiceImpl.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserMapper userMapper;

    /**
     * 从数据库中查出用户信息，
     * 供 AuthenticationProvider 进行密码比对
     *
     * @param username 由 AuthenticationProvider 提供，也就是前端传入的username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1、根据用户名查询用户信息
        LambdaQueryWrapper&amp;lt;User&amp;gt; queryWrapper = new LambdaQueryWrapper&amp;lt;&amp;gt;();
        queryWrapper.eq(User::getUserName, username);
        User user = userMapper.selectOne(queryWrapper);
        // 2、如果查询不到数据就通过抛出异常来给出提示
        if (null == user) {
            throw new UsernameNotFoundException(&amp;quot;用户名或密码错误&amp;quot;);
        }
        // 3、根据用户名查询权限信息，将其添加到 UserDetailsBean 中的 authorities
        List&amp;lt;String&amp;gt; list = userMapper.selectPermsByUserId(user.getId());
        // 4、将查出的用户信息，权限信息，封装成UserDetails（UserDetailsBean）对象返回
        return new UserDetailsBean(user, list);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jwtauthenticationtokenfilter&#34;&gt;JwtAuthenticationTokenFilter&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JwtAuthenticationTokenFilter.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RequiredArgsConstructor
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    private final RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //获取token
        String token = request.getHeader(&amp;quot;token&amp;quot;);
        //判断token是否非空
        if (StringUtils.isEmpty(token)) {
            //为空，则直接放行，请求会去下一个登录接口
            filterChain.doFilter(request, response);
            return;
        }
        //不为空，则解析token获取userid
        String userId;
        try {
            Claims jwt = JwtUtils.parseJWT(token);
            userId = jwt.getSubject();
        } catch (Exception e) {
            //解析失败，提示token非法
            // 方法一：
            // 注意，此时需要自定义认证异常处理，否则只会响应403的空白错误；
            // 同时，我发现这里无论抛出哪个AuthenticationException的异常，无聊怎么传递消息，
            // 在自定义认证异常时，异常消息都会被覆盖成&amp;quot;Full authentication is required to access this resource&amp;quot;
            // 所以，这里还是采用第二种方法处理异常。
//            throw new AuthenticationServiceException(&amp;quot;Token非法&amp;quot;,new Throwable(&amp;quot;Token非法&amp;quot;));
            //方法二：
            request.getRequestDispatcher(&amp;quot;/jwtFilterException/&amp;quot; + &amp;quot;Token非法&amp;quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //解析成功，通过userid从Redis缓存中获取 UserDetailsBean
        UserDetailsBean userDetailsBean = redisCache.getCacheObject(&amp;quot;login:&amp;quot; + userId);
        //获取不了，提示会话失效，请重新登录
        if (null == userDetailsBean) {
            //解析失败，提示token非法
            request.getRequestDispatcher(&amp;quot;/jwtFilterException/&amp;quot; + &amp;quot;会话失效，请重新登录&amp;quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //获取的了，将 UserDetailsBean 封装成 authentication 对象，显式地为用户去注册身份认证
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetailsBean, null, userDetailsBean.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authentication);
        //放行
        filterChain.doFilter(request, response);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jwtfilterexceptioncontroller&#34;&gt;JwtFilterExceptionController&lt;/h3&gt;
&lt;p&gt;JwtFilterExceptionController.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class JwtFilterExceptionController {

    @RequestMapping(&amp;quot;/jwtFilterException/{message}&amp;quot;)
    public Result jwtFilterException(@PathVariable(&amp;quot;message&amp;quot;) String message) {
        return Result.error(message);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;accessdeniedhandlerimpl&#34;&gt;AccessDeniedHandlerImpl&lt;/h3&gt;
&lt;p&gt;AccessDeniedHandlerImpl.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class AccessDeniedHandlerImpl implements AccessDeniedHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        Result&amp;lt;Object&amp;gt; result = Result.error(HttpStatus.FORBIDDEN.value(), accessDeniedException.getMessage());
        String json = JSON.toJSONString(result);
        WebUtils.renderString(response, json);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;authenticationentrypointimpl&#34;&gt;AuthenticationEntryPointImpl&lt;/h3&gt;
&lt;p&gt;AuthenticationEntryPointImpl.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {
        Result&amp;lt;Object&amp;gt; result = Result.error(HttpStatus.UNAUTHORIZED.value(), e.getMessage());
        String json = JSON.toJSONString(result);
        WebUtils.renderString(response, json);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;securityconfig&#34;&gt;SecurityConfig&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SecurityConfig.java&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@RequiredArgsConstructor
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;

    private final AuthenticationEntryPoint authenticationEntryPoint;

    private final AccessDeniedHandler accessDeniedHandler;

    /**
     * 替换默认密码编码器
     * 使用BCryptPasswordEncoder
     *
     * @return
     */
    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                // 关闭csrf
                .csrf().disable()
                // 不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // 对于登录接口 允许匿名访问
                .authorizeRequests()
                .antMatchers(&amp;quot;/user/login&amp;quot;).anonymous()
                // 除上面外的所有请求全部需要鉴权认证
                .anyRequest().authenticated();

        // 把 JWT 过滤器添加到过滤器链中
        http
                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
        
        // 配置自定义的认证和授权异常处理类
        http
                .exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);
        // 允许跨域
        http.cors();
    }

    /**
     * 在容器中注入AuthenticationManager
     * 供登录接口的Service调用
     *
     * @return
     * @throws Exception
     */
    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;vue&#34;&gt;Vue&lt;/h1&gt;
">常用文件和代码模版</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/spring-security-bi-ji/"" data-c="
          &lt;h1 id=&#34;springsecurity从入门到精通&#34;&gt;SpringSecurity从入门到精通&lt;/h1&gt;
&lt;h2 id=&#34;0简介&#34;&gt;0.简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring Security&lt;/strong&gt; 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架&lt;strong&gt;Shiro&lt;/strong&gt;，它提供了更丰富的功能，社区资源也比Shiro丰富。&lt;/p&gt;
&lt;p&gt;一般来说中大型的项目都是使用&lt;strong&gt;SpringSecurity&lt;/strong&gt; 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。&lt;/p&gt;
&lt;p&gt;一般Web应用的需要进行&lt;strong&gt;认证&lt;/strong&gt;和&lt;strong&gt;授权&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;①&lt;strong&gt;认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;②&lt;strong&gt;授权：经过认证后判断当前用户是否有权限进行某个操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而认证和授权也是SpringSecurity作为安全框架的核心功能。&lt;/p&gt;
&lt;h2 id=&#34;1快速入门&#34;&gt;1.快速入门&lt;/h2&gt;
&lt;h3 id=&#34;11-准备工作&#34;&gt;1.1 准备工作&lt;/h3&gt;
&lt;p&gt;我们先要搭建一个简单的SpringBoot工程&lt;/p&gt;
&lt;h4 id=&#34;1-添加依赖&#34;&gt;① 添加依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.5.0&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-创建启动类&#34;&gt;② 创建启动类&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class SecurityApplication {

    public static void main(String[] args) {
        SpringApplication.run(SecurityApplication.class,args);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-创建controller&#34;&gt;③ 创建Controller&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @RequestMapping(&amp;quot;/hello&amp;quot;)
    public String hello(){
        return &amp;quot;hello&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-引入springsecurity&#34;&gt;1.2 引入SpringSecurity&lt;/h3&gt;
&lt;p&gt;在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须登陆之后才能对接口进行访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2认证&#34;&gt;2.认证&lt;/h2&gt;
&lt;h3 id=&#34;21-登陆校验流程&#34;&gt;2.1 登陆校验流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220817165509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;22-原理初探&#34;&gt;2.2 原理初探&lt;/h3&gt;
&lt;p&gt;想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。&lt;/p&gt;
&lt;h4 id=&#34;221-springsecurity完整流程&#34;&gt;2.2.1 SpringSecurity完整流程&lt;/h4&gt;
&lt;p&gt;SpringSecurity的原理其实就是一个&lt;strong&gt;过滤器链&lt;/strong&gt;，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220817165658.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UsernamePasswordAuthenticationFilter&lt;/strong&gt;:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**FilterSecurityInterceptor：**负责权限校验的过滤器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220817165723.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;222-认证流程详解&#34;&gt;2.2.2 认证流程详解&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220817165917.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;概念速查:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Authentication接口&lt;/strong&gt;: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AuthenticationManager接口&lt;/strong&gt;：定义了认证Authentication的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UserDetailsService接口&lt;/strong&gt;：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UserDetails接口&lt;/strong&gt;：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。&lt;/p&gt;
&lt;h3 id=&#34;23-解决问题&#34;&gt;2.3 解决问题&lt;/h3&gt;
&lt;h4 id=&#34;231-思路分析&#34;&gt;2.3.1 思路分析&lt;/h4&gt;
&lt;p&gt;登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;① 自定义 UserDetailsService 的实现类 UserDetailsServiceImpl

			在这个实现类中去查询数据库，来判断密码是否正确

② 自定义登录接口  

			调用 ProviderManager 的方法进行认证 如果认证通过生成jwt

			把用户信息存入redis中
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;校验：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;① 定义Jwt认证过滤器

			获取token

			解析token获取其中的userid

			从Redis中获取用户信息

			存入SecurityContextHolder
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;232-准备工作&#34;&gt;2.3.2 准备工作&lt;/h4&gt;
&lt;p&gt;① 添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--redis依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--fastjson依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;1.2.83&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--jwt依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jjwt&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;② 添加Redis相关配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.TypeFactory;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.SerializationException;
import com.alibaba.fastjson.parser.ParserConfig;
import org.springframework.util.Assert;
import java.nio.charset.Charset;

/**
 * Redis使用FastJson序列化
 * 
 * @author sg
 */
public class FastJsonRedisSerializer&amp;lt;T&amp;gt; implements RedisSerializer&amp;lt;T&amp;gt;
{

    public static final Charset DEFAULT_CHARSET = Charset.forName(&amp;quot;UTF-8&amp;quot;);

    private Class&amp;lt;T&amp;gt; clazz;

    static
    {
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
    }

    public FastJsonRedisSerializer(Class&amp;lt;T&amp;gt; clazz)
    {
        super();
        this.clazz = clazz;
    }

    @Override
    public byte[] serialize(T t) throws SerializationException
    {
        if (t == null)
        {
            return new byte[0];
        }
        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);
    }

    @Override
    public T deserialize(byte[] bytes) throws SerializationException
    {
        if (bytes == null || bytes.length &amp;lt;= 0)
        {
            return null;
        }
        String str = new String(bytes, DEFAULT_CHARSET);

        return JSON.parseObject(str, clazz);
    }


    protected JavaType getJavaType(Class&amp;lt;?&amp;gt; clazz)
    {
        return TypeFactory.defaultInstance().constructType(clazz);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class RedisConfig {

    @Bean
    @SuppressWarnings(value = {&amp;quot;unchecked&amp;quot;, &amp;quot;rawtypes&amp;quot;})
    public RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&amp;lt;Object, Object&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
        template.setConnectionFactory(connectionFactory);

        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);

        // 使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(serializer);

        // Hash的key也采用StringRedisSerializer的序列化方式
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(serializer);

        template.afterPropertiesSet();

        // 开启AutoType，处理异常，com.alibaba.fastjson.JSONException: autoType is not support. org.springframework.security.core.authority.SimpleGrantedAuthority
        // 建议使用这种方式，小范围指定白名单
        ParserConfig.getGlobalInstance().addAccept(&amp;quot;org.springframework.security.core.authority.&amp;quot;);
        TypeUtils.addMapping(&amp;quot;org.springframework.security.core.authority.SimpleGrantedAuthority&amp;quot;,
                SimpleGrantedAuthority.class);

        return template;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;③ 响应类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.fasterxml.jackson.annotation.JsonInclude;

/**
 * @Author 三更  B站： https://space.bilibili.com/663528522
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ResponseResult&amp;lt;T&amp;gt; {
    /**
     * 状态码
     */
    private Integer code;
    /**
     * 提示信息，如果有错误时，前端可以获取该字段进行提示
     */
    private String msg;
    /**
     * 查询到的结果数据，
     */
    private T data;

    public ResponseResult(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public ResponseResult(Integer code, T data) {
        this.code = code;
        this.data = data;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public ResponseResult(Integer code, String msg, T data) {
        this.code = code;
        this.msg = msg;
        this.data = data;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;④ JWT 工具类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * JWT工具类
 */
public class JwtUtils {

    //有效期为
    //public static final Long JWT_TTL = 60 * 60 * 1000L;// 60 * 60 * 1000  一个小时
    private static final Long JWT_TTL = 60 * 60 * 24000L;// 60 * 60 * 24000  二十四个小时

    //设置秘钥明文
    private static final char[] JWT_SECRET_KEY = &amp;quot;sangeng&amp;quot;.toCharArray();

    public static String getUUID() {
        String token = UUID.randomUUID().toString().replaceAll(&amp;quot;-&amp;quot;, &amp;quot;&amp;quot;);
        return token;
    }

    /**
     * 生成jtw
     *
     * @param subject token中要存放的数据（json格式）
     * @return
     */
    public static String createJWT(String subject) {
        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间
        return builder.compact();
    }

    /**
     * 生成jtw
     *
     * @param subject   token中要存放的数据（json格式）
     * @param ttlMillis token超时时间
     * @return
     */
    public static String createJWT(String subject, Long ttlMillis) {
        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间
        return builder.compact();
    }

    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;
        SecretKey secretKey = generalKey();
        long nowMillis = System.currentTimeMillis();
        Date now = new Date(nowMillis);
        if (ttlMillis == null) {
            ttlMillis = JwtUtils.JWT_TTL;
        }
        long expMillis = nowMillis + ttlMillis;
        Date expDate = new Date(expMillis);
        return Jwts.builder()
                .setId(uuid)              //唯一的ID
                .setSubject(subject)   // 主题  可以是JSON数据
                .setIssuer(&amp;quot;admin&amp;quot;)     // 签发者
                .setIssuedAt(now)      // 签发时间
                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥
                .setExpiration(expDate);
    }

    /**
     * 创建token
     *
     * @param id
     * @param subject
     * @param ttlMillis
     * @return
     */
    public static String createJWT(String id, String subject, Long ttlMillis) {
        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间
        return builder.compact();
    }

    /**
     * 生成加密后的秘钥 secretKey
     *
     * @return
     */
    public static SecretKey generalKey() {
        byte[] encodedKey = Base64.getDecoder().decode(new String(JWT_SECRET_KEY));
        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &amp;quot;AES&amp;quot;);
        return key;
    }

    /**
     * 解析
     *
     * @param jwt
     * @return
     * @throws Exception
     */
    public static Claims parseJWT(String jwt) throws Exception {
        SecretKey secretKey = generalKey();
        return Jwts.parser()
                .setSigningKey(secretKey)
                .parseClaimsJws(jwt)
                .getBody();
    }

    public static void main(String[] args) throws Exception {
        String token = JwtUtils.createJWT(&amp;quot;cook&amp;quot;);
        Claims claims = parseJWT(token);
        System.out.println(token);//eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI3YTI5ZTQ4OThjMmI0YjMwOTczNTc4YmZjMmQwMWE2NSIsInN1YiI6ImNvb2siLCJpc3MiOiJhZG1pbiIsImlhdCI6MTY2MTE4NzM5MywiZXhwIjoxNjYxMjczNzkzfQ.dUO663dn5SIndbPgwIedXmY2YazG4WqD4rYzgGrtHXM
        System.out.println(claims);//{jti=7a29e4898c2b4b30973578bfc2d01a65, sub=cook, iss=admin, iat=1661187393, exp=1661273793}
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
import java.util.concurrent.TimeUnit;

@SuppressWarnings(value = { &amp;quot;unchecked&amp;quot;, &amp;quot;rawtypes&amp;quot; })
@Component
public class RedisCache
{
    @Autowired
    public RedisTemplate redisTemplate;

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key 缓存的键值
     * @param value 缓存的值
     */
    public &amp;lt;T&amp;gt; void setCacheObject(final String key, final T value)
    {
        redisTemplate.opsForValue().set(key, value);
    }

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key 缓存的键值
     * @param value 缓存的值
     * @param timeout 时间
     * @param timeUnit 时间颗粒度
     */
    public &amp;lt;T&amp;gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)
    {
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    /**
     * 设置有效时间
     *
     * @param key Redis键
     * @param timeout 超时时间
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout)
    {
        return expire(key, timeout, TimeUnit.SECONDS);
    }

    /**
     * 设置有效时间
     *
     * @param key Redis键
     * @param timeout 超时时间
     * @param unit 时间单位
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout, final TimeUnit unit)
    {
        return redisTemplate.expire(key, timeout, unit);
    }

    /**
     * 获得缓存的基本对象。
     *
     * @param key 缓存键值
     * @return 缓存键值对应的数据
     */
    public &amp;lt;T&amp;gt; T getCacheObject(final String key)
    {
        ValueOperations&amp;lt;String, T&amp;gt; operation = redisTemplate.opsForValue();
        return operation.get(key);
    }

    /**
     * 删除单个对象
     *
     * @param key
     */
    public boolean deleteObject(final String key)
    {
        return redisTemplate.delete(key);
    }

    /**
     * 删除集合对象
     *
     * @param collection 多个对象
     * @return
     */
    public long deleteObject(final Collection collection)
    {
        return redisTemplate.delete(collection);
    }

    /**
     * 缓存List数据
     *
     * @param key 缓存的键值
     * @param dataList 待缓存的List数据
     * @return 缓存的对象
     */
    public &amp;lt;T&amp;gt; long setCacheList(final String key, final List&amp;lt;T&amp;gt; dataList)
    {
        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);
        return count == null ? 0 : count;
    }

    /**
     * 获得缓存的list对象
     *
     * @param key 缓存的键值
     * @return 缓存键值对应的数据
     */
    public &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; getCacheList(final String key)
    {
        return redisTemplate.opsForList().range(key, 0, -1);
    }

    /**
     * 缓存Set
     *
     * @param key 缓存键值
     * @param dataSet 缓存的数据
     * @return 缓存数据的对象
     */
    public &amp;lt;T&amp;gt; BoundSetOperations&amp;lt;String, T&amp;gt; setCacheSet(final String key, final Set&amp;lt;T&amp;gt; dataSet)
    {
        BoundSetOperations&amp;lt;String, T&amp;gt; setOperation = redisTemplate.boundSetOps(key);
        Iterator&amp;lt;T&amp;gt; it = dataSet.iterator();
        while (it.hasNext())
        {
            setOperation.add(it.next());
        }
        return setOperation;
    }

    /**
     * 获得缓存的set
     *
     * @param key
     * @return
     */
    public &amp;lt;T&amp;gt; Set&amp;lt;T&amp;gt; getCacheSet(final String key)
    {
        return redisTemplate.opsForSet().members(key);
    }

    /**
     * 缓存Map
     *
     * @param key
     * @param dataMap
     */
    public &amp;lt;T&amp;gt; void setCacheMap(final String key, final Map&amp;lt;String, T&amp;gt; dataMap)
    {
        if (dataMap != null) {
            redisTemplate.opsForHash().putAll(key, dataMap);
        }
    }

    /**
     * 获得缓存的Map
     *
     * @param key
     * @return
     */
    public &amp;lt;T&amp;gt; Map&amp;lt;String, T&amp;gt; getCacheMap(final String key)
    {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * 往Hash中存入数据
     *
     * @param key Redis键
     * @param hKey Hash键
     * @param value 值
     */
    public &amp;lt;T&amp;gt; void setCacheMapValue(final String key, final String hKey, final T value)
    {
        redisTemplate.opsForHash().put(key, hKey, value);
    }

    /**
     * 获取Hash中的数据
     *
     * @param key Redis键
     * @param hKey Hash键
     * @return Hash中的对象
     */
    public &amp;lt;T&amp;gt; T getCacheMapValue(final String key, final String hKey)
    {
        HashOperations&amp;lt;String, String, T&amp;gt; opsForHash = redisTemplate.opsForHash();
        return opsForHash.get(key, hKey);
    }

    /**
     * 删除Hash中的数据
     * 
     * @param key
     * @param hkey
     */
    public void delCacheMapValue(final String key, final String hkey)
    {
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.delete(key, hkey);
    }

    /**
     * 获取多个Hash中的数据
     *
     * @param key Redis键
     * @param hKeys Hash键集合
     * @return Hash对象集合
     */
    public &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; getMultiCacheMapValue(final String key, final Collection&amp;lt;Object&amp;gt; hKeys)
    {
        return redisTemplate.opsForHash().multiGet(key, hKeys);
    }

    /**
     * 获得缓存的基本对象列表
     *
     * @param pattern 字符串前缀
     * @return 对象列表
     */
    public Collection&amp;lt;String&amp;gt; keys(final String pattern)
    {
        return redisTemplate.keys(pattern);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class WebUtils
{
    /**
     * 将字符串渲染到客户端
     * 
     * @param response 渲染对象
     * @param string 待渲染的字符串
     * @return null
     */
    public static String renderString(HttpServletResponse response, String string) {
        try
        {
            response.setStatus(200);
            response.setContentType(&amp;quot;application/json&amp;quot;);
            response.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
            response.getWriter().print(string);
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;⑤实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.Serializable;
import java.util.Date;


/**
 * 用户表(User)实体类
 *
 * @author 三更
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User implements Serializable {
    private static final long serialVersionUID = -40356785423868312L;
    
    /**
    * 主键
    */
    private Long id;
    /**
    * 用户名
    */
    private String userName;
    /**
    * 昵称
    */
    private String nickName;
    /**
    * 密码
    */
    private String password;
    /**
    * 账号状态（0正常 1停用）
    */
    private String status;
    /**
    * 邮箱
    */
    private String email;
    /**
    * 手机号
    */
    private String phonenumber;
    /**
    * 用户性别（0男，1女，2未知）
    */
    private String sex;
    /**
    * 头像
    */
    private String avatar;
    /**
    * 用户类型（0管理员，1普通用户）
    */
    private String userType;
    /**
    * 创建人的用户id
    */
    private Long createBy;
    /**
    * 创建时间
    */
    private Date createTime;
    /**
    * 更新人
    */
    private Long updateBy;
    /**
    * 更新时间
    */
    private Date updateTime;
    /**
    * 删除标志（0代表未删除，1代表已删除）
    */
    private Integer delFlag;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;233-实现&#34;&gt;2.3.3 实现&lt;/h4&gt;
&lt;h5 id=&#34;2331-数据库校验用户&#34;&gt;2.3.3.1 数据库校验用户&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;从之前的分析我们可以知道，我们可以自定义一个UserDetailsServiceImpl,&lt;/li&gt;
&lt;li&gt;让SpringSecurity使用我们的UserDetailsServiceImpl。&lt;/li&gt;
&lt;li&gt;我们自己的UserDetailsServiceImpl可以从数据库中查询用户名和密码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;准备工作&#34;&gt;准备工作&lt;/h6&gt;
&lt;p&gt;我们先创建一个用户表， 建表语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;CREATE TABLE `sys_user` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
  `user_name` VARCHAR(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;用户名&#39;,
  `nick_name` VARCHAR(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;昵称&#39;,
  `password` VARCHAR(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;密码&#39;,
  `status` CHAR(1) DEFAULT &#39;0&#39; COMMENT &#39;账号状态（0正常 1停用）&#39;,
  `email` VARCHAR(64) DEFAULT NULL COMMENT &#39;邮箱&#39;,
  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT &#39;手机号&#39;,
  `sex` CHAR(1) DEFAULT NULL COMMENT &#39;用户性别（0男，1女，2未知）&#39;,
  `avatar` VARCHAR(128) DEFAULT NULL COMMENT &#39;头像&#39;,
  `user_type` CHAR(1) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;用户类型（0管理员，1普通用户）&#39;,
  `create_by` BIGINT(20) DEFAULT NULL COMMENT &#39;创建人的用户id&#39;,
  `create_time` DATETIME DEFAULT NULL COMMENT &#39;创建时间&#39;,
  `update_by` BIGINT(20) DEFAULT NULL COMMENT &#39;更新人&#39;,
  `update_time` DATETIME DEFAULT NULL COMMENT &#39;更新时间&#39;,
  `del_flag` INT(11) DEFAULT &#39;0&#39; COMMENT &#39;删除标志（0代表未删除，1代表已删除）&#39;,
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;用户表&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引入MybatisPuls和mysql驱动的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置数据库信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;spring:
  datasource:
    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;amp;serverTimezone=UTC
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义Mapper接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserMapper extends BaseMapper&amp;lt;User&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改User实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;类名上加@TableName(value = &amp;quot;sys_user&amp;quot;) ,delFlag字段上加 @TableLogic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置Mapper扫描&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@MapperScan(&amp;quot;com.sangeng.mapper&amp;quot;)
public class SimpleSecurityApplication {
    public static void main(String[] args) {
        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);
        System.out.println(run);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加junit依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试 MyBatis-Plus 是否能正常使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @Author 三更  B站： https://space.bilibili.com/663528522
 */
@SpringBootTest
public class MapperTest {

    @Autowired
    private UserMapper userMapper;

    @Test
    public void testUserMapper(){
        List&amp;lt;User&amp;gt; users = userMapper.selectList(null);
        System.out.println(users);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;核心代码实现&#34;&gt;核心代码实现&lt;/h6&gt;
&lt;h6 id=&#34;1-创建userdetailsservice的实现类&#34;&gt;① 创建UserDetailsService的实现类&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;重写其中的方法。来从数据库中查询用户信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1）UserDetailsServiceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserMapper userMapper;

    /**
     * 从数据库中查出用户信息，
     * 供 AuthenticationProvider 进行密码比对
     *
     * @param username 由 AuthenticationProvider 提供，也就是前端传入的username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1、根据用户名查询用户信息
        LambdaQueryWrapper&amp;lt;User&amp;gt; queryWrapper = new LambdaQueryWrapper&amp;lt;&amp;gt;();
        queryWrapper.eq(User::getUserName, username);
        User user = userMapper.selectOne(queryWrapper);
        // 2、如果查询不到数据就通过抛出异常来给出提示
        if (null == user) {
            throw new UsernameNotFoundException(&amp;quot;用户名或密码错误&amp;quot;);
        }
        //TODO 3、根据用户名查询权限信息，将其添加到 UserDetailsBean 中的 authorities

        // 4、将查出的用户信息，权限信息，封装成UserDetails（UserDetailsBean）对象返回
        return new UserDetailsBean(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）UserDetailsBean&lt;/p&gt;
&lt;p&gt;因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 登录用户 UserDetails
 */
public class UserDetailsBean implements UserDetails {

    /**
     * 封装用户信息
     */
    private User user;

    @Override
    public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities() {
        return null;
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUserName();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return user.getStatus().equals(&amp;quot;0&amp;quot;);
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public UserDetailsBean() {
    }

    public UserDetailsBean(User user) {
        this.user = user;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;2-配置密码编码器&#34;&gt;② 配置密码编码器&lt;/h6&gt;
&lt;p&gt;&lt;code&gt;AuthenticationProvider&lt;/code&gt;，在根据返回的UserDetails进行密码比对时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认使用的PasswordEncoder要求数据库中的密码格式为：{type}password 。它会根据 type 去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换默认的 PasswordEncoder。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们一般使用SpringSecurity推荐的的&lt;mark&gt;BCryptPasswordEncoder&lt;/mark&gt;，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以我们可以定义一个SpringSecurity的配置类，new 一个 BCryptPasswordEncoder，然后使用 @Bean 注解将其注入 Spring  容器，替换默认的密码编码器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SecurityConfig {

    /**
     * 替换默认密码编码器
     * 使用BCryptPasswordEncoder
     * @return
     */
    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder(){
        return new BCryptPasswordEncoder();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你想让用户的密码是&lt;code&gt;明文存储&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;则不需要替换默认的密码编码器，&lt;/p&gt;
&lt;p&gt;只需在密码前加&lt;code&gt;{noop}&lt;/code&gt;，这里的 noop 就是指定加密类型为明文&lt;/p&gt;
&lt;p&gt;&lt;code&gt;当然，在真的项目中谁会把密码明文存储呢？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220817203822.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;3-测试&#34;&gt;③ 测试&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;使用浏览器，通过默认的认证页面测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2333-自定义登陆接口&#34;&gt;2.3.3.3 自定义登陆接口&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接下我们需要&lt;mark&gt;自定义登陆接口&lt;/mark&gt;，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在接口中调用&lt;mark&gt;AuthenticationManager&lt;/mark&gt;的==authenticate()==方法来进行用户认证，所以还需要配置类中把AuthenticationManager注入容器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入Redis，可以把用户id作为key。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;1-创建登录接口的-controller&#34;&gt;① 创建登录接口的 Controller&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;LoginController&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class LoginController {

    @Autowired
    private LoginServcie loginServcie;

    @PostMapping(&amp;quot;/user/login&amp;quot;)
    public ResponseResult login(@RequestBody User user){
        return loginServcie.login(user);
    }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;2-给登录接口放行同时为-spring-容器注入-authenticationmanager&#34;&gt;② 给登录接口放行，同时为 Spring 容器注入 AuthenticationManager&lt;/h6&gt;
&lt;p&gt;&lt;mark&gt;注意&lt;/mark&gt; ：此时配置类要继承WebSecurityConfigurerAdapter&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                // 关闭csrf
                .csrf().disable()
                // 不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // 对于登录接口 允许匿名访问
                .authorizeRequests()
                .antMatchers(&amp;quot;/user/login&amp;quot;).anonymous()
                // 除上面外的所有请求全部需要鉴权认证
                .anyRequest().authenticated();
    }

    /**
     * 在容器中注入AuthenticationManager
     * 供登录接口的Service调用
     *
     * @return
     * @throws Exception
     */
    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;3-创建登录接口的-service&#34;&gt;③ 创建登录接口的 Service&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;LoginService&lt;/li&gt;
&lt;li&gt;LoginServiceImpl&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface LoginServcie {
  
    Result login(User user);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@RequiredArgsConstructor
public class LoginServcieImpl implements LoginServcie {

    private final AuthenticationManager authenticationManager;

    private final RedisCache redisCache;

    @Override
    public Result login(User user) {
        //非空判断
        if (null == user || null == user.getUserName() || null == user.getPassword()) {
            return Result.error(&amp;quot;用户名或密码不能为空&amp;quot;);
        }
        //调用AuthenticationManager的authenticate()方法，判断密码对不对
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword());
        Authentication authenticate = null;
        try {
            authenticate = authenticationManager.authenticate(authentication);
        } catch (BadCredentialsException e) {
            return Result.error(&amp;quot;用户名或密码错误&amp;quot;);
        } catch (LockedException e) {
            return Result.error(&amp;quot;账号被锁定，请联系管理员&amp;quot;);
        }
        //若密码正确，则用 userid 生成token
        UserDetailsBean userDetailsBean = (UserDetailsBean) authenticate.getPrincipal();
        String userId = userDetailsBean.getUser().getId().toString();
        String token = JwtUtils.createJWT(userId);
        //将用户信息 UserDetails 放入 Redis 缓存中，用户id作为key
        redisCache.setCacheObject(&amp;quot;login:&amp;quot; + userId, userDetailsBean);
        //返回token给前端
        HashMap&amp;lt;String, String&amp;gt; tokenMap = new HashMap&amp;lt;&amp;gt;();
        tokenMap.put(&amp;quot;token&amp;quot;, token);
        return Result.OK(&amp;quot;登录成功&amp;quot;, tokenMap);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;4-测试登录接口&#34;&gt;④ 测试登录接口&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;使用Postan测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2334-认证过滤器&#34;&gt;2.3.3.4 认证过滤器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户登录成功后，对其他所有接口的请求都会携带相应的 token ，后续操作都是通过 token 鉴权&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以，我们需要自定义一个 JWT 过滤器，如果 token 有效，则&lt;mark&gt;显式&lt;/mark&gt;地为用户去&lt;mark&gt;注册身份认证&lt;/mark&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;mark&gt;SecurityContextHolder.getContext().setAuthentication(anAuthentication);&lt;/mark&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个过滤器具体流程为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取请求头中的token，对token进行解析取出其中的userid。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用userid去redis中获取对应的UserDetailsBean对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后封装成 authentication 对象存入 SecurityContextHolder 显式注册身份认证&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;1-创建-jwt-过滤器&#34;&gt;① 创建 JWT 过滤器&lt;/h6&gt;
&lt;p&gt;1）JwtAuthenticationTokenFilter&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RequiredArgsConstructor
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    private final RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //获取token
        String token = request.getHeader(&amp;quot;token&amp;quot;);
        //判断token是否非空
        if (StringUtils.isEmpty(token)) {
            //为空，则直接放行，请求会去下一个登录接口
            filterChain.doFilter(request, response);
            return;
        }
        //不为空，则解析token获取userid
        String userId;
        try {
            Claims jwt = JwtUtils.parseJWT(token);
            userId = jwt.getSubject();
        } catch (Exception e) {
            //解析失败，提示token非法
            // 方法一：
            // 注意，此时需要自定义认证异常处理，否则只会响应403的空白错误；
            // 同时，我发现这里无论抛出哪个AuthenticationException的异常，无聊怎么传递消息，
            // 在自定义认证异常时，异常消息都会被覆盖成&amp;quot;Full authentication is required to access this resource&amp;quot;
            // 所以，这里还是采用第二种方法处理异常。
//            throw new AuthenticationServiceException(&amp;quot;Token非法&amp;quot;,new Throwable(&amp;quot;Token非法&amp;quot;));
            //方法二：
            request.getRequestDispatcher(&amp;quot;/jwtFilterException/&amp;quot; + &amp;quot;Token非法&amp;quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //解析成功，通过userid从Redis缓存中获取 UserDetailsBean
        UserDetailsBean userDetailsBean = redisCache.getCacheObject(&amp;quot;login:&amp;quot; + userId);
        //获取不了，提示会话失效，请重新登录
        if (null == userDetailsBean) {
            //解析失败，提示token非法
            request.getRequestDispatcher(&amp;quot;/jwtFilterException/&amp;quot; + &amp;quot;会话失效，请重新登录&amp;quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //获取的了，将 UserDetailsBean 封装成 authentication 对象，显式地为用户去注册身份认证
        // TODO: 将权限信息封装进 authentication 对象
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetailsBean, null, userDetailsBean.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authentication);
        //放行
        filterChain.doFilter(request, response);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）JwtFilterExceptionController&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class JwtFilterExceptionController {

    @RequestMapping(&amp;quot;/jwtFilterException/{message}&amp;quot;)
    public Result jwtFilterException(@PathVariable(&amp;quot;message&amp;quot;) String message) {
        return Result.error(message);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;2-注册过滤器&#34;&gt;② 注册过滤器&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@RequiredArgsConstructor
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;

    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                // 关闭csrf
                .csrf().disable()
                // 不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // 对于登录接口 允许匿名访问
                .authorizeRequests()
                .antMatchers(&amp;quot;/user/login&amp;quot;).anonymous()
                // 除上面外的所有请求全部需要鉴权认证
                .anyRequest().authenticated();

        // 把 JWT 过滤器添加到过滤器链中
        http
                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
    }

    /**
     * 在容器中注入AuthenticationManager
     * 供登录接口的Service调用
     *
     * @return
     * @throws Exception
     */
    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;3-测试-2&#34;&gt;③ 测试&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;使用Postman测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2335-退出登录&#34;&gt;2.3.3.5 退出登录&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;我们只需要定义一个退出登录接口&lt;/li&gt;
&lt;li&gt;通过 SecurityContextHolder 获取当前用户的认证信息，&lt;/li&gt;
&lt;li&gt;然后通过认证信息获取 userid&lt;/li&gt;
&lt;li&gt;再通过 userid 删除redis中对应的数据即可&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public Result logout() {
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
    UserDetailsBean userDetailsBean = (UserDetailsBean) authentication.getPrincipal();
    Long userId = userDetailsBean.getUser().getId();
    redisCache.deleteObject(&amp;quot;login:&amp;quot; + userId);
    return Result.OK(&amp;quot;退出登录成功&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3授权&#34;&gt;3.授权&lt;/h2&gt;
&lt;h3 id=&#34;30-权限系统的作用&#34;&gt;3.0 权限系统的作用&lt;/h3&gt;
&lt;p&gt;例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。&lt;/p&gt;
&lt;p&gt;总结起来就是&lt;strong&gt;不同的用户可以使用不同的功能&lt;/strong&gt;。这就是权限系统要去实现的效果。&lt;/p&gt;
&lt;p&gt;我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。&lt;/p&gt;
&lt;p&gt;所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。&lt;/p&gt;
&lt;h3 id=&#34;31-授权基本流程&#34;&gt;3.1 授权基本流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在FilterSecurityInterceptor中会从SecurityContextHolder获取当前用户的Authentication，然后获取其中的权限信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后判断当前用户的权限信息是否与接口设置的所需权限匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匹配则放行，否则拦截。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后设置我们的接口等资源所需要的权限即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-授权实现&#34;&gt;3.2 授权实现&lt;/h3&gt;
&lt;h4 id=&#34;321-基于注解设置访问资源的权限&#34;&gt;3.2.1 基于注解设置访问资源的权限&lt;/h4&gt;
&lt;h5 id=&#34;1-开启基于注解的配置&#34;&gt;① 开启基于注解的配置&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EnableGlobalMethodSecurity(prePostEnabled = true)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-使用-preauthorize-设置权限&#34;&gt;② 使用 @PreAuthorize 设置权限&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class HelloController {

    @PreAuthorize(&amp;quot;hasAuthority(&#39;ROLE_TEST&#39;)&amp;quot;)
    @RequestMapping(&amp;quot;/hello&amp;quot;)
    public String hello(){
        return &amp;quot;hello&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3-测试-3&#34;&gt;③ 测试&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;我们可以先用 Postman 进行简单的测试&lt;/li&gt;
&lt;li&gt;结果当然是 403 无权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;322-封装权限信息&#34;&gt;3.2.2 封装权限信息&lt;/h4&gt;
&lt;h5 id=&#34;1-修改userdetailsbean&#34;&gt;① 修改UserDetailsBean&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 登录用户 UserDetails
 */
public class UserDetailsBean implements UserDetails {

    /**
     * 封装用户信息
     */
    private User user;

    /**
     * 封装用户权限信息
     */
    private List&amp;lt;String&amp;gt; authorityList;
    
    private List&amp;lt;SimpleGrantedAuthority&amp;gt; authorities;

    @Override
    public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities() {
        // 写法一：
//        List&amp;lt;SimpleGrantedAuthority&amp;gt; authorities = authorities.stream().map(s -&amp;gt; new SimpleGrantedAuthority(s)).collect(Collectors.toList());
        // 写法二：
        authorities = authorityList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());
        // 写法三：
//        Collection&amp;lt;SimpleGrantedAuthority&amp;gt; authorities = null;
//        for (String s : authorities) {
//            authorities.add(new SimpleGrantedAuthority(s));
//        }
        return authorities;
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUserName();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return user.getStatus().equals(&amp;quot;0&amp;quot;);
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public List&amp;lt;String&amp;gt; getAuthorityList() {
        return authorityList;
    }

    public void setAuthorityList(List&amp;lt;String&amp;gt; authorityList) {
        this.authorityList = authorityList;
    }

    public void setAuthorities(List&amp;lt;SimpleGrantedAuthority&amp;gt; authorities) {
        this.authorities = authorities;
    }

    public UserDetailsBean() {
    }

    public UserDetailsBean(User user, List&amp;lt;String&amp;gt; authorityList) {
        this.user = user;
        this.authorityList = authorityList;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-修改userdetailsserviceimpl&#34;&gt;② 修改UserDetailsServiceImpl&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserMapper userMapper;

    /**
     * 从数据库中查出用户信息，
     * 供 AuthenticationProvider 进行密码比对
     *
     * @param username 由 AuthenticationProvider 提供，也就是前端传入的username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1、根据用户名查询用户信息
        LambdaQueryWrapper&amp;lt;User&amp;gt; queryWrapper = new LambdaQueryWrapper&amp;lt;&amp;gt;();
        queryWrapper.eq(User::getUserName, username);
        User user = userMapper.selectOne(queryWrapper);
        // 2、如果查询不到数据就通过抛出异常来给出提示
        if (null == user) {
            throw new UsernameNotFoundException(&amp;quot;用户名或密码错误&amp;quot;);
        }
        //TODO 3、根据用户名查询权限信息，将其添加到 UserDetailsBean 中的 authorities
        List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;quot;ROLE_USER&amp;quot;, &amp;quot;ROLE_ADMIN&amp;quot;);
        // 4、将查出的用户信息，权限信息，封装成UserDetails（UserDetailsBean）对象返回
        return new UserDetailsBean(user,list);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3-修改jwtauthenticationtokenfilter&#34;&gt;③ 修改JwtAuthenticationTokenFilter&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;TODO&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RequiredArgsConstructor
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    private final RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //获取token
        String token = request.getHeader(&amp;quot;token&amp;quot;);
        //判断token是否非空
        if (StringUtils.isEmpty(token)) {
            //为空，则直接放行，请求会去下一个登录接口
            filterChain.doFilter(request, response);
            return;
        }
        //不为空，则解析token获取userid
        String userId;
        try {
            Claims jwt = JwtUtils.parseJWT(token);
            userId = jwt.getSubject();
        } catch (Exception e) {
            //解析失败，提示token非法
            request.getRequestDispatcher(&amp;quot;/jwtFilterException/&amp;quot; + &amp;quot;Token非法&amp;quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //解析成功，通过userid从Redis缓存中获取 UserDetailsBean
        UserDetailsBean userDetailsBean = redisCache.getCacheObject(&amp;quot;login:&amp;quot; + userId);
        //获取不了，提示会话失效，请重新登录
        if (null == userDetailsBean) {
            //解析失败，提示token非法
            request.getRequestDispatcher(&amp;quot;/jwtFilterException/&amp;quot; + &amp;quot;会话失效，请重新登录&amp;quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //获取的了，将 UserDetailsBean 封装成 authentication 对象，显式地为用户去注册身份认证
        // TODO: 将权限信息封装进 authentication 对象
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetailsBean, null, userDetailsBean.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authentication);
        //放行
        filterChain.doFilter(request, response);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;4-测试&#34;&gt;④ 测试&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;使用 Postman 进行测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;323-从数据库查询权限信息&#34;&gt;3.2.3 从数据库查询权限信息&lt;/h4&gt;
&lt;h5 id=&#34;3231-rbac权限模型&#34;&gt;3.2.3.1 RBAC权限模型&lt;/h5&gt;
&lt;p&gt;RBAC权限模型（Role-Based Access Control）&lt;/p&gt;
&lt;p&gt;即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220818201512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;3232-准备工作&#34;&gt;3.2.3.2 准备工作&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;

USE `sg_security`;

/*Table structure for table `sys_menu` */

DROP TABLE IF EXISTS `sys_menu`;

CREATE TABLE `sys_menu` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `menu_name` varchar(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;菜单名&#39;,
  `path` varchar(200) DEFAULT NULL COMMENT &#39;路由地址&#39;,
  `component` varchar(255) DEFAULT NULL COMMENT &#39;组件路径&#39;,
  `visible` char(1) DEFAULT &#39;0&#39; COMMENT &#39;菜单状态（0显示 1隐藏）&#39;,
  `status` char(1) DEFAULT &#39;0&#39; COMMENT &#39;菜单状态（0正常 1停用）&#39;,
  `perms` varchar(100) DEFAULT NULL COMMENT &#39;权限标识&#39;,
  `icon` varchar(100) DEFAULT &#39;#&#39; COMMENT &#39;菜单图标&#39;,
  `create_by` bigint(20) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint(20) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int(11) DEFAULT &#39;0&#39; COMMENT &#39;是否删除（0未删除 1已删除）&#39;,
  `remark` varchar(500) DEFAULT NULL COMMENT &#39;备注&#39;,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;菜单表&#39;;

/*Table structure for table `sys_role` */

DROP TABLE IF EXISTS `sys_role`;

CREATE TABLE `sys_role` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) DEFAULT NULL,
  `role_key` varchar(100) DEFAULT NULL COMMENT &#39;角色权限字符串&#39;,
  `status` char(1) DEFAULT &#39;0&#39; COMMENT &#39;角色状态（0正常 1停用）&#39;,
  `del_flag` int(1) DEFAULT &#39;0&#39; COMMENT &#39;del_flag&#39;,
  `create_by` bigint(200) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint(200) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `remark` varchar(500) DEFAULT NULL COMMENT &#39;备注&#39;,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;角色表&#39;;

/*Table structure for table `sys_role_menu` */

DROP TABLE IF EXISTS `sys_role_menu`;

CREATE TABLE `sys_role_menu` (
  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#39;角色ID&#39;,
  `menu_id` bigint(200) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;菜单id&#39;,
  PRIMARY KEY (`role_id`,`menu_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;

/*Table structure for table `sys_user` */

DROP TABLE IF EXISTS `sys_user`;

CREATE TABLE `sys_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
  `user_name` varchar(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;用户名&#39;,
  `nick_name` varchar(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;昵称&#39;,
  `password` varchar(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;密码&#39;,
  `status` char(1) DEFAULT &#39;0&#39; COMMENT &#39;账号状态（0正常 1停用）&#39;,
  `email` varchar(64) DEFAULT NULL COMMENT &#39;邮箱&#39;,
  `phonenumber` varchar(32) DEFAULT NULL COMMENT &#39;手机号&#39;,
  `sex` char(1) DEFAULT NULL COMMENT &#39;用户性别（0男，1女，2未知）&#39;,
  `avatar` varchar(128) DEFAULT NULL COMMENT &#39;头像&#39;,
  `user_type` char(1) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;用户类型（0管理员，1普通用户）&#39;,
  `create_by` bigint(20) DEFAULT NULL COMMENT &#39;创建人的用户id&#39;,
  `create_time` datetime DEFAULT NULL COMMENT &#39;创建时间&#39;,
  `update_by` bigint(20) DEFAULT NULL COMMENT &#39;更新人&#39;,
  `update_time` datetime DEFAULT NULL COMMENT &#39;更新时间&#39;,
  `del_flag` int(11) DEFAULT &#39;0&#39; COMMENT &#39;删除标志（0代表未删除，1代表已删除）&#39;,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;用户表&#39;;

/*Table structure for table `sys_user_role` */

DROP TABLE IF EXISTS `sys_user_role`;

CREATE TABLE `sys_user_role` (
  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#39;用户id&#39;,
  `role_id` bigint(200) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;角色id&#39;,
  PRIMARY KEY (`user_id`,`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;SELECT 
	DISTINCT m.`perms`
FROM
	sys_user_role ur
	LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`
	LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`
	LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`
WHERE
	user_id = 2
	AND r.`status` = 0
	AND m.`status` = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.sangeng.domain;

import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.Date;

/**
 * 菜单表(Menu)实体类
 *
 * @author makejava
 * @since 2021-11-24 15:30:08
 */
@TableName(value=&amp;quot;sys_menu&amp;quot;)
@Data
@AllArgsConstructor
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class Menu implements Serializable {
    private static final long serialVersionUID = -54979041104113736L;
    
    private Long id;
    /**
    * 菜单名
    */
    private String menuName;
    /**
    * 路由地址
    */
    private String path;
    /**
    * 组件路径
    */
    private String component;
    /**
    * 菜单状态（0显示 1隐藏）
    */
    private String visible;
    /**
    * 菜单状态（0正常 1停用）
    */
    private String status;
    /**
    * 权限标识
    */
    private String perms;
    /**
    * 菜单图标
    */
    private String icon;
    
    private Long createBy;
    
    private Date createTime;
    
    private Long updateBy;
    
    private Date updateTime;
    /**
    * 是否删除（0未删除 1已删除）
    */
    @TableLogic
    private Integer delFlag;
    /**
    * 备注
    */
    private String remark;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3233-代码实现&#34;&gt;3.2.3.3 代码实现&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;我们只需要根据用户 id 去查询到其所对应的权限信息即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以我们可以先定义个 mapper ，其中提供一个方法可以根据 userid 查询权限信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.sangeng.domain.Menu;

import java.util.List;

/**
 * @Author 三更  B站： https://space.bilibili.com/663528522
 */
public interface MenuMapper extends BaseMapper&amp;lt;Menu&amp;gt; {
    List&amp;lt;String&amp;gt; selectPermsByUserId(@Param(&amp;quot;id&amp;quot;) Long id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;多表联查，所以需要创建对应的 mapper 映射文件，定义对应的sql语句&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot; &amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.sangeng.mapper.MenuMapper&amp;quot;&amp;gt;

    &amp;lt;select id=&amp;quot;selectPermsByUserId&amp;quot; resultType=&amp;quot;java.lang.String&amp;quot;&amp;gt;
        SELECT
            DISTINCT m.`perms`
        FROM
            sys_user_role ur
            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`
            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`
            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`
        WHERE
            user_id = #{id}
            AND r.`status` = 0
            AND m.`status` = 0
    &amp;lt;/select&amp;gt;
  
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在 application.yml 中配置 mapper 映射文件的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spring:
  datasource:
    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;amp;serverTimezone=UTC
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
  redis:
    host: localhost
    port: 6379
mybatis-plus:
  mapper-locations: classpath*:/mapper/**/*.xml 

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;然后我们可以在 UserDetailsServiceImpl 中去调用该 mapper 的方法&lt;/li&gt;
&lt;li&gt;将查询的权限信息封装到 UserDetailsBean 对象中即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserMapper userMapper;

    /**
     * 从数据库中查出用户信息，
     * 供 AuthenticationProvider 进行密码比对
     *
     * @param username 由 AuthenticationProvider 提供，也就是前端传入的username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1、根据用户名查询用户信息
        LambdaQueryWrapper&amp;lt;User&amp;gt; queryWrapper = new LambdaQueryWrapper&amp;lt;&amp;gt;();
        queryWrapper.eq(User::getUserName, username);
        User user = userMapper.selectOne(queryWrapper);
        // 2、如果查询不到数据就通过抛出异常来给出提示
        if (null == user) {
            throw new UsernameNotFoundException(&amp;quot;用户名或密码错误&amp;quot;);
        }
        // 3、根据用户名查询权限信息，将其添加到 UserDetailsBean 中的 authorities
        List&amp;lt;String&amp;gt; list = userMapper.selectPermsByUserId(user.getId());
        // 4、将查出的用户信息，权限信息，封装成UserDetails（UserDetailsBean）对象返回
        return new UserDetailsBean(user,list);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-自定义失败处理&#34;&gt;4、自定义失败处理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在SpringSecurity中，如果我们在&lt;mark&gt;认证&lt;/mark&gt;或者&lt;mark&gt;授权&lt;/mark&gt;的过程中出现了&lt;mark&gt;异常&lt;/mark&gt;会被&lt;mark&gt;ExceptionTranslationFilter&lt;/mark&gt;捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是&lt;mark&gt;认证&lt;/mark&gt;过程中出现的异常会被封装成AuthenticationException然后调用&lt;mark&gt;AuthenticationEntryPoint&lt;/mark&gt;对象的方法去进行异常处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是&lt;mark&gt;授权&lt;/mark&gt;过程中出现的异常会被封装成AccessDeniedException然后调用&lt;mark&gt;AccessDeniedHandler&lt;/mark&gt;对象的方法去进行异常处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-自定义实现类&#34;&gt;① 自定义实现类&lt;/h3&gt;
&lt;p&gt;1）自定义授权异常处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class AccessDeniedHandlerImpl implements AccessDeniedHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        Result&amp;lt;Object&amp;gt; result = Result.error(HttpStatus.FORBIDDEN.value(), accessDeniedException.getMessage());
        String json = JSON.toJSONString(result);
        WebUtils.renderString(response,json);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2）自定义认证异常处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @Author 三更  B站： https://space.bilibili.com/663528522
 */
@Component
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &amp;quot;认证失败请重新登录&amp;quot;);
        String json = JSON.toJSONString(result);
        WebUtils.renderString(response,json);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-配置给-springsecurity&#34;&gt;② 配置给 SpringSecurity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先注入对应的处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired
private AuthenticationEntryPoint authenticationEntryPoint;

@Autowired
private AccessDeniedHandler accessDeniedHandler;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;然后我们可以使用HttpSecurity对象的方法去配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 配置自定义的认证和授权异常处理类
http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).
        accessDeniedHandler(accessDeniedHandler);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-跨域&#34;&gt;5、跨域&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同源策略要求源相同才能正常进行通信，即&lt;mark&gt;协议&lt;/mark&gt;、&lt;mark&gt;域名&lt;/mark&gt;、&lt;mark&gt;端口号&lt;/mark&gt;都完全一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以我们就要处理一下，让前端能进行跨域请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-首先开启-springmvc-的跨域访问&#34;&gt;① 首先开启 SpringMVC 的跨域访问&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration(proxyBeanMethods = false)
public class MvcConfiguration {

    /**
     * 处理CORS
     *
     * @return
     */
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping(&amp;quot;/**&amp;quot;)
                        .allowedOriginPatterns(&amp;quot;http://localhost:*&amp;quot;)
                        .allowedMethods(&amp;quot;GET&amp;quot;, &amp;quot;POST&amp;quot;, &amp;quot;PUT&amp;quot;, &amp;quot;DELETE&amp;quot;)
                        .allowCredentials(true)//设置是否允许客户端跨域携带验证数据，如Cookie值
                        .maxAge(3600);
            }
        };
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
      // 设置允许跨域的路径
        registry.addMapping(&amp;quot;/**&amp;quot;)
                // 设置允许跨域请求的域名
                .allowedOriginPatterns(&amp;quot;*&amp;quot;)
                // 是否允许cookie
                .allowCredentials(true)
                // 设置允许的请求方式
                .allowedMethods(&amp;quot;GET&amp;quot;, &amp;quot;POST&amp;quot;, &amp;quot;DELETE&amp;quot;, &amp;quot;PUT&amp;quot;)
                // 设置允许的header属性
                .allowedHeaders(&amp;quot;*&amp;quot;)
                // 跨域允许时间
                .maxAge(3600);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-开启-springsecurity-的跨域访问&#34;&gt;② 开启 SpringSecurity 的跨域访问&lt;/h3&gt;
&lt;p&gt;由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 允许跨域
http.cors();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-遗留小问题&#34;&gt;6、遗留小问题&lt;/h2&gt;
&lt;h3 id=&#34;61-其它权限校验方法&#34;&gt;6.1 其它权限校验方法&lt;/h3&gt;
&lt;p&gt;我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。&lt;/p&gt;
&lt;p&gt;hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。&lt;/p&gt;
&lt;p&gt;它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark&gt;hasAnyAuthority&lt;/mark&gt;方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @PreAuthorize(&amp;quot;hasAnyAuthority(&#39;admin&#39;,&#39;test&#39;,&#39;system:dept:list&#39;)&amp;quot;)
    public String hello(){
        return &amp;quot;hello&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark&gt;hasRole&lt;/mark&gt;要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 &lt;mark&gt;ROLE_&lt;/mark&gt; 后再去比较。所以这种情况下要用用户对应的权限也要有&lt;strong&gt;ROLE_&lt;/strong&gt; 这个前缀才可以。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @PreAuthorize(&amp;quot;hasRole(&#39;system:dept:list&#39;)&amp;quot;)
    public String hello(){
        return &amp;quot;hello&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark&gt;hasAnyRole&lt;/mark&gt; 有&lt;mark&gt;Any&lt;/mark&gt;任意的角色就可以访问。它内部也会把我们传入的参数拼接上&lt;mark&gt;ROLE_&lt;/mark&gt; 后再去比较。所以这种情况下要用用户对应的权限也要有 &lt;strong&gt;ROLE_&lt;/strong&gt; 这个前缀才可以。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @PreAuthorize(&amp;quot;hasAnyRole(&#39;admin&#39;,&#39;system:dept:list&#39;)&amp;quot;)
    public String hello(){
        return &amp;quot;hello&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;62-自定义权限校验方法&#34;&gt;6.2 自定义权限校验方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们也可以定义自己的权限校验方法，在 @PreAuthorize 注解中使用我们的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component(&amp;quot;ex&amp;quot;)
public class SGExpressionRoot {

    public boolean hasAuthority(String authority){
        //获取当前用户的权限
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        List&amp;lt;String&amp;gt; authorities = loginUser.getAuthorities();
        //判断用户权限集合中是否存在authority
        return authorities.contains(authority);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在 SPEL 表达式中，使用 @ex 相当于获取容器中 bean 的名字未ex的对象。然后再调用这个对象的 hasAuthority 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/hello&amp;quot;)
@PreAuthorize(&amp;quot;@ex.hasAuthority(&#39;system:dept:list&#39;)&amp;quot;)
public String hello(){
    return &amp;quot;hello&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;63-基于配置的权限控制&#34;&gt;6.3 基于配置的权限控制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们也可以在配置类中使用使用配置的方式对资源进行权限控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void configure(HttpSecurity http) throws Exception {
    http
            //关闭csrf
            .csrf().disable()
            //不通过Session获取SecurityContext
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeRequests()
            // 对于登录接口 允许匿名访问
            .antMatchers(&amp;quot;/user/login&amp;quot;).anonymous()
            .antMatchers(&amp;quot;/testCors&amp;quot;).hasAuthority(&amp;quot;system:dept:list222&amp;quot;)
            // 除上面外的所有请求全部需要鉴权认证
            .anyRequest().authenticated();

    //添加过滤器
    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);

    //配置异常处理器
    http.exceptionHandling()
            //配置认证失败处理器
            .authenticationEntryPoint(authenticationEntryPoint)
            .accessDeniedHandler(accessDeniedHandler);

    //允许跨域
    http.cors();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;64-csrf&#34;&gt;6.4 CSRF&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。

https://blog.csdn.net/freeking101/article/details/86537087

SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。

我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;65-认证成功处理器&#34;&gt;6.5 认证成功处理器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们也可以自己去自定义成功处理器进行成功后的相应处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class SGSuccessHandler implements AuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        System.out.println(&amp;quot;认证成功了&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private AuthenticationSuccessHandler successHandler;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin().successHandler(successHandler);

        http.authorizeRequests().anyRequest().authenticated();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;66-认证失败处理器&#34;&gt;6.6 认证失败处理器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们也可以自己去自定义失败处理器进行失败后的相应处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class SGFailureHandler implements AuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
        System.out.println(&amp;quot;认证失败了&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private AuthenticationSuccessHandler successHandler;

    @Autowired
    private AuthenticationFailureHandler failureHandler;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin()
                //配置认证成功处理器
                .successHandler(successHandler)
                //配置认证失败处理器
                .failureHandler(failureHandler);

        http.authorizeRequests().anyRequest().authenticated();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;67-登出成功处理器&#34;&gt;6.7 登出成功处理器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class SGLogoutSuccessHandler implements LogoutSuccessHandler {
    @Override
    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        System.out.println(&amp;quot;注销成功&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private AuthenticationSuccessHandler successHandler;

    @Autowired
    private AuthenticationFailureHandler failureHandler;

    @Autowired
    private LogoutSuccessHandler logoutSuccessHandler;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin()
                //配置认证成功处理器
                .successHandler(successHandler)
                //配置认证失败处理器
                .failureHandler(failureHandler);

        http.logout()
                //配置注销成功处理器
                .logoutSuccessHandler(logoutSuccessHandler);

        http.authorizeRequests().anyRequest().authenticated();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;68-其他认证方案畅想&#34;&gt;6.8 其他认证方案畅想&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;oauth-2&#34;&gt;OAuth 2&lt;/h1&gt;
&lt;h2 id=&#34;开始&#34;&gt;开始&lt;/h2&gt;
">Spring Security笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/poi-yu-easyexcel-bi-ji/"" data-c="
          &lt;h1 id=&#34;poi与easyexcel&#34;&gt;POI与EasyExcel&lt;/h1&gt;
&lt;h2 id=&#34;poi&#34;&gt;POI&lt;/h2&gt;
&lt;p&gt;Apache POI为Java程序提供API，来支持Microsoft Office格式档案读和写的功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HSSF&lt;/code&gt; － 提供读写 Microsoft Excel &lt;code&gt;XLS&lt;/code&gt;格式档案的功能。&lt;code&gt;Excel2003&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;XSSF&lt;/code&gt; － 提供读写Microsoft Excel OOXML &lt;code&gt;XLSX&lt;/code&gt;格式档案的功能。&lt;code&gt;Excel2007+&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;S&lt;/mark&gt;XSSF － XSSF的加强版，采用缓存机制，可以写非常大的数据量，如 100万 条甚至更多，写数据速度快，占用更少的内存&lt;/p&gt;
&lt;p&gt;HWPF － 提供读写[Microsoft Word[DOC]格式档案的功能。&lt;/p&gt;
&lt;p&gt;HSLF － 提供读写Microsoft PowerPoint格式档案的功能。&lt;/p&gt;
&lt;p&gt;HDGF － 提供读写Microsoft Visio格式档案的功能。&lt;/p&gt;
&lt;p&gt;HPBF － 提供读写Microsoft Publisher格式档案的功能。&lt;/p&gt;
&lt;p&gt;HSMF － 提供读写Microsoft Outlook格式档案的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其中Excel2003文件最多存储65536行数据，Excel2007+则没有限制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;easyexcel&#34;&gt;EasyExcel&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;EasyExcel是阿里巴巴开源的快速、简洁、&lt;mark&gt;解决大文件内存溢出&lt;/mark&gt;的java处理Excel工具&lt;/li&gt;
&lt;li&gt;https://github.com/alibaba/easyexcel&lt;/li&gt;
&lt;li&gt;POI存在内存泄露的主要原因是，在操作过程中它是将所有数据写入到内存，再一次性写入磁盘。当然也有优点，速度快。&lt;/li&gt;
&lt;li&gt;EasyExcel是一行一行的读写，用这样的方式解决了内存占用高甚至溢出的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;poi-excel写&#34;&gt;POI-Excel写&lt;/h1&gt;
&lt;p&gt;1、创建Maven项目&lt;/p&gt;
&lt;p&gt;2、添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;!--xls(03)--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.poi&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;poi&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.9&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--xlsx(07)--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.poi&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;poi-ooxml&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.9&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--日期格式化工具--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;joda-time&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;joda-time&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.10.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--junit--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、编写测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ExcelWrite {
 
    private String PATH=&amp;quot;F:\\ideaProject\\study\\&amp;quot;;
 
    @Test
    public void write03() throws IOException {
        // 1、创建工作薄
        Workbook workbook = new HSSFWorkbook();
        //2、创建工作表
        Sheet sheet = workbook.createSheet(&amp;quot;test1&amp;quot;);
 
        //3、创建行(0:第一行)
        Row row1 = sheet.createRow(0);
        //4、创建单元格(0:第一行的第一个格子)
        Cell cell00 = row1.createCell(0);
        cell00.setCellValue(&amp;quot;测试数据&amp;quot;);
        //第一行的第二个格子
        Cell cell01 = row1.createCell(1);
        cell01.setCellValue(&amp;quot;testData&amp;quot;);
 
        //第二行
        Row row2 = sheet.createRow(1);
        //第二行的第一个格子
        Cell cell10 = row2.createCell(0);
        cell10.setCellValue(&amp;quot;时间&amp;quot;);
        //第二行的第二个格子
        Cell cell11 = row2.createCell(1);
        cell11.setCellValue(new DateTime().toString(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;));
 
        //生成Excel（IO流）
        //03版本的Excel是使用 .xls 结尾！！！
        FileOutputStream fileOutputStream = new FileOutputStream(PATH + &amp;quot;POI03测试.xls&amp;quot;);
 
        workbook.write(fileOutputStream);
 
        //关闭流
        fileOutputStream.close();
 
        System.out.println(&amp;quot;03Excel输出完毕&amp;quot;);
    }
 
    @Test
    public void write07() throws IOException {
        // 1、创建工作薄
        Workbook workbook = new XSSFWorkbook();
        //2、创建工作表
        Sheet sheet = workbook.createSheet(&amp;quot;test1&amp;quot;);
 
        //3、创建行(0:第一行)
        Row row1 = sheet.createRow(0);
        //4、创建单元格(0:第一行的第一个格子)
        Cell cell00 = row1.createCell(0);
        cell00.setCellValue(&amp;quot;测试数据&amp;quot;);
        //第一行的第二个格子
        Cell cell01 = row1.createCell(1);
        cell01.setCellValue(&amp;quot;testData&amp;quot;);
 
        //第二行
        Row row2 = sheet.createRow(1);
        //第二行的第一个格子
        Cell cell10 = row2.createCell(0);
        cell10.setCellValue(&amp;quot;时间&amp;quot;);
        //第二行的第二个格子
        Cell cell11 = row2.createCell(1);
        cell11.setCellValue(new DateTime().toString(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;));
 
        //生成Excel（IO流）
        //03版本的Excel是使用 .xlsx 结尾！！！
        FileOutputStream fileOutputStream = new FileOutputStream(PATH + &amp;quot;POI07测试.xlsx&amp;quot;);
 
        workbook.write(fileOutputStream);
 
        //关闭流
        fileOutputStream.close();
 
        System.out.println(&amp;quot;07Excel输出完毕&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，Excel文件后缀与对应的对象&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Excel版本&lt;/th&gt;
&lt;th&gt;文件后缀&lt;/th&gt;
&lt;th&gt;对应的对象&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2003&lt;/td&gt;
&lt;td&gt;xls&lt;/td&gt;
&lt;td&gt;HSSF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2007&lt;/td&gt;
&lt;td&gt;xlsx&lt;/td&gt;
&lt;td&gt;XSSF / SXSSF&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;hssf&#34;&gt;HSSF&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void write03BigData() throws IOException {
    long begin = System.currentTimeMillis();
 
    //创建簿
    Workbook workbook = new HSSFWorkbook();
    //创建表
    Sheet sheet = workbook.createSheet();
    //写数据
    for (int rowNum = 0; rowNum &amp;lt; 65536; rowNum++) {
        Row row = sheet.createRow(rowNum);
        for (int cellNum = 0; cellNum &amp;lt; 10; cellNum++) {
            Cell cell = row.createCell(cellNum);
            cell.setCellValue(cellNum);
        }
    }
    System.out.println(&amp;quot;over&amp;quot;);
    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &amp;quot;TestWrite03BigData.xls&amp;quot;);
    workbook.write(fileOutputStream);
    fileOutputStream.close();
 
    long end = System.currentTimeMillis();
 
    System.out.println((double) (end-begin)/1000);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;优点：写入过程中先写入内存，不操作磁盘，最后一次性写入磁盘，速度快&lt;/li&gt;
&lt;li&gt;缺点：最多只能处理 &lt;mark&gt;65536&lt;/mark&gt; 行，否则会抛出异常&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;java.lang.IllegalArgumentException: Invalid row number (65536) outside allowable range (0..65535)&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xssf&#34;&gt;XSSF&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;@Test
public void write07BigData() throws IOException {
    long begin = System.currentTimeMillis();
 
    //创建簿
    Workbook workbook = new XSSFWorkbook();
    //创建表
    Sheet sheet = workbook.createSheet();
    //写数据
    for (int rowNum = 0; rowNum &amp;lt; 100000; rowNum++) {
        Row row = sheet.createRow(rowNum);
        for (int cellNum = 0; cellNum &amp;lt; 10; cellNum++) {
            Cell cell = row.createCell(cellNum);
            cell.setCellValue(cellNum);
        }
    }
    System.out.println(&amp;quot;over&amp;quot;);
    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &amp;quot;TestWrite07BigData.xlsx&amp;quot;);
    workbook.write(fileOutputStream);
    fileOutputStream.close();
 
    long end = System.currentTimeMillis();
 
    System.out.println((double) (end-begin)/1000);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;优点：因为XSSF是对应Excel2007版本，所以它可以写较大的数据量，如 20万条&lt;/li&gt;
&lt;li&gt;缺点：因为POI的&lt;code&gt;一次性&lt;/code&gt;机制，写数据时速度非常慢，非常耗内存，也会发生内存溢出，如 100万条&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sxssf&#34;&gt;SXSSF&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void write07BigDataS() throws IOException {
    long begin = System.currentTimeMillis();
 
    //创建簿
    Workbook workbook = new SXSSFWorkbook();
    //创建表
    Sheet sheet = workbook.createSheet();
    //写数据
    for (int rowNum = 0; rowNum &amp;lt; 100000; rowNum++) {
        Row row = sheet.createRow(rowNum);
        for (int cellNum = 0; cellNum &amp;lt; 10; cellNum++) {
            Cell cell = row.createCell(cellNum);
            cell.setCellValue(cellNum);
        }
    }
    System.out.println(&amp;quot;over&amp;quot;);
    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &amp;quot;TestWrite07BigDataS.xlsx&amp;quot;);
    workbook.write(fileOutputStream);
    fileOutputStream.close();
  
    //删除临时文件
    ((SXSSFWorkbook) workbook).dispose();
 
    long end = System.currentTimeMillis();
    System.out.println((double) (end-begin)/1000);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;优点：采用缓存机制，可以写非常大的数据量，如 100万 条甚至更多，写数据速度快，占用更少的内存&lt;/li&gt;
&lt;li&gt;可以使用&lt;mark&gt;dispose&lt;/mark&gt;( )方法删除临时文件&lt;/li&gt;
&lt;li&gt;默认由 100 条记录被保存在内存中，如果超过这数量，则最前面的数据被写入临时文件&lt;/li&gt;
&lt;li&gt;如果想自定义&lt;mark&gt;内存中数据的数量&lt;/mark&gt;，可以使用&lt;mark&gt;有参构造器&lt;/mark&gt;。new SXSSFWorkbook(amount)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;SXSSFWorkbook 官方解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实现“BigGridDemo”策略的流式XSSFWorkbook版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这允许写入非常大的文件而不会耗尽内存，因为任何时候只有可配置的行部分被保存在内存中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请注意，仍然可能会消耗大量内存，&lt;/li&gt;
&lt;li&gt;这些内存基于正在使用的功能，例如合并区域，注释...仍然只存储在内存中&lt;/li&gt;
&lt;li&gt;因此如果广泛使用，可能需要大量内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;poi-excel读&#34;&gt;POI-Excel读&lt;/h1&gt;
&lt;h2 id=&#34;hssf-2&#34;&gt;HSSF&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testRead03() throws IOException {
    //获取文件流
    FileInputStream fileInputStream = new FileInputStream(PATH + &amp;quot;POIPOI03测试.xls&amp;quot;);
 
    //1、获取工作簿
    Workbook workbook = new HSSFWorkbook(fileInputStream);
    //2、得到表
    Sheet sheet = workbook.getSheetAt(0);
    //3、得到行
    Row row = sheet.getRow(0);
    //4、得到列
    Cell cell = row.getCell(0);
 
    //读取值时一定要注意类型
    System.out.println(cell.getStringCellValue());
 
    fileInputStream.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;==注意：==读取值时一定要注意类型，类型选择不匹配会报错&lt;/p&gt;
&lt;h2 id=&#34;xssf-2&#34;&gt;XSSF&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testRead07() throws IOException {
    //获取文件流
    FileInputStream fileInputStream = new FileInputStream(PATH + &amp;quot;POIPOI07测试.xlsx&amp;quot;);
 
    //1、获取工作簿
    Workbook workbook = new XSSFWorkbook(fileInputStream);
    //2、得到表
    Sheet sheet = workbook.getSheetAt(0);
    //3、得到行
    Row row = sheet.getRow(0);
    //4、得到列
    Cell cell = row.getCell(0);
 
    //读取值时一定要注意类型
    System.out.println(cell.getStringCellValue());
 
    fileInputStream.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;读取不同的数据类型&#34;&gt;读取不同的数据类型&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testCellType() throws Exception {
    //获取文件
    FileInputStream fileInputStream = new FileInputStream(PATH + &amp;quot;会员消费商品明细表.xls&amp;quot;);
 
    //获取工作薄
    Workbook workbook = new HSSFWorkbook(fileInputStream);
    //得到表
    Sheet sheet = workbook.getSheetAt(0);
 
    //获取标题内容
    Row rowTitle = sheet.getRow(0);
    if (rowTitle != null){
        //获取一行中有多少个单元格
        int cellCount = rowTitle.getPhysicalNumberOfCells();
        for (int cellNum = 0; cellNum &amp;lt; cellCount; cellNum++) {
            //获取单元
            Cell cell = rowTitle.getCell(cellNum);
            if (cell != null){
                //获取类型
                int cellType = cell.getCellType();
                String cellValue = cell.getStringCellValue();
                System.out.print(cellValue + &amp;quot; | &amp;quot;);
            }
        }
        System.out.println();
    }
 
    //获取表中的内容
    int rowCount = sheet.getPhysicalNumberOfRows();
    for (int rowNum = 1; rowNum &amp;lt; rowCount; rowNum++) {
        Row rowData = sheet.getRow(rowNum);
        if (rowData != null){
            //读取列
            int cellCout = rowTitle.getPhysicalNumberOfCells();
            for (int cellNum = 0; cellNum &amp;lt; cellCout; cellNum++) {
                System.out.print(&amp;quot;【&amp;quot; + (rowNum+1) + &amp;quot;-&amp;quot; + (cellNum+1) + &amp;quot;】&amp;quot;);
              
                Cell cell = rowData.getCell(cellNum);
                //匹配列的数据类型
                if (cell != null){
                    int cellType = cell.getCellType();
                    String cellValue = &amp;quot;&amp;quot;;
 
                    switch (cellType){
                        case HSSFCell.CELL_TYPE_STRING://字符串
                            System.out.print(&amp;quot;【STRING】&amp;quot;);
                            cellValue = cell.getStringCellValue();
                            break;
                        case HSSFCell.CELL_TYPE_BOOLEAN://布尔值
                            System.out.print(&amp;quot;【BOOLEAN】&amp;quot;);
                            cellValue = String.valueOf(cell.getBooleanCellValue());
                            break;
                        case HSSFCell.CELL_TYPE_NUMERIC://数字类型
                            System.out.print(&amp;quot;【NUMERIC】&amp;quot;);
 
                            if (HSSFDateUtil.isCellDateFormatted(cell)){//日期
                                System.out.print(&amp;quot;【日期】&amp;quot;);
                                Date date = cell.getDateCellValue();
                                cellValue = new DateTime().toString(&amp;quot;yyyy-MM-dd&amp;quot;);
                            }else{
                                // 不是日期格式，则防止当数字过长时以科学计数法显示
                                System.out.print(&amp;quot;【转换成字符串】&amp;quot;);
                                cell.setCellType(HSSFCell.CELL_TYPE_STRING);
                                cellValue = cell.toString();
                            }
                            break;
                        case HSSFCell.CELL_TYPE_BLANK://空
                            System.out.print(&amp;quot;【BLANK】&amp;quot;);
                            break;
                        case Cell.CELL_TYPE_ERROR:
                            System.out.print(&amp;quot;【数据类型错误】&amp;quot;);
                            break;
                    }
                    System.out.println(cellValue);
                }
            }
        }
    }
    fileInputStream.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;读计算公式&#34;&gt;读计算公式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testFormula() throws Exception {
    FileInputStream fileInputStream = new FileInputStream(PATH + &amp;quot;计算公式.xls&amp;quot;);
    Workbook workbook = new HSSFWorkbook(fileInputStream);
    Sheet sheetAt = workbook.getSheetAt(0);
 
    //获取计算公式所在的行
    Row row = sheetAt.getRow(4);
    //计算公式的第几个单元格
    Cell cell = row.getCell(0);
 
    //拿到计算公式
    FormulaEvaluator formulaEvaluator = new HSSFFormulaEvaluator((HSSFWorkbook) workbook);
 
    //输出单元格内容
    int cellType = cell.getCellType();
    switch (cellType){
        case Cell.CELL_TYPE_FORMULA://公式
            //获取单元格的计算公式
            String formula = cell.getCellFormula();
            System.out.println(formula);
 
            //计算
            CellValue evaluate = formulaEvaluator.evaluate(cell);
            String cellValue = evaluate.formatAsString();
            System.out.println(cellValue);
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;easyexcel操作&#34;&gt;EasyExcel操作&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;EasyExcel操作参照官方快速开始即可&lt;/li&gt;
&lt;li&gt;https://github.com/alibaba/easyexcel&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;写入&#34;&gt;写入&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按固定类格式进行写入&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;读取&#34;&gt;读取&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;根据监听器设置的规则进行读取&lt;/li&gt;
&lt;/ul&gt;
">POI与EasyExcel笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/vue3-kuai-su-shang-shou-bi-ji/"" data-c="
          &lt;h1 id=&#34;vue3快速上手&#34;&gt;Vue3快速上手&lt;/h1&gt;
&lt;img src=&#34;https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png&#34; style=&#34;width:200px&#34; /&gt;
&lt;h2 id=&#34;1vue3简介&#34;&gt;1.Vue3简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）&lt;/li&gt;
&lt;li&gt;耗时2年多、&lt;a href=&#34;https://github.com/vuejs/vue-next/graphs/commit-activity&#34;&gt;2600+次提交&lt;/a&gt;、&lt;a href=&#34;https://github.com/vuejs/rfcs/tree/master/active-rfcs&#34;&gt;30+个RFC&lt;/a&gt;、&lt;a href=&#34;https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+&#34;&gt;600+次PR&lt;/a&gt;、&lt;a href=&#34;https://github.com/vuejs/vue-next/graphs/contributors&#34;&gt;99位贡献者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2vue3带来了什么&#34;&gt;2.Vue3带来了什么&lt;/h2&gt;
&lt;h3 id=&#34;1性能的提升&#34;&gt;1.性能的提升&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;打包大小减少41%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初次渲染快55%, 更新渲染快133%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存减少54%&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2源码的升级&#34;&gt;2.源码的升级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用Proxy代替defineProperty实现响应式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重写虚拟DOM的实现和Tree-Shaking&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3拥抱typescript&#34;&gt;3.拥抱TypeScript&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Vue3可以更好的支持TypeScript&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4新的特性&#34;&gt;4.新的特性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Composition API（组合API）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setup配置&lt;/li&gt;
&lt;li&gt;ref与reactive&lt;/li&gt;
&lt;li&gt;watch与watchEffect&lt;/li&gt;
&lt;li&gt;provide与inject&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新的内置组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fragment&lt;/li&gt;
&lt;li&gt;Teleport&lt;/li&gt;
&lt;li&gt;Suspense&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他改变&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新的生命周期钩子&lt;/li&gt;
&lt;li&gt;data 选项应始终被声明为一个函数&lt;/li&gt;
&lt;li&gt;移除keyCode支持作为 v-on 的修饰符&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;一-创建vue30工程&#34;&gt;一、创建Vue3.0工程&lt;/h1&gt;
&lt;h2 id=&#34;1使用-vue-cli-创建&#34;&gt;1.使用 vue-cli 创建&lt;/h2&gt;
&lt;p&gt;官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
vue --version
## 安装或者升级你的@vue/cli
npm install -g @vue/cli
## 创建
vue create vue_test
## 启动
cd vue_test
npm run serve
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2使用-vite-创建&#34;&gt;2.使用 vite 创建&lt;/h2&gt;
&lt;p&gt;官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite&lt;/p&gt;
&lt;p&gt;vite官网：https://vitejs.cn&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是vite？—— 新一代前端构建工具。&lt;/li&gt;
&lt;li&gt;优势如下：
&lt;ul&gt;
&lt;li&gt;开发环境中，无需打包操作，可快速的冷启动。&lt;/li&gt;
&lt;li&gt;轻量快速的热重载（HMR）。&lt;/li&gt;
&lt;li&gt;真正的按需编译，不再等待整个应用编译完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;传统构建 与 vite构建对比图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cn.vitejs.dev/assets/bundler.37740380.png&#34; style=&#34;width:500px;height:280px;float:left&#34; /&gt;&lt;img src=&#34;https://cn.vitejs.dev/assets/esm.3070012d.png&#34; style=&#34;width:480px;height:280px&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## 创建工程
npm init vite-app &amp;lt;project-name&amp;gt;
## 进入工程目录
cd &amp;lt;project-name&amp;gt;
## 安装依赖
npm install
## 运行
npm run dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二-常用-composition-api&#34;&gt;二、常用 Composition API&lt;/h1&gt;
&lt;p&gt;官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html&lt;/p&gt;
&lt;h2 id=&#34;1拉开序幕的setup&#34;&gt;1.拉开序幕的setup&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;理解：Vue3.0中一个新的配置项，值为一个函数。&lt;/li&gt;
&lt;li&gt;setup是所有&lt;strong style=&#34;color:#DD5145&#34;&gt;Composition API（组合API）&lt;/strong&gt;&lt;i style=&#34;color:gray;font-weight:bold&#34;&gt;“ 表演的舞台 ”&lt;/i&gt;。&lt;/li&gt;
&lt;li&gt;组件中所用到的：数据、方法等等，均要配置在setup中。&lt;/li&gt;
&lt;li&gt;setup函数的两种返回值：
&lt;ol&gt;
&lt;li&gt;若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:#aad&#34;&gt;若返回一个渲染函数：则可以自定义渲染内容。（了解）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;注意点：
&lt;ol&gt;
&lt;li&gt;尽量不要与Vue2.x配置混用
&lt;ul&gt;
&lt;li&gt;Vue2.x配置（data、methos、computed...）中&lt;strong style=&#34;color:#DD5145&#34;&gt;可以访问到&lt;/strong&gt;setup中的属性、方法。&lt;/li&gt;
&lt;li&gt;但在setup中&lt;strong style=&#34;color:#DD5145&#34;&gt;不能访问到&lt;/strong&gt;Vue2.x配置（data、methos、computed...）。&lt;/li&gt;
&lt;li&gt;如果有重名, setup优先。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2ref函数&#34;&gt;2.ref函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作用: 定义一个响应式的数据&lt;/li&gt;
&lt;li&gt;语法: &lt;code&gt;const xxx = ref(initValue)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;创建一个包含响应式数据的&lt;strong style=&#34;color:#DD5145&#34;&gt;引用对象（reference对象，简称ref对象）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;JS中操作数据： &lt;code&gt;xxx.value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;模板中读取数据: 不需要.value，直接：&lt;code&gt;&amp;lt;div&amp;gt;{{xxx}}&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;备注：
&lt;ul&gt;
&lt;li&gt;接收的数据可以是：基本类型、也可以是对象类型。&lt;/li&gt;
&lt;li&gt;基本类型的数据：响应式依然是靠&lt;code&gt;Object.defineProperty()&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;与&lt;code&gt;set&lt;/code&gt;完成的。&lt;/li&gt;
&lt;li&gt;对象类型的数据：内部 &lt;i style=&#34;color:gray;font-weight:bold&#34;&gt;“ 求助 ”&lt;/i&gt; 了Vue3.0中的一个新函数—— &lt;code&gt;reactive&lt;/code&gt;函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3reactive函数&#34;&gt;3.reactive函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作用: 定义一个&lt;strong style=&#34;color:#DD5145&#34;&gt;对象类型&lt;/strong&gt;的响应式数据（基本类型不要用它，要用&lt;code&gt;ref&lt;/code&gt;函数）&lt;/li&gt;
&lt;li&gt;语法：&lt;code&gt;const 代理对象= reactive(源对象)&lt;/code&gt;接收一个对象（或数组），返回一个&lt;strong style=&#34;color:#DD5145&#34;&gt;代理对象（Proxy的实例对象，简称proxy对象）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;reactive定义的响应式数据是“深层次的”。&lt;/li&gt;
&lt;li&gt;内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4vue30中的响应式原理&#34;&gt;4.Vue3.0中的响应式原理&lt;/h2&gt;
&lt;h3 id=&#34;vue2x的响应式&#34;&gt;vue2.x的响应式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象类型：通过&lt;code&gt;Object.defineProperty()&lt;/code&gt;对属性的读取、修改进行拦截（数据劫持）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.defineProperty(data, &#39;count&#39;, {
    get () {}, 
    set () {}
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存在问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增属性、删除属性, 界面不会更新。&lt;/li&gt;
&lt;li&gt;直接通过下标修改数组, 界面不会自动更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vue30的响应式&#34;&gt;Vue3.0的响应式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实现原理:
&lt;ul&gt;
&lt;li&gt;通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。&lt;/li&gt;
&lt;li&gt;通过Reflect（反射）:  对源对象的属性进行操作。&lt;/li&gt;
&lt;li&gt;MDN文档中描述的Proxy与Reflect：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;new Proxy(data, {
	// 拦截读取属性值
    get (target, prop) {
    	return Reflect.get(target, prop)
    },
    // 拦截设置属性值或添加新属性
    set (target, prop, value) {
    	return Reflect.set(target, prop, value)
    },
    // 拦截删除属性
    deleteProperty (target, prop) {
    	return Reflect.deleteProperty(target, prop)
    }
})

proxy.name = &#39;tom&#39;   
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5reactive对比ref&#34;&gt;5.reactive对比ref&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从定义数据角度对比：
&lt;ul&gt;
&lt;li&gt;ref用来定义：&lt;strong style=&#34;color:#DD5145&#34;&gt;基本类型数据&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;reactive用来定义：&lt;strong style=&#34;color:#DD5145&#34;&gt;对象（或数组）类型数据&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;备注：ref也可以用来定义&lt;strong style=&#34;color:#DD5145&#34;&gt;对象（或数组）类型数据&lt;/strong&gt;, 它内部会自动通过&lt;code&gt;reactive&lt;/code&gt;转为&lt;strong style=&#34;color:#DD5145&#34;&gt;代理对象&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从原理角度对比：
&lt;ul&gt;
&lt;li&gt;ref通过&lt;code&gt;Object.defineProperty()&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;与&lt;code&gt;set&lt;/code&gt;来实现响应式（数据劫持）。&lt;/li&gt;
&lt;li&gt;reactive通过使用&lt;strong style=&#34;color:#DD5145&#34;&gt;Proxy&lt;/strong&gt;来实现响应式（数据劫持）, 并通过&lt;strong style=&#34;color:#DD5145&#34;&gt;Reflect&lt;/strong&gt;操作&lt;strong style=&#34;color:orange&#34;&gt;源对象&lt;/strong&gt;内部的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从使用角度对比：
&lt;ul&gt;
&lt;li&gt;ref定义的数据：操作数据&lt;strong style=&#34;color:#DD5145&#34;&gt;需要&lt;/strong&gt;&lt;code&gt;.value&lt;/code&gt;，读取数据时模板中直接读取&lt;strong style=&#34;color:#DD5145&#34;&gt;不需要&lt;/strong&gt;&lt;code&gt;.value&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;reactive定义的数据：操作数据与读取数据：&lt;strong style=&#34;color:#DD5145&#34;&gt;均不需要&lt;/strong&gt;&lt;code&gt;.value&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6setup的两个注意点&#34;&gt;6.setup的两个注意点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setup执行的时机&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在beforeCreate之前执行一次，this是undefined。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setup的参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。&lt;/li&gt;
&lt;li&gt;context：上下文对象
&lt;ul&gt;
&lt;li&gt;attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 &lt;code&gt;this.$attrs&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;slots: 收到的插槽内容, 相当于 &lt;code&gt;this.$slots&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;emit: 分发自定义事件的函数, 相当于 &lt;code&gt;this.$emit&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7计算属性与监视&#34;&gt;7.计算属性与监视&lt;/h2&gt;
&lt;h3 id=&#34;1computed函数&#34;&gt;1.computed函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;与Vue2.x中computed配置功能一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {computed} from &#39;vue&#39;

setup(){
    ...
	//计算属性——简写
    let fullName = computed(()=&amp;gt;{
        return person.firstName + &#39;-&#39; + person.lastName
    })
    //计算属性——完整
    let fullName = computed({
        get(){
            return person.firstName + &#39;-&#39; + person.lastName
        },
        set(value){
            const nameArr = value.split(&#39;-&#39;)
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        }
    })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2watch函数&#34;&gt;2.watch函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;与Vue2.x中watch配置功能一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个小“坑”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。&lt;/li&gt;
&lt;li&gt;监视reactive定义的响应式数据中某个属性时：deep配置有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=&amp;gt;{
	console.log(&#39;sum变化了&#39;,newValue,oldValue)
},{immediate:true})

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=&amp;gt;{
	console.log(&#39;sum或msg变化了&#39;,newValue,oldValue)
}) 

/* 情况三：监视reactive定义的响应式数据
			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=&amp;gt;{
	console.log(&#39;person变化了&#39;,newValue,oldValue)
},{immediate:true,deep:false}) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=&amp;gt;person.job,(newValue,oldValue)=&amp;gt;{
	console.log(&#39;person的job变化了&#39;,newValue,oldValue)
},{immediate:true,deep:true}) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=&amp;gt;person.job,()=&amp;gt;person.name],(newValue,oldValue)=&amp;gt;{
	console.log(&#39;person的job变化了&#39;,newValue,oldValue)
},{immediate:true,deep:true})

//特殊情况
watch(()=&amp;gt;person.job,(newValue,oldValue)=&amp;gt;{
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3watcheffect函数&#34;&gt;3.watchEffect函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;watch的套路是：既要指明监视的属性，也要指明监视的回调。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;watchEffect有点像computed：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。&lt;/li&gt;
&lt;li&gt;而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=&amp;gt;{
    const x1 = sum.value
    const x2 = person.age
    console.log(&#39;watchEffect配置的回调执行了&#39;)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8生命周期&#34;&gt;8.生命周期&lt;/h2&gt;
&lt;h3 id=&#34;vue2x的生命周期&#34;&gt;Vue2.x的生命周期&lt;/h3&gt;
&lt;img src=&#34;https://v2.cn.vuejs.org/images/lifecycle.png&#34; alt=&#34;img&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;h3 id=&#34;vue30的生命周期&#34;&gt;Vue3.0的生命周期&lt;/h3&gt;
&lt;img src=&#34;https://cn.vuejs.org/assets/lifecycle.16e4c08e.png&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;beforeDestroy&lt;/code&gt;改名为 &lt;code&gt;beforeUnmount&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;destroyed&lt;/code&gt;改名为 &lt;code&gt;unmounted&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;beforeCreate&lt;/code&gt;===&amp;gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;created&lt;/code&gt;===&amp;gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;beforeMount&lt;/code&gt; ===&amp;gt;&lt;code&gt;onBeforeMount&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mounted&lt;/code&gt;===&amp;gt;&lt;code&gt;onMounted&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;beforeUpdate&lt;/code&gt;===&amp;gt;&lt;code&gt;onBeforeUpdate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;updated&lt;/code&gt; ===&amp;gt;&lt;code&gt;onUpdated&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;beforeUnmount&lt;/code&gt; ==&amp;gt;&lt;code&gt;onBeforeUnmount&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unmounted&lt;/code&gt; ===&amp;gt;&lt;code&gt;onUnmounted&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;9自定义hook函数&#34;&gt;9.自定义hook函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类似于vue2.x中的mixin。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10toref&#34;&gt;10.toRef&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法：&lt;code&gt;const name = toRef(person,&#39;name&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用:   要将响应式对象中的某个属性单独提供给外部使用时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扩展：&lt;code&gt;toRefs&lt;/code&gt; 与&lt;code&gt;toRef&lt;/code&gt;功能一致，但可以批量创建多个 ref 对象，语法：&lt;code&gt;toRefs(person)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;三-其它-composition-api&#34;&gt;三、其它 Composition API&lt;/h1&gt;
&lt;h2 id=&#34;1shallowreactive-与-shallowref&#34;&gt;1.shallowReactive 与 shallowRef&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;shallowReactive：只处理对象最外层属性的响应式（浅响应式）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么时候使用?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&amp;gt; shallowReactive。&lt;/li&gt;
&lt;li&gt;如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&amp;gt; shallowRef。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2readonly-与-shallowreadonly&#34;&gt;2.readonly 与 shallowReadonly&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;readonly: 让一个响应式数据变为只读的（深只读）。&lt;/li&gt;
&lt;li&gt;shallowReadonly：让一个响应式数据变为只读的（浅只读）。&lt;/li&gt;
&lt;li&gt;应用场景: 不希望数据被修改时。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3toraw-与-markraw&#34;&gt;3.toRaw 与 markRaw&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;toRaw：
&lt;ul&gt;
&lt;li&gt;作用：将一个由&lt;code&gt;reactive&lt;/code&gt;生成的&lt;strong style=&#34;color:orange&#34;&gt;响应式对象&lt;/strong&gt;转为&lt;strong style=&#34;color:orange&#34;&gt;普通对象&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;markRaw：
&lt;ul&gt;
&lt;li&gt;作用：标记一个对象，使其永远不会再成为响应式对象。&lt;/li&gt;
&lt;li&gt;应用场景:
&lt;ol&gt;
&lt;li&gt;有些值不应被设置为响应式的，例如复杂的第三方类库等。&lt;/li&gt;
&lt;li&gt;当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4customref&#34;&gt;4.customRef&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现防抖效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;template&amp;gt;
	&amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;keyword&amp;quot;&amp;gt;
	&amp;lt;h3&amp;gt;{{keyword}}&amp;lt;/h3&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
	import {ref,customRef} from &#39;vue&#39;
	export default {
		name:&#39;Demo&#39;,
		setup(){
			// let keyword = ref(&#39;hello&#39;) //使用Vue准备好的内置ref
			//自定义一个myRef
			function myRef(value,delay){
				let timer
				//通过customRef去实现自定义
				return customRef((track,trigger)=&amp;gt;{
					return{
						get(){
							track() //告诉Vue这个value值是需要被“追踪”的
							return value
						},
						set(newValue){
							clearTimeout(timer)
							timer = setTimeout(()=&amp;gt;{
								value = newValue
								trigger() //告诉Vue去更新界面
							},delay)
						}
					}
				})
			}
			let keyword = myRef(&#39;hello&#39;,500) //使用程序员自定义的ref
			return {
				keyword
			}
		}
	}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5provide-与-inject&#34;&gt;5.provide 与 inject&lt;/h2&gt;
&lt;img src=&#34;https://v3.cn.vuejs.org/images/components_provide.png&#34; style=&#34;zoom:50%;&#34;/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作用：实现&lt;strong style=&#34;color:#DD5145&#34;&gt;祖与后代组件间&lt;/strong&gt;通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套路：父组件有一个 &lt;code&gt;provide&lt;/code&gt; 选项来提供数据，后代组件有一个 &lt;code&gt;inject&lt;/code&gt; 选项来开始使用这些数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具体写法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;祖组件中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;setup(){
	......
    let car = reactive({name:&#39;奔驰&#39;,price:&#39;40万&#39;})
    provide(&#39;car&#39;,car)
    ......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后代组件中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;setup(props,context){
	......
    const car = inject(&#39;car&#39;)
    return {car}
	......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6响应式数据的判断&#34;&gt;6.响应式数据的判断&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;isRef: 检查一个值是否为一个 ref 对象&lt;/li&gt;
&lt;li&gt;isReactive: 检查一个对象是否是由 &lt;code&gt;reactive&lt;/code&gt; 创建的响应式代理&lt;/li&gt;
&lt;li&gt;isReadonly: 检查一个对象是否是由 &lt;code&gt;readonly&lt;/code&gt; 创建的只读代理&lt;/li&gt;
&lt;li&gt;isProxy: 检查一个对象是否是由 &lt;code&gt;reactive&lt;/code&gt; 或者 &lt;code&gt;readonly&lt;/code&gt; 方法创建的代理&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;四-composition-api-的优势&#34;&gt;四、Composition API 的优势&lt;/h1&gt;
&lt;h2 id=&#34;1options-api-存在的问题&#34;&gt;1.Options API 存在的问题&lt;/h2&gt;
&lt;p&gt;使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。&lt;/p&gt;
 &lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image&#34; style=&#34;zoom:50%;&#34;/&gt;
 &lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image&#34; style=&#34;zoom:50%;&#34;/&gt; 
&lt;h2 id=&#34;2composition-api-的优势&#34;&gt;2.Composition API 的优势&lt;/h2&gt;
&lt;p&gt;我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。&lt;/p&gt;
 &lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image&#34; style=&#34;zoom:50%;&#34;/&gt;
 &lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image&#34; style=&#34;zoom:50%;&#34;/&gt; 
&lt;h1 id=&#34;五-新的组件&#34;&gt;五、新的组件&lt;/h1&gt;
&lt;h2 id=&#34;1fragment&#34;&gt;1.Fragment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在Vue2中: 组件必须有一个根标签&lt;/li&gt;
&lt;li&gt;在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中&lt;/li&gt;
&lt;li&gt;好处: 减少标签层级, 减小内存占用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2teleport&#34;&gt;2.Teleport&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;什么是Teleport？—— &lt;code&gt;Teleport&lt;/code&gt; 是一种能够将我们的&lt;strong style=&#34;color:#DD5145&#34;&gt;组件html结构&lt;/strong&gt;移动到指定位置的技术。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;teleport to=&amp;quot;移动位置&amp;quot;&amp;gt;
	&amp;lt;div v-if=&amp;quot;isShow&amp;quot; class=&amp;quot;mask&amp;quot;&amp;gt;
		&amp;lt;div class=&amp;quot;dialog&amp;quot;&amp;gt;
			&amp;lt;h3&amp;gt;我是一个弹窗&amp;lt;/h3&amp;gt;
			&amp;lt;button @click=&amp;quot;isShow = false&amp;quot;&amp;gt;关闭弹窗&amp;lt;/button&amp;gt;
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/teleport&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3suspense&#34;&gt;3.Suspense&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;等待异步组件时渲染一些额外内容，让应用有更好的用户体验&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;异步引入组件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {defineAsyncComponent} from &#39;vue&#39;
const Child = defineAsyncComponent(()=&amp;gt;import(&#39;./components/Child.vue&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;Suspense&lt;/code&gt;包裹组件，并配置好&lt;code&gt;default&lt;/code&gt; 与 &lt;code&gt;fallback&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;template&amp;gt;
	&amp;lt;div class=&amp;quot;app&amp;quot;&amp;gt;
		&amp;lt;h3&amp;gt;我是App组件&amp;lt;/h3&amp;gt;
		&amp;lt;Suspense&amp;gt;
			&amp;lt;template v-slot:default&amp;gt;
				&amp;lt;Child/&amp;gt;
			&amp;lt;/template&amp;gt;
			&amp;lt;template v-slot:fallback&amp;gt;
				&amp;lt;h3&amp;gt;加载中.....&amp;lt;/h3&amp;gt;
			&amp;lt;/template&amp;gt;
		&amp;lt;/Suspense&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;六-其他&#34;&gt;六、其他&lt;/h1&gt;
&lt;h2 id=&#34;1全局api的转移&#34;&gt;1.全局API的转移&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Vue 2.x 有许多全局 API 和配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例如：注册全局组件、注册全局指令等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//注册全局组件
Vue.component(&#39;MyButton&#39;, {
  data: () =&amp;gt; ({
    count: 0
  }),
  template: &#39;&amp;lt;button @click=&amp;quot;count++&amp;quot;&amp;gt;Clicked {{ count }} times.&amp;lt;/button&amp;gt;&#39;
})

//注册全局指令
Vue.directive(&#39;focus&#39;, {
  inserted: el =&amp;gt; el.focus()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vue3.0中对这些API做出了调整：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将全局的API，即：&lt;code&gt;Vue.xxx&lt;/code&gt;调整到应用实例（&lt;code&gt;app&lt;/code&gt;）上&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;2.x 全局 API（&lt;code&gt;Vue&lt;/code&gt;）&lt;/th&gt;
&lt;th&gt;3.x 实例 API (&lt;code&gt;app&lt;/code&gt;)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Vue.config.xxxx&lt;/td&gt;
&lt;td&gt;app.config.xxxx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Vue.config.productionTip&lt;/td&gt;
&lt;td&gt;&lt;strong style=&#34;color:#DD5145&#34;&gt;移除&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Vue.component&lt;/td&gt;
&lt;td&gt;app.component&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Vue.directive&lt;/td&gt;
&lt;td&gt;app.directive&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Vue.mixin&lt;/td&gt;
&lt;td&gt;app.mixin&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Vue.use&lt;/td&gt;
&lt;td&gt;app.use&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Vue.prototype&lt;/td&gt;
&lt;td&gt;app.config.globalProperties&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2其他改变&#34;&gt;2.其他改变&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;data选项应始终被声明为一个函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过度类名的更改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Vue2.x写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.v-enter,
.v-leave-to {
  opacity: 0;
}
.v-leave,
.v-enter-to {
  opacity: 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vue3.x写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-leave-from,
.v-enter-to {
  opacity: 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong style=&#34;color:#DD5145&#34;&gt;移除&lt;/strong&gt;keyCode作为 v-on 的修饰符，同时也不再支持&lt;code&gt;config.keyCodes&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong style=&#34;color:#DD5145&#34;&gt;移除&lt;/strong&gt;&lt;code&gt;v-on.native&lt;/code&gt;修饰符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;父组件中绑定事件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;my-component
  v-on:close=&amp;quot;handleComponentEvent&amp;quot;
  v-on:click=&amp;quot;handleNativeClickEvent&amp;quot;
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子组件中声明自定义事件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vue&#34;&gt;&amp;lt;script&amp;gt;
  export default {
    emits: [&#39;close&#39;]
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong style=&#34;color:#DD5145&#34;&gt;移除&lt;/strong&gt;过滤器（filter）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Vue3快速上手笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/ssm-zheng-he/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;视频课程链接：&lt;br&gt;
&lt;a href=&#34;https://youtube.com/playlist?list=PLmOn9nNkQxJFbsU4Qz8CdRiVM4Qs3ci75&#34;&gt;🔗YouTube（下载资料更方便）&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1Ya411S7aT&#34;&gt;🔗bilibili&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727103525.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;ssm整合&#34;&gt;SSM整合&lt;/h1&gt;
&lt;h1 id=&#34;1-contextloaderlistener&#34;&gt;1、ContextLoaderListener&lt;/h1&gt;
&lt;p&gt;Spring提供了监听器ContextLoaderListener，实现ServletContextListener接口，可监听 ServletContext 的状态，在web服务器的启动，读取Spring的配置文件，创建Spring的IOC容器。web 应用中必须在web.xml中配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
    配置Spring的监听器，在服务器启动时加载Spring的配置文件
    Spring配置文件默认位置和名称：/WEB-INF/applicationContext.xml
    可通过上下文参数自定义Spring配置文件的位置和名称
 --&amp;gt;
&amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;

&amp;lt;!-- 设置Spring的配置文件的位置和名称 --&amp;gt;
&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;classpath:Spring.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-准备工作&#34;&gt;2、准备工作&lt;/h1&gt;
&lt;h2 id=&#34;1创建maven-module&#34;&gt;①创建Maven Module&lt;/h2&gt;
&lt;h2 id=&#34;2导入依赖&#34;&gt;②导入依赖&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;

&amp;lt;properties&amp;gt;
    &amp;lt;spring.version&amp;gt;5.3.1&amp;lt;/spring.version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--springmvc--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-aspects&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- Mybatis核心 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.5.7&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--mybatis和spring的整合包--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.0.6&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- druid连接池 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.9&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- junit测试 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- MySQL驱动 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.1.38&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- log4j日志 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;pagehelper&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.2.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 日志 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- ServletAPI --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.12.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- Spring5和Thymeleaf整合包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.thymeleaf&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;thymeleaf-spring5&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.0.12.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3创建表&#34;&gt;③创建表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE `t_emp`(
    `emp_id`   int(11) NOT NULL AUTO_INCREMENT,
    `emp_name` varchar(20) DEFAULT NULL,
    `age`      int(11) DEFAULT NULL,
    `sex`      char(1)     DEFAULT NULL,
    `email`    varchar(50) DEFAULT NULL,
    PRIMARY KEY (`emp_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-配置webxml&#34;&gt;3、配置web.xml&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--配置springMVC的编码过滤器--&amp;gt;
&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
    &amp;lt;!--如果只设置encoding参数则编码过滤器只对请求request生效--&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;!--设置forceResponseEncoding参数为true，编码过滤器才对响应respose生效--&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;forceResponseEncoding&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;

&amp;lt;!-- 配置处理请求方式PUT和DELETE的过滤器 --&amp;gt;
&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;HiddenHttpMethodFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.springframework.web.filter.HiddenHttpMethodFilter&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;HiddenHttpMethodFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;

&amp;lt;!-- 配置SpringMVC的前端控制器 --&amp;gt;
&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;!-- 设置SpringMVC的配置文件的位置和名称 --&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;classpath:SpringMVC.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;!-- 将DispatcherServlet 的初始化时间提前到服务器启动时 --&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;

&amp;lt;!-- 配置Spring的监听器 --&amp;gt;
&amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;

&amp;lt;!-- 设置Spring的配置文件的位置和名称 --&amp;gt;
&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;classpath:Spring.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-创建springmvc的配置文件并配置&#34;&gt;4、创建SpringMVC的配置文件并配置&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--扫描控制层组件--&amp;gt;
&amp;lt;context:component-scan base-package=&amp;quot;com.atguigu.controller&amp;quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;

&amp;lt;!--配置视图解析器--&amp;gt;
&amp;lt;bean id=&amp;quot;viewResolver&amp;quot; class=&amp;quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;order&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;characterEncoding&amp;quot; value=&amp;quot;UTF-8&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;templateEngine&amp;quot;&amp;gt;
        &amp;lt;bean class=&amp;quot;org.thymeleaf.spring5.SpringTemplateEngine&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;templateResolver&amp;quot;&amp;gt;
                &amp;lt;bean class=&amp;quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&amp;quot;&amp;gt;
                    &amp;lt;!-- 视图前缀 --&amp;gt;
                    &amp;lt;property name=&amp;quot;prefix&amp;quot; value=&amp;quot;/WEB-INF/templates/&amp;quot;/&amp;gt;
                    &amp;lt;!-- 视图后缀 --&amp;gt;
                    &amp;lt;property name=&amp;quot;suffix&amp;quot; value=&amp;quot;.html&amp;quot;/&amp;gt;
                    &amp;lt;property name=&amp;quot;templateMode&amp;quot; value=&amp;quot;HTML5&amp;quot;/&amp;gt;
                    &amp;lt;property name=&amp;quot;characterEncoding&amp;quot; value=&amp;quot;UTF-8&amp;quot;/&amp;gt;
                &amp;lt;/bean&amp;gt;
            &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!-- 配置默认的servlet处理静态资源 --&amp;gt;
&amp;lt;mvc:default-servlet-handler/&amp;gt;

&amp;lt;!-- 开启MVC的注解驱动 --&amp;gt;
&amp;lt;mvc:annotation-driven/&amp;gt;

&amp;lt;!-- 配置访问首页的视图控制器 --&amp;gt;
&amp;lt;mvc:view-controller path=&amp;quot;/&amp;quot; view-name=&amp;quot;index&amp;quot;&amp;gt;&amp;lt;/mvc:view-controller&amp;gt;

&amp;lt;!-- 处理CORS --&amp;gt;
&amp;lt;mvc:cors&amp;gt;
    &amp;lt;!--
        allowed-origins: &amp;lt;origin&amp;gt; | *
        其中，origin 参数的值指定允许访问该资源的外域 origin 域名。
        对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符*，表示允许来自所有域的请求。
    --&amp;gt;
    &amp;lt;!--&amp;lt;mvc:mapping path=&amp;quot;/**&amp;quot; allowed-origins=&amp;quot;http:/z/example.com/&amp;quot; allowed-methods=&amp;quot;GET,POST&amp;quot; max-age=&amp;quot;3600&amp;quot;/&amp;gt;--&amp;gt;
    &amp;lt;!--
        allowed-origin-patterns
        替代llowed-origins，此属性允许更灵活的模式，例如 *.domain1.com
    --&amp;gt;
    &amp;lt;mvc:mapping path=&amp;quot;/**&amp;quot; allowed-origin-patterns=&amp;quot;http://localhost:*&amp;quot; allowed-methods=&amp;quot;GET,POST&amp;quot; max-age=&amp;quot;3600&amp;quot;/&amp;gt;
&amp;lt;/mvc:cors&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-搭建mybatis环境&#34;&gt;5、搭建MyBatis环境&lt;/h1&gt;
&lt;h2 id=&#34;1创建属性文件jdbcproperties&#34;&gt;①创建属性文件jdbc.properties&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/mydb?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false
# jdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
jdbc.username=root
jdbc.password=
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2创建mybatis的核心配置文件mybatis-configxml&#34;&gt;②创建MyBatis的核心配置文件mybatis-config.xml&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;settings&amp;gt;
        &amp;lt;!--将表中字段的下划线自动转换为驼峰--&amp;gt;
        &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;!--开启延迟加载--&amp;gt;
        &amp;lt;setting name=&amp;quot;lazyLoadingEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;
    &amp;lt;!--设置类型别名--&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;package name=&amp;quot;com.atguigu.pojo&amp;quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;

    &amp;lt;plugins&amp;gt;
        &amp;lt;!--设置分页插件--&amp;gt;
        &amp;lt;plugin interceptor=&amp;quot;com.github.pagehelper.PageInterceptor&amp;quot;&amp;gt;
            &amp;lt;!--reasonable：分页合理化参数，默认值为false,直接根据参数进行查询。
              当该参数设置为 true 时，pageNum&amp;lt;=0 时会查询第一页， pageNum&amp;gt;pages（超过总数时），会查询最后一页。--&amp;gt;
            &amp;lt;property name=&amp;quot;reasonable&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;pageSizeZero&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;

    &amp;lt;!--引入映射文件--&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;!--        &amp;lt;mapper resource=&amp;quot;mybatisdemo/mappers/UserMapper.xml&amp;quot;/&amp;gt;--&amp;gt;
        &amp;lt;!--
        以包为单位，将包下所有的映射文件引入核心配置文件
        注意：
			1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下
			2. mapper接口要和mapper映射文件的名字一致
			&amp;lt;package name=&amp;quot;com.example.mybatis.mapper&amp;quot;/&amp;gt;
        --&amp;gt;
        &amp;lt;package name=&amp;quot;com.atguigu.mapper&amp;quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3创建mapper接口和映射文件&#34;&gt;③创建Mapper接口和映射文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface EmployeeMapper {
    List&amp;lt;Employee&amp;gt; getEmployeeList();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.atguigu.ssm.mapper.EmployeeMapper&amp;quot;&amp;gt;
    
    &amp;lt;select id=&amp;quot;getEmployeeList&amp;quot; resultType=&amp;quot;Employee&amp;quot;&amp;gt;
        select *
        from t_emp
    &amp;lt;/select&amp;gt;
    
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关于mapper映射文件的位置一般有两种写法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a. MyBatis映射文件存放的位置是src/main/resources/mappers目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;b. 将MyBatis映射文件存放到src/main/java同一目录下，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;此时需要在pom.xml中手动指定映射文件的存放位置，因为这样Maven才会编译这些xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
        &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在mybatis中配置映射文件的存放位置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;sqlSessionFactoryBean&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionFactoryBean&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;configLocation&amp;quot; value=&amp;quot;classpath:mybatis-config.xml&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;druidDataSource&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;!--
     设置映射文件的路径
     只有映射文件的包和mapper接口的包不一致时需要设置
     --&amp;gt;
    &amp;lt;property name=&amp;quot;mapperLocations&amp;quot; value=&amp;quot;classpath:com/xxxxx/mapper/xml/*.xml&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4创建日志文件log4jxml&#34;&gt;④创建日志文件log4j.xml&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE log4j:configuration SYSTEM &amp;quot;log4j.dtd&amp;quot;&amp;gt;
&amp;lt;log4j:configuration xmlns:log4j=&amp;quot;http://jakarta.apache.org/log4j/&amp;quot;&amp;gt;
    &amp;lt;appender name=&amp;quot;STDOUT&amp;quot; class=&amp;quot;org.apache.log4j.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;param name=&amp;quot;Encoding&amp;quot; value=&amp;quot;UTF-8&amp;quot;/&amp;gt;
        &amp;lt;layout class=&amp;quot;org.apache.log4j.PatternLayout&amp;quot;&amp;gt;
            &amp;lt;param name=&amp;quot;ConversionPattern&amp;quot; value=&amp;quot;%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \n&amp;quot;/&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;logger name=&amp;quot;java.sql&amp;quot;&amp;gt;
        &amp;lt;level value=&amp;quot;debug&amp;quot;/&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&amp;quot;org.apache.ibatis&amp;quot;&amp;gt;
        &amp;lt;level value=&amp;quot;info&amp;quot;/&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;root&amp;gt;
        &amp;lt;level value=&amp;quot;debug&amp;quot;/&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot;/&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/log4j:configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-创建spring的配置文件并配置&#34;&gt;6、创建Spring的配置文件并配置&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--扫描组件（除控制层）--&amp;gt;
&amp;lt;content:component-scan base-package=&amp;quot;com.atguigu&amp;quot;&amp;gt;
    &amp;lt;content:exclude-filter type=&amp;quot;annotation&amp;quot; expression=&amp;quot;org.springframework.stereotype.Controller&amp;quot;/&amp;gt;
&amp;lt;/content:component-scan&amp;gt;

&amp;lt;!-- 引入jdbc.properties --&amp;gt;
&amp;lt;content:property-placeholder location=&amp;quot;classpath:jdbc.properties&amp;quot;&amp;gt;&amp;lt;/content:property-placeholder&amp;gt;

&amp;lt;!-- 配置Druid数据源 --&amp;gt;
&amp;lt;bean id=&amp;quot;dataSource&amp;quot; class=&amp;quot;com.alibaba.druid.pool.DruidDataSource&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!-- 配置用于创建SqlSessionFactory的工厂bean，可以直接在Spring的IOC中获取SqlSessionFactory --&amp;gt;
&amp;lt;bean class=&amp;quot;org.mybatis.spring.SqlSessionFactoryBean&amp;quot;&amp;gt;
    &amp;lt;!-- 设置MyBatis核心配置文件的路径（可以不设置） --&amp;gt;
    &amp;lt;property name=&amp;quot;configLocation&amp;quot; value=&amp;quot;classpath:mybatis-config.xml&amp;quot;&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!-- 设置数据源 --&amp;gt;
    &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;!--
     设置映射文件的路径
     只有映射文件的包和mapper接口的包不一致时需要设置
     --&amp;gt;
    &amp;lt;!--
    &amp;lt;property name=&amp;quot;mapperLocations&amp;quot; value=&amp;quot;classpath:mapper/*.xml&amp;quot;&amp;gt;
    &amp;lt;/property&amp;gt;
    --&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!--
    配置mapper接口的扫描
    可以将指定包下所有的mapper接口通过SqlSessionFactory创建动态代理实现类对象
    并将这些对象作为bean交给IOC容器管理
--&amp;gt;
&amp;lt;bean class=&amp;quot;org.mybatis.spring.mapper.MapperScannerConfigurer&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;basePackage&amp;quot; value=&amp;quot;com.atguigu.mapper&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!--配置事务管理器--&amp;gt;
&amp;lt;bean id=&amp;quot;transactionManager&amp;quot; class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!--
开启事务的注解驱动
通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务
--&amp;gt;
&amp;lt;!--
 transaction-manager属性的默认值是transactionManager，
 如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性
--&amp;gt;
&amp;lt;tx:annotation-driven transaction-manager=&amp;quot;transactionManager&amp;quot;&amp;gt;&amp;lt;/tx:annotation-driven&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-测试功能&#34;&gt;7、测试功能&lt;/h1&gt;
&lt;h2 id=&#34;1创建组件&#34;&gt;①创建组件&lt;/h2&gt;
&lt;p&gt;实体类Employee&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Employee {

    private Integer empId;
    private String empName;
    private Integer age;
    private String sex;
    private String email;

    public Employee() {
    }

    public Employee(Integer empId, String empName, Integer age, String sex, String email) {
        this.empId = empId;
        this.empName = empName;
        this.age = age;
        this.sex = sex;
        this.email = email;
    }

    public Integer getEmpId() {
        return empId;
    }

    public void setEmpId(Integer empId) {
        this.empId = empId;
    }

    public String getEmpName() {
        return empName;
    }

    public void setEmpName(String empName) {
        this.empName = empName;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return &amp;quot;Employee{&amp;quot; +
                &amp;quot;empId=&amp;quot; + empId +
                &amp;quot;, empName=&#39;&amp;quot; + empName + &#39;\&#39;&#39; +
                &amp;quot;, age=&amp;quot; + age +
                &amp;quot;, sex=&#39;&amp;quot; + sex + &#39;\&#39;&#39; +
                &amp;quot;, email=&#39;&amp;quot; + email + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建控制层组件EmployeeController&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class EmployeeController {
    @Autowired
    private EmployeeService employeeService;

    @RequestMapping(value = &amp;quot;/employee/page/{pageNum}&amp;quot;, method =
            RequestMethod.GET)
    public String getEmployeeList(Model model, @PathVariable(&amp;quot;pageNum&amp;quot;) Integer
            pageNum) {
        PageInfo&amp;lt;Employee&amp;gt; page = employeeService.getEmployeeList(pageNum);
        model.addAttribute(&amp;quot;page&amp;quot;, page);
        return &amp;quot;employee_list&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建接口EmployeeService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface EmployeeService {
    PageInfo&amp;lt;Employee&amp;gt; getEmployeeList(Integer pageNum);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建实现类EmployeeServiceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class EmployeeServiceImpl implements EmployeeService {
    @Autowired
    private EmployeeMapper employeeMapper;

    @Override
    public PageInfo&amp;lt;Employee&amp;gt; getEmployeeList(Integer pageNum) {
        PageHelper.startPage(pageNum, 4);
        List&amp;lt;Employee&amp;gt; list = employeeMapper.getEmployeeList();
        PageInfo&amp;lt;Employee&amp;gt; page = new PageInfo&amp;lt;&amp;gt;(list, 5);
        return page;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2创建页面&#34;&gt;②创建页面&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Employee Info&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; th:href=&amp;quot;@{/static/css/index_work.css}&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th colspan=&amp;quot;6&amp;quot;&amp;gt;Employee Info&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th&amp;gt;emp_id&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;emp_name&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;age&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;sex&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;email&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;options&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr th:each=&amp;quot;employee : ${page.list}&amp;quot;&amp;gt;
        &amp;lt;td th:text=&amp;quot;${employee.empId}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&amp;quot;${employee.empName}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&amp;quot;${employee.age}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&amp;quot;${employee.sex}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&amp;quot;${employee.email}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;
            &amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;delete&amp;lt;/a&amp;gt;
            &amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;update&amp;lt;/a&amp;gt;
        &amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td colspan=&amp;quot;6&amp;quot;&amp;gt;
             &amp;lt;span th:if=&amp;quot;${page.hasPreviousPage}&amp;quot;&amp;gt;
                    &amp;lt;a th:href=&amp;quot;@{/employee/page/1}&amp;quot;&amp;gt;首页&amp;lt;/a&amp;gt;
                    &amp;lt;a th:href=&amp;quot;@{&#39;/employee/page/&#39;+${page.prePage}}&amp;quot;&amp;gt;上一页&amp;lt;/a&amp;gt;
             &amp;lt;/span&amp;gt;
            &amp;lt;span th:each=&amp;quot;num : ${page.navigatepageNums}&amp;quot;&amp;gt;
                    &amp;lt;a th:if=&amp;quot;${page.pageNum==num}&amp;quot;
                       th:href=&amp;quot;@{&#39;/employee/page/&#39;+${num}}&amp;quot; th:text=&amp;quot;&#39;[&#39;+${num}+&#39;]&#39;&amp;quot; style=&amp;quot;color:
                    red;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
                    &amp;lt;a th:if=&amp;quot;${page.pageNum!=num}&amp;quot;
                       th:href=&amp;quot;@{&#39;/employee/page/&#39;+${num}}&amp;quot; th:text=&amp;quot;${num} &amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
            &amp;lt;/span&amp;gt;
            &amp;lt;span th:if=&amp;quot;${page.hasNextPage}&amp;quot;&amp;gt;
                    &amp;lt;a th:href=&amp;quot;@{&#39;/employee/page/&#39;+${page.nextPage}}&amp;quot;&amp;gt;下一页&amp;lt;/a&amp;gt;
                    &amp;lt;a th:href=&amp;quot;@{&#39;/employee/page/&#39;+${page.pages}}&amp;quot;&amp;gt;末页&amp;lt;/a&amp;gt;
            &amp;lt;/span&amp;gt;
        &amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3访问测试分页功能&#34;&gt;③访问测试分页功能&lt;/h2&gt;
&lt;p&gt;localhost:8080/employee/page/1&lt;/p&gt;
&lt;h1 id=&#34;8-加入druid监控&#34;&gt;8、加入Druid监控&lt;/h1&gt;
&lt;h2 id=&#34;1创建属性文件druidproperties&#34;&gt;①创建属性文件druid.properties&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#连接池建立时创建的初始化连接数
pool.init=1
#连接池中最小空闲连接数
pool.minIdle=3
#连接池中最大的活跃连接数
pool.maxActive=20
#定义最长等待时间
pool.maxWait=60000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2在spring配置文件中为druid数据源添加相应的属性&#34;&gt;②在Spring配置文件中为Druid数据源添加相应的属性&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 引入jdbc.properties和druid.properties --&amp;gt;
&amp;lt;content:property-placeholder location=&amp;quot;classpath:jdbc.properties,classpath:druid.properties&amp;quot;&amp;gt;&amp;lt;/content:property-placeholder&amp;gt;

&amp;lt;!-- 配置Druid数据源 --&amp;gt;
&amp;lt;bean id=&amp;quot;dataSource&amp;quot; class=&amp;quot;com.alibaba.druid.pool.DruidDataSource&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;!--数据源控制属性--&amp;gt;
    &amp;lt;!-- 配置初始化大小、最小、最大 --&amp;gt;
    &amp;lt;property name=&amp;quot;initialSize&amp;quot; value=&amp;quot;${pool.init}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;minIdle&amp;quot; value=&amp;quot;${pool.minIdle}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;maxActive&amp;quot; value=&amp;quot;${pool.maxActive}&amp;quot;/&amp;gt;
    &amp;lt;!-- 配置获取连接等待超时的时间 --&amp;gt;
    &amp;lt;property name=&amp;quot;maxWait&amp;quot; value=&amp;quot;${pool.maxWait}&amp;quot;/&amp;gt;
    &amp;lt;!-- 配置监控统计拦截的filters --&amp;gt;
    &amp;lt;property name=&amp;quot;filters&amp;quot; value=&amp;quot;stat&amp;quot;/&amp;gt;
    &amp;lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&amp;gt;
    &amp;lt;property name=&amp;quot;timeBetweenEvictionRunsMillis&amp;quot; value=&amp;quot;2000&amp;quot;/&amp;gt;
    &amp;lt;!--其他配置--&amp;gt;
    &amp;lt;property name=&amp;quot;minEvictableIdleTimeMillis&amp;quot; value=&amp;quot;300000&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;testWhileIdle&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;testOnBorrow&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;testOnReturn&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;poolPreparedStatements&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;maxOpenPreparedStatements&amp;quot; value=&amp;quot;20&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3在webxml中配置监控页面&#34;&gt;③在web.xml中配置监控页面&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- druid监控配置--&amp;gt;
&amp;lt;!-- 参考文档：https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE --&amp;gt;
&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;DruidStatView&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.alibaba.druid.support.http.StatViewServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;!-- 允许清空统计数据 --&amp;gt;
        &amp;lt;param-name&amp;gt;resetEnable&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;!--配置访问监控页面登录的用户名和密码（可选），实际开发中都会配置--&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;!-- 用户名 --&amp;gt;
        &amp;lt;param-name&amp;gt;loginUsername&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;druid&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;!-- 密码 --&amp;gt;
        &amp;lt;param-name&amp;gt;loginPassword&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;druid&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
&amp;lt;/servlet&amp;gt;

&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;DruidStatView&amp;lt;/servlet-name&amp;gt;
    &amp;lt;!-- 访问监控页面的映射请求，实际访问一般都在浏览器输入http://xxx/druid/index --&amp;gt;
    &amp;lt;url-pattern&amp;gt;/druid/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">SSM整合</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/mac-she-zhi-java_home-huan-jing-bian-liang/"" data-c="
          &lt;h2 id=&#34;获取java的安装路径&#34;&gt;获取JAVA的安装路径&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这个命令可以用来显示电脑中安装的所有Java JDK&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/usr/libexec/java_home -V
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;添加java_home到profile&#34;&gt;添加JAVA_HOME到profile&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vi ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加如下环境配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# java
JAVA_HOME=&amp;quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home&amp;quot;
export JAVA_HOME
PATH=$PATH:$JAVA_HOME/bin
export PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;让配置生效&#34;&gt;让配置生效&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;echo $JAVA_HOME
&lt;/code&gt;&lt;/pre&gt;
">Mac设置JAVA_HOME环境变量</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/spring-bi-ji/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;视频课程链接：&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1Ya411S7aT?p=63&#34;&gt;🔗bilibili（新版）&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1Vf4y127N5&#34;&gt;🔗bilibili（旧版）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1-spring简介&#34;&gt;1、Spring简介&lt;/h1&gt;
&lt;h2 id=&#34;11-spring概述&#34;&gt;1.1、Spring概述&lt;/h2&gt;
&lt;p&gt;官网地址：https://spring.io/&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring 是&lt;code&gt;最受欢迎&lt;/code&gt;的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。&lt;/p&gt;
&lt;p&gt;Spring 框架是一个&lt;code&gt;开源&lt;/code&gt;的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首 次在 Apache 2.0 许可下发布。&lt;/p&gt;
&lt;p&gt;Spring 是&lt;code&gt;轻量级&lt;/code&gt;的框架，其基础版本只有 2 MB 左右的大小。&lt;/p&gt;
&lt;p&gt;Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;12-spring家族&#34;&gt;1.2、Spring家族&lt;/h2&gt;
&lt;p&gt;项目列表：https://spring.io/projects&lt;/p&gt;
&lt;h2 id=&#34;13-spring-framework&#34;&gt;1.3、Spring Framework&lt;/h2&gt;
&lt;p&gt;Spring 基础框架，可以视为 Spring 基础设施，基本上任何其他 Spring 项目都是以 Spring Framework 为基础的。&lt;/p&gt;
&lt;h3 id=&#34;131-spring-framework特性&#34;&gt;1.3.1、Spring Framework特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。&lt;/li&gt;
&lt;li&gt;控制反转：IOC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。&lt;/li&gt;
&lt;li&gt;面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。&lt;/li&gt;
&lt;li&gt;容器：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。&lt;/li&gt;
&lt;li&gt;组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。&lt;/li&gt;
&lt;li&gt;声明式：很多以前需要编写代码才能实现的功能，现在只需要声明需求即可由框架代为实现。&lt;/li&gt;
&lt;li&gt;一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;132-spring-framework五大功能模块&#34;&gt;1.3.2、Spring Framework五大功能模块&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能模块&lt;/th&gt;
&lt;th&gt;功能介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Core Container&lt;/td&gt;
&lt;td&gt;核心容器，在Spring环境下使用任何功能都必须基于IOC容器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AOP&amp;amp;Aspects&lt;/td&gt;
&lt;td&gt;面向切面编程。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Testing&lt;/td&gt;
&lt;td&gt;提供了对 junit 或 TestNG 测试框架的整合。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Data Access/Integration&lt;/td&gt;
&lt;td&gt;提供了对数据访问/集成的功能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring MVC&lt;/td&gt;
&lt;td&gt;提供了面向Web应用程序的集成功能&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;2-ioc&#34;&gt;2、IOC&lt;/h1&gt;
&lt;h2 id=&#34;21-ioc容器&#34;&gt;2.1、IOC容器&lt;/h2&gt;
&lt;h3 id=&#34;211-ioc思想&#34;&gt;2.1.1、IOC思想&lt;/h3&gt;
&lt;p&gt;IOC：Inversion of Control，翻译过来是&lt;strong&gt;反转控制&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;1获取资源的传统方式&#34;&gt;①获取资源的传统方式&lt;/h4&gt;
&lt;p&gt;自己做饭：买菜、洗菜、择菜、改刀、炒菜，全过程参与，费时费力，必须清楚了解资源创建整个过程中的全部细节且熟练掌握。&lt;/p&gt;
&lt;p&gt;在应用程序中的组件需要获取资源时，传统的方式是组件&lt;strong&gt;主动&lt;/strong&gt;的从容器中获取所需要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。&lt;/p&gt;
&lt;h4 id=&#34;2反转控制方式获取资源&#34;&gt;②反转控制方式获取资源&lt;/h4&gt;
&lt;p&gt;点外卖：下单、等、吃，省时省力，不必关心资源创建过程的所有细节。&lt;/p&gt;
&lt;p&gt;反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向———改由容器主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的&lt;strong&gt;被动&lt;/strong&gt;形式。&lt;/p&gt;
&lt;h4 id=&#34;3di&#34;&gt;③DI&lt;/h4&gt;
&lt;p&gt;DI：Dependency Injection，翻译过来是&lt;strong&gt;依赖注入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;DI 是 IOC 的另一种表述方式（实现方式）：即组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器的资源注入。相对于IOC而言，这种表述更直接。&lt;/p&gt;
&lt;p&gt;所以结论是：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种==&lt;strong&gt;具体实现&lt;/strong&gt;==。&lt;/p&gt;
&lt;h3 id=&#34;212-ioc容器在spring中的实现&#34;&gt;2.1.2、IOC容器在Spring中的实现&lt;/h3&gt;
&lt;p&gt;Spring 的 IOC 容器就是 IOC 思想的一个落地的产品实现。IOC 容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建 IOC 容器。Spring 提供了 IOC 容器的两种实现方式：&lt;/p&gt;
&lt;h4 id=&#34;1beanfactory&#34;&gt;①BeanFactory&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2applicationcontext&#34;&gt;②ApplicationContext&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;以后在 Spring 环境下看到一个类或接口的名称中包含 ApplicationContext，那基本就可以断定，这个类或接口与 IOC 容器有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;3applicationcontext的主要实现类&#34;&gt;③ApplicationContext的主要实现类&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721104046.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型名&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ClassPathXmlApplicationContext&lt;/td&gt;
&lt;td&gt;通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FileSystemXmlApplicationContext&lt;/td&gt;
&lt;td&gt;通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ConfigurableApplicationContext&lt;/td&gt;
&lt;td&gt;ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文（容器）的能力。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WebApplicationContext&lt;/td&gt;
&lt;td&gt;专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;22-基于xml管理bean&#34;&gt;2.2、基于XML管理bean&lt;/h2&gt;
&lt;h3 id=&#34;221-实验一创建bean&#34;&gt;2.2.1、实验一：创建bean&lt;/h3&gt;
&lt;h4 id=&#34;1创建maven-module&#34;&gt;①创建Maven Module&lt;/h4&gt;
&lt;h4 id=&#34;2引入依赖&#34;&gt;②引入依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- junit测试 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721105410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;3创建类helloworld&#34;&gt;③创建类HelloWorld&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.atguigu.spring.pojo;

public class HelloWorld {
    public void sayHello() {
        System.out.println(&amp;quot;Hello Spring&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4创建spring的配置文件&#34;&gt;④创建Spring的配置文件&lt;/h4&gt;
&lt;p&gt;applicationContext.xml&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721110013.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721110038.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;5在spring的配置文件中配置bean&#34;&gt;⑤在Spring的配置文件中配置bean&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
		配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理
		通过bean标签配置IOC容器所管理的bean
		属性：
				id：设置bean的唯一标识
				class：设置bean所对应类型的全类名
--&amp;gt;
&amp;lt;bean id=&amp;quot;helloworld&amp;quot; class=&amp;quot;com.atguigu.spring.bean.HelloWorld&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;6创建测试类测试&#34;&gt;⑥创建测试类测试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testHelloWorld() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);
    HelloWorld helloWorld = ioc.getBean(HelloWorld.class);
    helloWorld.sayHello();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;7思路&#34;&gt;⑦思路&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721112410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;8注意&#34;&gt;⑧注意&lt;/h4&gt;
&lt;p&gt;Spring 底层默认通过反射技术调用组件类的无参构造器来创建组件对象，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出下面的异常：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;helloworld&#39; defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.atguigu.spring.bean.HelloWorld]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.atguigu.spring.bean.HelloWorld. ()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;222-实验二获取bean&#34;&gt;2.2.2、实验二：获取bean&lt;/h3&gt;
&lt;h4 id=&#34;1方式一根据id获取&#34;&gt;①方式一：根据id获取&lt;/h4&gt;
&lt;p&gt;由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。&lt;/p&gt;
&lt;h4 id=&#34;2方式二根据类型获取&#34;&gt;②方式二：根据类型获取&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testHelloWorld() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);
    HelloWorld bean = ioc.getBean(HelloWorld.class);
    bean.sayHello();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3方式三根据id和类型&#34;&gt;③方式三：根据id和类型&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testHelloWorld() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);
    HelloWorld bean = ioc.getBean(&amp;quot;helloworld&amp;quot;, HelloWorld.class);
    bean.sayHello();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4注意&#34;&gt;④注意&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当IOC容器中一共配置了两个：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;helloworldOne&amp;quot; class=&amp;quot;com.atguigu.spring.bean.HelloWorld&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;helloworldTwo&amp;quot; class=&amp;quot;com.atguigu.spring.bean.HelloWorld&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据类型获取时会抛出异常：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.atguigu.spring.bean.HelloWorld&#39; available: expected single matching bean but found 2: helloworldOne,helloworldTwo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5扩展&#34;&gt;⑤扩展&lt;/h4&gt;
&lt;p&gt;如果组件类实现了接口，根据接口类型可以获取组件类 bean 吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以，前提是bean唯一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取实现类 bean 吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不行，因为bean不唯一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个父类只有一个子类，根据父类类型可以获取子类 bean 吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以，前提是bean唯一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个父类有多个子类，根据父类类型可以子类获取 bean 吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不行，因为bean不唯一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;6结论&#34;&gt;⑥结论&lt;/h4&gt;
&lt;p&gt;根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 &lt;strong&gt;instanceof&lt;/strong&gt; 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。&lt;/p&gt;
&lt;h3 id=&#34;223-实验三依赖注入之setter注入&#34;&gt;2.2.3、实验三：依赖注入之setter注入&lt;/h3&gt;
&lt;h4 id=&#34;1创建学生类student&#34;&gt;①创建学生类Student&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Student {
    
    private Integer id;
    private String name;
    private Integer age;
    private String sex;

    public Student() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return &amp;quot;Student{&amp;quot; +
                &amp;quot;id=&amp;quot; + id +
                &amp;quot;, name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &amp;quot;, age=&amp;quot; + age +
                &amp;quot;, sex=&#39;&amp;quot; + sex + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2配置bean时为属性赋值&#34;&gt;②配置bean时为属性赋值&lt;/h4&gt;
&lt;p&gt;spring-di.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt; &amp;lt;bean id=&amp;quot;studentOne&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Student&amp;quot;&amp;gt;
     &amp;lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&amp;gt;
     &amp;lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关）
     --&amp;gt;
     &amp;lt;!-- value属性：指定属性值 --&amp;gt;
     &amp;lt;property name=&amp;quot;id&amp;quot; value=&amp;quot;1001&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
     &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;张三&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
     &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;23&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
     &amp;lt;property name=&amp;quot;sex&amp;quot; value=&amp;quot;男&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
 &amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3测试&#34;&gt;③测试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testDIBySet() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;spring-di.xml&amp;quot;);
    Student studentOne = ioc.getBean(&amp;quot;studentOne&amp;quot;, Student.class);
    System.out.println(studentOne);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;224-实验四依赖注入之构造器注入&#34;&gt;2.2.4、实验四：依赖注入之构造器注入&lt;/h3&gt;
&lt;h4 id=&#34;1在student类中添加有参构造&#34;&gt;①在Student类中添加有参构造&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Student(Integer id, String name, Integer age, String sex) {
    this.id = id;
    this.name = name;
    this.age = age;
    this.sex = sex;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2配置bean&#34;&gt;②配置bean&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;studentTwo&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Student&amp;quot;&amp;gt;
    &amp;lt;constructor-arg value=&amp;quot;1002&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;constructor-arg value=&amp;quot;李四&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;constructor-arg value=&amp;quot;33&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;constructor-arg value=&amp;quot;女&amp;quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;constructor-arg标签还有两个属性可以进一步描述构造器参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;index属性：指定参数所在位置的索引（从0开始）&lt;/li&gt;
&lt;li&gt;name属性：指定参数名&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;3测试-2&#34;&gt;③测试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testDIBySet() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;spring-di.xml&amp;quot;);
    Student studentOne = ioc.getBean(&amp;quot;studentTwo&amp;quot;, Student.class);
    System.out.println(studentOne);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;225-实验五特殊值处理&#34;&gt;2.2.5、实验五：特殊值处理&lt;/h3&gt;
&lt;h4 id=&#34;1字面量赋值&#34;&gt;①字面量赋值&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是字面量？ (基本类型变量)&lt;/p&gt;
&lt;p&gt;int a = 10;&lt;/p&gt;
&lt;p&gt;声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。（这里10就是字面量）&lt;/p&gt;
&lt;p&gt;而如果a是带引号的：&#39;a&#39;，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&amp;gt;
&amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;张三&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2null值&#34;&gt;②null值&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt; &amp;lt;property name=&amp;quot;name&amp;quot;&amp;gt;
     &amp;lt;null/&amp;gt;
 &amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;null&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上写法，为name所赋的值是字符串null&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;3xml实体&#34;&gt;③xml实体&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&amp;gt;
&amp;lt;!-- 解决方案一：使用XML实体来代替 --&amp;gt;
&amp;lt;property name=&amp;quot;expression&amp;quot; value=&amp;quot;a &amp;amp;lt; b&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4cdata节&#34;&gt;④CDATA节&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;property name=&amp;quot;expression&amp;quot;&amp;gt;
		&amp;lt;!-- 解决方案二：使用CDATA节 --&amp;gt;
		&amp;lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&amp;gt;
		&amp;lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&amp;gt;
		&amp;lt;!-- 所以CDATA节中写什么符号都随意 --&amp;gt;
&amp;lt;value&amp;gt;&amp;lt;![CDATA[a &amp;lt; b]]&amp;gt;&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;226-实验六为类类型属性赋值&#34;&gt;2.2.6、实验六：为类类型属性赋值&lt;/h3&gt;
&lt;h4 id=&#34;1创建班级类clazz&#34;&gt;①创建班级类Clazz&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Clazz {
    private Integer clazzId;
    private String clazzName;

    public Integer getClazzId() {
        return clazzId;
    }

    public void setClazzId(Integer clazzId) {
        this.clazzId = clazzId;
    }

    public String getClazzName() {
        return clazzName;
    }

    public void setClazzName(String clazzName) {
        this.clazzName = clazzName;
    }

    @Override
    public String toString() {
        return &amp;quot;Clazz{&amp;quot; +
                &amp;quot;clazzId=&amp;quot; + clazzId +
                &amp;quot;, clazzName=&#39;&amp;quot; + clazzName + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }

    public Clazz() {
    }

    public Clazz(Integer clazzId, String clazzName) {
        this.clazzId = clazzId;
        this.clazzName = clazzName;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2修改student类&#34;&gt;②修改Student类&lt;/h4&gt;
&lt;p&gt;在Student类中添加以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Clazz clazz;
public Clazz getClazz() {
    return clazz;
}
public void setClazz(Clazz clazz) {
    this.clazz = clazz;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3方式一引用外部已声明的bean&#34;&gt;③方式一：引用外部已声明的bean&lt;/h4&gt;
&lt;p&gt;配置Clazz类型的bean：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;clazzOne&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Clazz&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;clazzId&amp;quot; value=&amp;quot;1111&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;clazzName&amp;quot; value=&amp;quot;财源滚滚班&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为Student中的clazz属性赋值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;studentFour&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Student&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;id&amp;quot; value=&amp;quot;1004&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;赵六&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;26&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;sex&amp;quot; value=&amp;quot;女&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&amp;gt;
    &amp;lt;property name=&amp;quot;clazz&amp;quot; ref=&amp;quot;clazzOne&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误演示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;studentFour&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Student&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;id&amp;quot; value=&amp;quot;1004&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;赵六&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;26&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;sex&amp;quot; value=&amp;quot;女&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;clazz&amp;quot; value=&amp;quot;clazzOne&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type &#39;java.lang.String&#39; to required type &#39;com.atguigu.spring.bean.Clazz&#39; for property &#39;clazz&#39;: no matching editors or conversion strategy found 意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;4方式二内部bean&#34;&gt;④方式二：内部bean&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;studentFour&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Student&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;id&amp;quot; value=&amp;quot;1004&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;赵六&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;26&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;sex&amp;quot; value=&amp;quot;女&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;clazz&amp;quot;&amp;gt;
        &amp;lt;!-- 在一个bean中再声明一个bean就是内部bean --&amp;gt;
        &amp;lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&amp;gt;
        &amp;lt;bean id=&amp;quot;clazzInner&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Clazz&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;clazzId&amp;quot; value=&amp;quot;2222&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
            &amp;lt;property name=&amp;quot;clazzName&amp;quot; value=&amp;quot;远大前程班&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3方式三级联属性赋值&#34;&gt;③方式三：级联属性赋值&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;studentFour&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Student&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;id&amp;quot; value=&amp;quot;1004&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;赵六&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;26&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;sex&amp;quot; value=&amp;quot;女&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;!-- 级联的方式，要保证提前为clazz属性赋值或者实例化 --&amp;gt;
    &amp;lt;!-- 所以这种方式相当于修改，一般不用级联赋值 --&amp;gt;
    &amp;lt;property name=&amp;quot;clazz&amp;quot; ref=&amp;quot;clazzOne&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;clazz.clazzId&amp;quot; value=&amp;quot;3333&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;clazz.clazzName&amp;quot; value=&amp;quot;最强王者班&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;227-实验七为数组类型属性赋值&#34;&gt;2.2.7、实验七：为数组类型属性赋值&lt;/h3&gt;
&lt;h4 id=&#34;1修改student类&#34;&gt;①修改Student类&lt;/h4&gt;
&lt;p&gt;在Student类中添加以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private String[] hobbies;
public String[] getHobbies() {
    return hobbies;
}
public void setHobbies(String[] hobbies) {
    this.hobbies = hobbies;

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2配置bean-2&#34;&gt;②配置bean&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;studentFour&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Student&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;id&amp;quot; value=&amp;quot;1004&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;赵六&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;26&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;sex&amp;quot; value=&amp;quot;女&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&amp;gt;
    &amp;lt;property name=&amp;quot;clazz&amp;quot; ref=&amp;quot;clazzOne&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;hobbies&amp;quot;&amp;gt;
        &amp;lt;array&amp;gt;
            &amp;lt;value&amp;gt;抽烟&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;喝酒&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;烫头&amp;lt;/value&amp;gt;
        &amp;lt;/array&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;228-实验八为集合类型属性赋值&#34;&gt;2.2.8、实验八：为集合类型属性赋值&lt;/h3&gt;
&lt;h4 id=&#34;1为list集合类型属性赋值&#34;&gt;①为List集合类型属性赋值&lt;/h4&gt;
&lt;p&gt;在Clazz类中添加以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private List&amp;lt;Student&amp;gt; students;
public List&amp;lt;Student&amp;gt; getStudents() {
    return students;
}
public void setStudents(List&amp;lt;Student&amp;gt; students) {
    this.students = students;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置bean：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;clazzTwo&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Clazz&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;clazzId&amp;quot; value=&amp;quot;4444&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;clazzName&amp;quot; value=&amp;quot;Javaee0222&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;students&amp;quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;ref bean=&amp;quot;studentOne&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
            &amp;lt;ref bean=&amp;quot;studentTwo&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
            &amp;lt;ref bean=&amp;quot;studentThree&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;2为map集合类型属性赋值&#34;&gt;②为Map集合类型属性赋值&lt;/h4&gt;
&lt;p&gt;创建教师类Teacher：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Teacher {
    private Integer teacherId;

    private String teacherName;

    public Teacher() {
    }

    public Teacher(Integer teacherId, String teacherName) {
        this.teacherId = teacherId;
        this.teacherName = teacherName;
    }

    public Integer getTeacherId() {
        return teacherId;
    }

    public void setTeacherId(Integer teacherId) {
        this.teacherId = teacherId;
    }

    public String getTeacherName() {
        return teacherName;
    }

    public void setTeacherName(String teacherName) {
        this.teacherName = teacherName;
    }

    @Override
    public String toString() {
        return &amp;quot;Teacher{&amp;quot; +
                &amp;quot;teacherId=&amp;quot; + teacherId +
                &amp;quot;, teacherName=&#39;&amp;quot; + teacherName + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Student类中添加以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Map&amp;lt;String, Teacher&amp;gt; teacherMap;
public Map&amp;lt;String, Teacher&amp;gt; getTeacherMap() {
    return teacherMap;
}
public void setTeacherMap(Map&amp;lt;String, Teacher&amp;gt; teacherMap) {
    this.teacherMap = teacherMap;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置bean：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;teacherOne&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Teacher&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;teacherId&amp;quot; value=&amp;quot;10010&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;teacherName&amp;quot; value=&amp;quot;大宝&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;teacherTwo&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Teacher&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;teacherId&amp;quot; value=&amp;quot;10086&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;teacherName&amp;quot; value=&amp;quot;二宝&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;studentFour&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Student&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;id&amp;quot; value=&amp;quot;1004&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;赵六&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;26&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;sex&amp;quot; value=&amp;quot;女&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&amp;gt;
    &amp;lt;property name=&amp;quot;clazz&amp;quot; ref=&amp;quot;clazzOne&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;hobbies&amp;quot;&amp;gt;
        &amp;lt;array&amp;gt;
            &amp;lt;value&amp;gt;抽烟&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;喝酒&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;烫头&amp;lt;/value&amp;gt;
        &amp;lt;/array&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;teacherMap&amp;quot;&amp;gt;
        &amp;lt;map&amp;gt;
            &amp;lt;entry&amp;gt;
                &amp;lt;key&amp;gt;
                    &amp;lt;value&amp;gt;10010&amp;lt;/value&amp;gt;
                &amp;lt;/key&amp;gt;
                &amp;lt;ref bean=&amp;quot;teacherOne&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
            &amp;lt;/entry&amp;gt;
            &amp;lt;entry&amp;gt;
                &amp;lt;key&amp;gt;
                    &amp;lt;value&amp;gt;10086&amp;lt;/value&amp;gt;
                &amp;lt;/key&amp;gt;
                &amp;lt;ref bean=&amp;quot;teacherTwo&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
            &amp;lt;/entry&amp;gt;
        &amp;lt;/map&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3引用集合类型的bean&#34;&gt;③引用集合类型的bean&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--list集合类型的bean--&amp;gt;
&amp;lt;util:list id=&amp;quot;students&amp;quot;&amp;gt;
    &amp;lt;ref bean=&amp;quot;studentOne&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
    &amp;lt;ref bean=&amp;quot;studentTwo&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
    &amp;lt;ref bean=&amp;quot;studentThree&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
&amp;lt;/util:list&amp;gt;
&amp;lt;!--map集合类型的bean--&amp;gt;
&amp;lt;util:map id=&amp;quot;teacherMap&amp;quot;&amp;gt;
    &amp;lt;entry&amp;gt;
        &amp;lt;key&amp;gt;
            &amp;lt;value&amp;gt;10010&amp;lt;/value&amp;gt;
        &amp;lt;/key&amp;gt;
        &amp;lt;ref bean=&amp;quot;teacherOne&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
    &amp;lt;/entry&amp;gt;
    &amp;lt;entry&amp;gt;
        &amp;lt;key&amp;gt;
            &amp;lt;value&amp;gt;10086&amp;lt;/value&amp;gt;
        &amp;lt;/key&amp;gt;
        &amp;lt;ref bean=&amp;quot;teacherTwo&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
    &amp;lt;/entry&amp;gt;
&amp;lt;/util:map&amp;gt;
&amp;lt;bean id=&amp;quot;clazzTwo&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Clazz&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;clazzId&amp;quot; value=&amp;quot;4444&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;clazzName&amp;quot; value=&amp;quot;Javaee0222&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;students&amp;quot; ref=&amp;quot;students&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&amp;quot;studentFour&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Student&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;id&amp;quot; value=&amp;quot;1004&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;赵六&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;26&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;sex&amp;quot; value=&amp;quot;女&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&amp;gt;
    &amp;lt;property name=&amp;quot;clazz&amp;quot; ref=&amp;quot;clazzOne&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;hobbies&amp;quot;&amp;gt;
        &amp;lt;array&amp;gt;
            &amp;lt;value&amp;gt;抽烟&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;喝酒&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;烫头&amp;lt;/value&amp;gt;
        &amp;lt;/array&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;teacherMap&amp;quot; ref=&amp;quot;teacherMap&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;使用util:list、util:map标签必须引入相应的命名空间，可以通过idea的提示功能选择&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;229-实验九依赖注入之p命名空间&#34;&gt;2.2.9、实验九：依赖注入之p命名空间&lt;/h3&gt;
&lt;p&gt;引入p命名空间后，可以通过以下方式为bean的各个属性赋值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;studentSix&amp;quot; class=&amp;quot;com.atguigu.spring.bean.Student&amp;quot;
		p:id=&amp;quot;1006&amp;quot; p:name=&amp;quot;小明&amp;quot; p:clazz-ref=&amp;quot;clazzOne&amp;quot; p:teacherMapref=&amp;quot;teacherMap&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2210-实验十引入外部属性文件&#34;&gt;2.2.10、实验十：引入外部属性文件&lt;/h3&gt;
&lt;h4 id=&#34;1加入依赖&#34;&gt;①加入依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- MySQL驱动 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;8.0.16&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- 数据源 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.31&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2创建外部属性文件&#34;&gt;②创建外部属性文件&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721151535.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/ssm?characterEncoding=utf8&amp;amp;useUnicode=true
jdbc.username=root
jdbc.password=
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3引入属性文件&#34;&gt;③引入属性文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 引入外部属性文件 --&amp;gt;
&amp;lt;context:property-placeholder location=&amp;quot;classpath:jdbc.properties&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4配置bean&#34;&gt;④配置bean&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 配置数据源 --&amp;gt;
&amp;lt;bean id=&amp;quot;druidDataSource&amp;quot; class=&amp;quot;com.alibaba.druid.pool.DruidDataSource&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5测试&#34;&gt;⑤测试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testDataSource() throws SQLException {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;springdatasource.xml&amp;quot;);
    DataSource dataSource = ioc.getBean(DataSource.class);
    Connection connection = dataSource.getConnection();
    System.out.println(connection);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2211-实验十一bean的作用域&#34;&gt;2.2.11、实验十一：bean的作用域&lt;/h3&gt;
&lt;h4 id=&#34;1概念&#34;&gt;①概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;取值&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;创建对象的时机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;singleton（默认）&lt;/td&gt;
&lt;td&gt;在IOC容器中，这个bean的对象始终为单实例&lt;/td&gt;
&lt;td&gt;IOC容器初始化时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;prototype&lt;/td&gt;
&lt;td&gt;这个bean在IOC容器中有多个实例&lt;/td&gt;
&lt;td&gt;获取bean时&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;如果是在WebApplicationContext环境下还会有另外三个作用域（但不常用）：&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;取值&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;request&lt;/td&gt;
&lt;td&gt;在一个请求范围内有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;session&lt;/td&gt;
&lt;td&gt;在一个会话范围内有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;global-session&lt;/td&gt;
&lt;td&gt;一般用于Portlet应用环境&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;Portlet是可以复用的Web模块,用于管理和显示用户界面。&lt;/p&gt;
&lt;p&gt;各作用域范围大小对比&lt;br&gt;
prototype &amp;lt; request &amp;lt; session &amp;lt; global-session &amp;lt; singleton&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;2创建类user&#34;&gt;②创建类User&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
    
    private Integer id;
    private String username;
    private String password;
    private Integer age;

    public User() {
    }

    public User(Integer id, String username, String password, Integer age) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.age = age;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &amp;quot;User{&amp;quot; +
                &amp;quot;id=&amp;quot; + id +
                &amp;quot;, username=&#39;&amp;quot; + username + &#39;\&#39;&#39; +
                &amp;quot;, password=&#39;&amp;quot; + password + &#39;\&#39;&#39; +
                &amp;quot;, age=&amp;quot; + age +
                &#39;}&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3配置bean&#34;&gt;③配置bean&lt;/h4&gt;
&lt;p&gt;springscope.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&amp;gt;
&amp;lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&amp;gt;
&amp;lt;bean class=&amp;quot;com.atguigu.bean.User&amp;quot; scope=&amp;quot;prototype&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4测试&#34;&gt;④测试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testBeanScope() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;springscope.xml&amp;quot;);
    User user1 = ioc.getBean(User.class);
    User user2 = ioc.getBean(User.class);
    System.out.println(user1 == user2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2212-实验十二bean的生命周期&#34;&gt;2.2.12、实验十二：bean的生命周期&lt;/h3&gt;
&lt;h4 id=&#34;1具体的生命周期过程&#34;&gt;①具体的生命周期过程&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;bean对象创建（调用无参构造器）&lt;/li&gt;
&lt;li&gt;给bean对象设置属性&lt;/li&gt;
&lt;li&gt;bean对象初始化之前操作（由bean的后置处理器负责）&lt;/li&gt;
&lt;li&gt;bean对象初始化（需在配置bean时指定初始化方法）&lt;/li&gt;
&lt;li&gt;bean对象初始化之后操作（由bean的后置处理器负责）&lt;/li&gt;
&lt;li&gt;bean对象就绪可以使用&lt;/li&gt;
&lt;li&gt;bean对象销毁（需在配置bean时指定销毁方法）&lt;/li&gt;
&lt;li&gt;IOC容器关闭&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2修改类user&#34;&gt;②修改类User&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
    private Integer id;
    private String username;
    private String password;
    private Integer age;

    public User() {
        System.out.println(&amp;quot;生命周期：1、创建对象&amp;quot;);
    }

    public User(Integer id, String username, String password, Integer age) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.age = age;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        System.out.println(&amp;quot;生命周期：2、依赖注入&amp;quot;);
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public void initMethod() {
        System.out.println(&amp;quot;生命周期：3、初始化&amp;quot;);
    }

    public void destroyMethod() {
        System.out.println(&amp;quot;生命周期：5、销毁&amp;quot;);
    }

    @Override
    public String toString() {
        return &amp;quot;User{&amp;quot; +
                &amp;quot;id=&amp;quot; + id +
                &amp;quot;, username=&#39;&amp;quot; + username + &#39;\&#39;&#39; +
                &amp;quot;, password=&#39;&amp;quot; + password + &#39;\&#39;&#39; +
                &amp;quot;, age=&amp;quot; + age +
                &#39;}&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;3配置bean-2&#34;&gt;③配置bean&lt;/h4&gt;
&lt;p&gt;spring-lifecycle.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 使用init-method属性指定初始化方法 --&amp;gt;
&amp;lt;!-- 使用destroy-method属性指定销毁方法 --&amp;gt;
&amp;lt;bean class=&amp;quot;com.atguigu.bean.User&amp;quot; scope=&amp;quot;prototype&amp;quot; init-method=&amp;quot;initMethod&amp;quot;
destroy-method=&amp;quot;destroyMethod&amp;quot;&amp;gt;
		&amp;lt;property name=&amp;quot;id&amp;quot; value=&amp;quot;1001&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
		&amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;admin&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
		&amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;123456&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
		&amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;23&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4测试-2&#34;&gt;④测试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testLife() {
    ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;spring-lifecycle.xml&amp;quot;);
    User bean = ioc.getBean(User.class);
    System.out.println(&amp;quot;生命周期：4、通过IOC容器获取bean并使用&amp;quot;);
    ioc.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5bean的后置处理器&#34;&gt;⑤bean的后置处理器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;bean的后置处理器会在生命周期的初始化前后添加额外的操作，&lt;/li&gt;
&lt;li&gt;需要实现BeanPostProcessor接口，且配置到IOC容器中，&lt;/li&gt;
&lt;li&gt;需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建bean的后置处理器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.atguigu.spring.process;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class MyBeanProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName)
            throws BeansException {
        System.out.println(&amp;quot;☆☆☆&amp;quot; + beanName + &amp;quot; = &amp;quot; + bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName)
            throws BeansException {
        System.out.println(&amp;quot;★★★&amp;quot; + beanName + &amp;quot; = &amp;quot; + bean);
        return bean;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在IOC容器中配置后置处理器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- bean的后置处理器要放入IOC容器才能生效 --&amp;gt;
&amp;lt;bean id=&amp;quot;myBeanProcessor&amp;quot; class=&amp;quot;com.atguigu.spring.process.MyBeanProcessor&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2213-实验十三factorybean&#34;&gt;2.2.13、实验十三：FactoryBean&lt;/h3&gt;
&lt;h4 id=&#34;1简介&#34;&gt;①简介&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FactoryBean是Spring提供的一种整合第三方框架的常用机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory;

import org.springframework.lang.Nullable;

/**
 * Interface to be implemented by objects used within a {@link BeanFactory} which
 * are themselves factories for individual objects. If a bean implements this
 * interface, it is used as a factory for an object to expose, not directly as a
 * bean instance that will be exposed itself.
 *
 * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;NB: A bean that implements this interface cannot be used as a normal bean.&amp;lt;/b&amp;gt;
 * A FactoryBean is defined in a bean style, but the object exposed for bean
 * references ({@link #getObject()}) is always the object that it creates.
 *
 * &amp;lt;p&amp;gt;FactoryBeans can support singletons and prototypes, and can either create
 * objects lazily on demand or eagerly on startup. The {@link SmartFactoryBean}
 * interface allows for exposing more fine-grained behavioral metadata.
 *
 * &amp;lt;p&amp;gt;This interface is heavily used within the framework itself, for example for
 * the AOP {@link org.springframework.aop.framework.ProxyFactoryBean} or the
 * {@link org.springframework.jndi.JndiObjectFactoryBean}. It can be used for
 * custom components as well; however, this is only common for infrastructure code.
 *
 * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;{@code FactoryBean} is a programmatic contract. Implementations are not
 * supposed to rely on annotation-driven injection or other reflective facilities.&amp;lt;/b&amp;gt;
 * {@link #getObjectType()} {@link #getObject()} invocations may arrive early in the
 * bootstrap process, even ahead of any post-processor setup. If you need access to
 * other beans, implement {@link BeanFactoryAware} and obtain them programmatically.
 *
 * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;The container is only responsible for managing the lifecycle of the FactoryBean
 * instance, not the lifecycle of the objects created by the FactoryBean.&amp;lt;/b&amp;gt; Therefore,
 * a destroy method on an exposed bean object (such as {@link java.io.Closeable#close()}
 * will &amp;lt;i&amp;gt;not&amp;lt;/i&amp;gt; be called automatically. Instead, a FactoryBean should implement
 * {@link DisposableBean} and delegate any such close call to the underlying object.
 *
 * &amp;lt;p&amp;gt;Finally, FactoryBean objects participate in the containing BeanFactory&#39;s
 * synchronization of bean creation. There is usually no need for internal
 * synchronization other than for purposes of lazy initialization within the
 * FactoryBean itself (or the like).
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @since 08.03.2003
 * @param &amp;lt;T&amp;gt; the bean type
 * @see org.springframework.beans.factory.BeanFactory
 * @see org.springframework.aop.framework.ProxyFactoryBean
 * @see org.springframework.jndi.JndiObjectFactoryBean
 */
public interface FactoryBean&amp;lt;T&amp;gt; {

	/**
	 * The name of an attribute that can be
	 * {@link org.springframework.core.AttributeAccessor#setAttribute set} on a
	 * {@link org.springframework.beans.factory.config.BeanDefinition} so that
	 * factory beans can signal their object type when it can&#39;t be deduced from
	 * the factory bean class.
	 * @since 5.2
	 */
	String OBJECT_TYPE_ATTRIBUTE = &amp;quot;factoryBeanObjectType&amp;quot;;


	/**
	 * Return an instance (possibly shared or independent) of the object
	 * managed by this factory.
	 * &amp;lt;p&amp;gt;As with a {@link BeanFactory}, this allows support for both the
	 * Singleton and Prototype design pattern.
	 * &amp;lt;p&amp;gt;If this FactoryBean is not fully initialized yet at the time of
	 * the call (for example because it is involved in a circular reference),
	 * throw a corresponding {@link FactoryBeanNotInitializedException}.
	 * &amp;lt;p&amp;gt;As of Spring 2.0, FactoryBeans are allowed to return {@code null}
	 * objects. The factory will consider this as normal value to be used; it
	 * will not throw a FactoryBeanNotInitializedException in this case anymore.
	 * FactoryBean implementations are encouraged to throw
	 * FactoryBeanNotInitializedException themselves now, as appropriate.
	 * @return an instance of the bean (can be {@code null})
	 * @throws Exception in case of creation errors
	 * @see FactoryBeanNotInitializedException
	 */
	@Nullable
	T getObject() throws Exception;

	/**
	 * Return the type of object that this FactoryBean creates,
	 * or {@code null} if not known in advance.
	 * &amp;lt;p&amp;gt;This allows one to check for specific types of beans without
	 * instantiating objects, for example on autowiring.
	 * &amp;lt;p&amp;gt;In the case of implementations that are creating a singleton object,
	 * this method should try to avoid singleton creation as far as possible;
	 * it should rather estimate the type in advance.
	 * For prototypes, returning a meaningful type here is advisable too.
	 * &amp;lt;p&amp;gt;This method can be called &amp;lt;i&amp;gt;before&amp;lt;/i&amp;gt; this FactoryBean has
	 * been fully initialized. It must not rely on state created during
	 * initialization; of course, it can still use such state if available.
	 * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; Autowiring will simply ignore FactoryBeans that return
	 * {@code null} here. Therefore it is highly recommended to implement
	 * this method properly, using the current state of the FactoryBean.
	 * @return the type of object that this FactoryBean creates,
	 * or {@code null} if not known at the time of the call
	 * @see ListableBeanFactory#getBeansOfType
	 */
	@Nullable
	Class&amp;lt;?&amp;gt; getObjectType();

	/**
	 * Is the object managed by this factory a singleton? That is,
	 * will {@link #getObject()} always return the same object
	 * (a reference that can be cached)?
	 * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; If a FactoryBean indicates to hold a singleton object,
	 * the object returned from {@code getObject()} might get cached
	 * by the owning BeanFactory. Hence, do not return {@code true}
	 * unless the FactoryBean always exposes the same reference.
	 * &amp;lt;p&amp;gt;The singleton status of the FactoryBean itself will generally
	 * be provided by the owning BeanFactory; usually, it has to be
	 * defined as singleton there.
	 * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; This method returning {@code false} does not
	 * necessarily indicate that returned objects are independent instances.
	 * An implementation of the extended {@link SmartFactoryBean} interface
	 * may explicitly indicate independent instances through its
	 * {@link SmartFactoryBean#isPrototype()} method. Plain {@link FactoryBean}
	 * implementations which do not implement this extended interface are
	 * simply assumed to always return independent instances if the
	 * {@code isSingleton()} implementation returns {@code false}.
	 * &amp;lt;p&amp;gt;The default implementation returns {@code true}, since a
	 * {@code FactoryBean} typically manages a singleton instance.
	 * @return whether the exposed object is a singleton
	 * @see #getObject()
	 * @see SmartFactoryBean#isPrototype()
	 */
	default boolean isSingleton() {
		return true;
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2创建类userfactorybean&#34;&gt;②创建类UserFactoryBean&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserFactoryBean implements FactoryBean&amp;lt;User&amp;gt; {
    @Override
    public User getObject() throws Exception {
        return new User();
    }

    @Override
    public Class&amp;lt;?&amp;gt; getObjectType() {
        return User.class;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3配置bean-3&#34;&gt;③配置bean&lt;/h4&gt;
&lt;p&gt;springfactorybean.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;user&amp;quot; class=&amp;quot;com.atguigu.bean.UserFactoryBean&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4测试-3&#34;&gt;④测试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testUserFactoryBean() {
    //获取IOC容器
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;springfactorybean.xml&amp;quot;);
    User user = (User) ioc.getBean(&amp;quot;user&amp;quot;);
    System.out.println(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2214-实验十四基于xml的自动装配&#34;&gt;2.2.14、实验十四：基于xml的自动装配&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;自动装配：&lt;/p&gt;
&lt;p&gt;根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;1场景模拟&#34;&gt;①场景模拟&lt;/h4&gt;
&lt;p&gt;创建类UserController&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserController {
    private UserService userService;

    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public void saveUser() {
        userService.saveUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建接口UserService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {
    
    void saveUser();
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建类UserServiceImpl实现接口UserService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserServiceImpl implements UserService {
    private UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void saveUser() {
        userDao.saveUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建接口UserDao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserDao {

    void saveUser();
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建类UserDaoImpl实现接口UserDao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl implements UserDao {

    @Override
    public void saveUser() {
        System.out.println(&amp;quot;保存成功&amp;quot;);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2配置bean-3&#34;&gt;②配置bean&lt;/h4&gt;
&lt;p&gt;autowirexml.xml&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用bean标签的autowire属性设置自动装配效果&lt;/p&gt;
&lt;p&gt;自动装配方式：byType&lt;/p&gt;
&lt;p&gt;byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值&lt;/p&gt;
&lt;p&gt;若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值 null&lt;/p&gt;
&lt;p&gt;若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionException&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;userController&amp;quot;
class=&amp;quot;com.atguigu.autowire.xml.controller.UserController&amp;quot; autowire=&amp;quot;byType&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&amp;quot;userService&amp;quot;
class=&amp;quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&amp;quot; autowire=&amp;quot;byType&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&amp;quot;userDao&amp;quot; class=&amp;quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;自动装配方式：byName&lt;/p&gt;
&lt;p&gt;byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean id=&amp;quot;userController&amp;quot;
class=&amp;quot;com.atguigu.autowire.xml.controller.UserController&amp;quot; autowire=&amp;quot;byName&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&amp;quot;userService&amp;quot;
class=&amp;quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&amp;quot; autowire=&amp;quot;byName&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&amp;quot;userServiceImpl&amp;quot;
class=&amp;quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&amp;quot; autowire=&amp;quot;byName&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&amp;quot;userDao&amp;quot; class=&amp;quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&amp;quot;userDaoImpl&amp;quot; class=&amp;quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3测试-3&#34;&gt;③测试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testAutoWireByXML() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;autowirexml.xml&amp;quot;);
    UserController userController = ioc.getBean(UserController.class);
    userController.saveUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23-基于注解管理bean&#34;&gt;2.3、基于注解管理bean&lt;/h2&gt;
&lt;h3 id=&#34;231-实验一标记与扫描&#34;&gt;2.3.1、实验一：标记与扫描&lt;/h3&gt;
&lt;h4 id=&#34;1注解&#34;&gt;①注解&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。&lt;/li&gt;
&lt;li&gt;本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。&lt;/li&gt;
&lt;li&gt;举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721171841.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们 做的工作，相当于框架的具体操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2扫描&#34;&gt;②扫描&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3新建maven-module&#34;&gt;③新建Maven Module&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;

    &amp;lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- junit测试 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4创建spring配置文件&#34;&gt;④创建Spring配置文件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;applicationContext.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721172818.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;5标识组件的常用注解&#34;&gt;⑤标识组件的常用注解&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;@Component：将类标识为普通组件&lt;/p&gt;
&lt;p&gt;@Controller：将类标识为控制层组件&lt;/p&gt;
&lt;p&gt;@Service：将类标识为业务层组件&lt;/p&gt;
&lt;p&gt;@Repository：将类标识为持久层组件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问：以上四个注解有什么关系和区别？&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721173246.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。&lt;/li&gt;
&lt;li&gt;对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。&lt;/li&gt;
&lt;li&gt;注意：虽然它们本质上一样，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;6创建组件&#34;&gt;⑥创建组件&lt;/h4&gt;
&lt;p&gt;创建控制层组件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class UserController {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建接口UserService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建业务层组件UserServiceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class UserServiceImpl implements UserService {
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建接口UserDao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserDao {
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建持久层组件UserDaoImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class UserDaoImpl implements UserDao {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;7扫描组件&#34;&gt;⑦扫描组件&lt;/h4&gt;
&lt;p&gt;情况一：最基本的扫描方式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;context:component-scan base-package=&amp;quot;com.atguigu&amp;quot;&amp;gt;
&amp;lt;/context:component-scan&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;情况二：指定要排除的组件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;context:component-scan base-package=&amp;quot;com.atguigu&amp;quot;&amp;gt;
    &amp;lt;!-- context:exclude-filter标签：指定排除规则 --&amp;gt;
    &amp;lt;!--
            type：设置排除或包含的依据
            type=&amp;quot;annotation&amp;quot;，根据注解排除，expression中设置要排除的注解的全类名
            type=&amp;quot;assignable&amp;quot;，根据类型排除，expression中设置要排除的类型的全类名
    --&amp;gt;
    &amp;lt;context:exclude-filter type=&amp;quot;annotation&amp;quot;
                            expression=&amp;quot;org.springframework.stereotype.Controller&amp;quot;/&amp;gt;
    &amp;lt;!--&amp;lt;context:exclude-filter type=&amp;quot;assignable&amp;quot; expression=&amp;quot;com.atguigu.controller.UserController&amp;quot;/&amp;gt;--&amp;gt;
&amp;lt;/context:component-scan&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;情况三：仅扫描指定组件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;context:component-scan base-package=&amp;quot;com.atguigu&amp;quot; use-default-filters=&amp;quot;false&amp;quot;&amp;gt;
    &amp;lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&amp;gt;
    &amp;lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&amp;gt;
    &amp;lt;!-- 此时必须设置use-default-filters=&amp;quot;false&amp;quot;，因为默认规则即扫描指定包下所有类 --&amp;gt;
    &amp;lt;!--
            type：设置排除或包含的依据
            type=&amp;quot;annotation&amp;quot;，根据注解排除，expression中设置要排除的注解的全类名
            type=&amp;quot;assignable&amp;quot;，根据类型排除，expression中设置要排除的类型的全类名
    --&amp;gt;
    &amp;lt;context:include-filter type=&amp;quot;annotation&amp;quot;
                            expression=&amp;quot;org.springframework.stereotype.Controller&amp;quot;/&amp;gt;
    &amp;lt;!--&amp;lt;context:include-filter type=&amp;quot;assignable&amp;quot;
        expression=&amp;quot;com.atguigu.controller.UserController&amp;quot;/&amp;gt;--&amp;gt;
&amp;lt;/context:component-scan&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;8测试&#34;&gt;⑧测试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testAutowireByAnnotation() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);
    UserController userController = ioc.getBean(UserController.class);
    System.out.println(userController);
    UserService userService = ioc.getBean(UserService.class);
    System.out.println(userService);
    UserDao userDao = ioc.getBean(UserDao.class);
    System.out.println(userDao);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;9组件所对应的bean的id&#34;&gt;⑨组件所对应的bean的id&lt;/h4&gt;
&lt;p&gt;在我们使用XML方式管理bean的时候，每个bean都有一个唯一标识，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;默认情况&lt;/p&gt;
&lt;p&gt;类名首字母小写就是bean的id。例如：UserController类对应的bean的id就是userController。&lt;/p&gt;
&lt;p&gt;自定义bean的id&lt;/p&gt;
&lt;p&gt;可通过标识组件的注解的value属性设置自定义的bean的id&lt;/p&gt;
&lt;p&gt;@Service(&amp;quot;userService&amp;quot;)//默认为userServiceImpl public class UserServiceImpl implements UserService {}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;232-实验二基于注解的自动装配&#34;&gt;2.3.2、实验二：基于注解的自动装配&lt;/h3&gt;
&lt;h4 id=&#34;1场景模拟-2&#34;&gt;①场景模拟&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;参考基于xml的自动装配&lt;/p&gt;
&lt;p&gt;在UserController中声明UserService对象&lt;/p&gt;
&lt;p&gt;在UserServiceImpl中声明UserDao对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;2-autowired注解&#34;&gt;② @Autowired注解&lt;/h4&gt;
&lt;p&gt;在成员变量上直接标记@Autowired注解即可完成自动装配，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class UserController {
  
    @Autowired
    private UserService userService;
  
    public void saveUser() {
        userService.saveUser();
    }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserService {
    void saveUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class UserServiceImpl implements UserService {
  
    @Autowired
    private UserDao userDao;
  
    @Override
    public void saveUser() {
        userDao.saveUser();
    }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserDao {
    void saveUser();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class UserDaoImpl implements UserDao {
    @Override
    public void saveUser() {
        System.out.println(&amp;quot;保存成功&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-autowired注解其他细节&#34;&gt;③ @Autowired注解其他细节&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;@Autowired注解可以标记在&lt;code&gt;构造器&lt;/code&gt;和&lt;code&gt;set方法&lt;/code&gt;上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class UserController {
    private UserService userService;
    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }
    public void saveUser() {
        userService.saveUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class UserController {
  
    private UserService userService;
  
    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
  
    public void saveUser() {
        userService.saveUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-autowired工作流程&#34;&gt;④ @Autowired工作流程&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721193212.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;首先根据所需要的组件类型到IOC容器中查找
&lt;ul&gt;
&lt;li&gt;能够找到唯一的bean：直接执行装配&lt;/li&gt;
&lt;li&gt;如果完全找不到匹配这个类型的bean：装配失败&lt;/li&gt;
&lt;li&gt;和所需类型匹配的bean不止一个
&lt;ul&gt;
&lt;li&gt;没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配
&lt;ul&gt;
&lt;li&gt;能够找到：执行装配&lt;/li&gt;
&lt;li&gt;找不到：装配失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用@Qualifier注解：根据@Qualifier注解中指定的名称作为bean的id进行匹配
&lt;ul&gt;
&lt;li&gt;能够找到：执行装配&lt;/li&gt;
&lt;li&gt;找不到：装配失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class UserController {
  
    @Autowired
    @Qualifier(&amp;quot;userServiceImpl&amp;quot;)
    private UserService userService;
  
    public void saveUser() {
        userService.saveUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;佛系装配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@Autowired中有属性required，默认值为true，因此在自动装配无法找到相应的bean时，会装配失败&lt;/p&gt;
&lt;p&gt;可以将属性required的值设置为false，则表示能装就装，装不上就不装.&lt;/p&gt;
&lt;p&gt;但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性。&lt;/p&gt;
&lt;p&gt;如果类中同时存在装配属性的 setXxx() 方法会使 required = false 设定失效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;注意&#34;&gt;注意&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在使用@Autowire的过程中会发现IDEA提示&lt;code&gt;不建议使用字段注入&lt;/code&gt;，我们查看检查描述可以看到这样容易抛出 &lt;code&gt;NullPointerException&lt;/code&gt;,提供的解决方案是将字段使用&lt;code&gt;final&lt;/code&gt;修饰，通过&lt;code&gt;构造器&lt;/code&gt;注入.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727184152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727184929.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们点击自动修复&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727185722.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在完成修复后我们注意到没有了任何注解，并且UserService能够正常的注入进来&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UserController{userService=com.atguigu.service.impl.UserServiceImpl@4ac3c60d}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这是因为从 Spring Framework 4.3 开始，&lt;code&gt;@Autowired&lt;/code&gt;如果&lt;code&gt;目标 bean 仅定义一个构造函数&lt;/code&gt;，则&lt;code&gt;不再需要&lt;/code&gt;对此类构造函数进行&lt;code&gt;注解声明&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即上述代码等价于&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class UserController {
  
    private final UserService userService;

    @Autowired //这里IDEA不会报警告
    public UserController(UserService userService) {
        this.userService = userService;
    }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;也即每个需要注入的属性需要&lt;code&gt;final&lt;/code&gt;修饰且要有相应的&lt;code&gt;参数构造器&lt;/code&gt;，自然当前类也只能有参数构造器不能有空参构造器。&lt;/p&gt;
&lt;p&gt;假设当前类有两个需要注入的属性字段：&lt;/p&gt;
&lt;p&gt;正确的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final CommonComponent commonComponent;
private final UserService userService;

public UserController(UserService userService, CommonComponent commonComponent) {
    this.userService = userService;
    this.commonComponent = commonComponent;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误的代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final CommonComponent commonComponent;
private final UserService userService;


//错误开始
public UserController() {
  
}
//错误结束


/*
a. 因为空参构造器会造成commonComponent或userService尚未初始化。（final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化）
b. 同理也不能有只含commonComponent或userService的单参构造器。
*/


public UserController(UserService userService, CommonComponent commonComponent) {
    this.userService = userService;
    this.commonComponent = commonComponent;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;5总结&#34;&gt;⑤总结&lt;/h4&gt;
&lt;p&gt;基于注解的自动装配&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方式一：使用&lt;code&gt;构造器注入&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用IDEA自动修复功能完成&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class UserController {
  
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式二：使用&lt;code&gt;@Resource&lt;/code&gt;替代@Autowired&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Resource和@Autowired和都可以用于来实现依赖注入，但前者为JDK（JSR-250标准）自带的，后者是Spring提供的。&lt;/li&gt;
&lt;li&gt;使用这种方式IDEA不会抱警告，但这种方式本质仍然是Field注入。&lt;/li&gt;
&lt;li&gt;Field注入的缺点很明显，比如不能像构造器注入那样注入不可变的对象，依赖对外部不可见（构造器和Setter可见，而private的属性不可见），会导致组件与IoC容器（比如Spring）紧密耦合，单元测试也需要使用IoC容器，依赖过多时相对构造器注入不能够明显的看出依赖过多（违反单一职责原则）。&lt;/li&gt;
&lt;li&gt;既然Field注入这么多缺点，但为什么大家还是习惯使用呢？主要原因：太方便了，极大的缩减了代码。而且大多数业务并不需要用构造器强绑定，同时换IoC容器的可能性也极低。所以，虽然Spring及IDE一直强调和提醒，但貌似并没有阻止程序员的使用。&lt;/li&gt;
&lt;li&gt;为什么只对@Autowired警告？&lt;/li&gt;
&lt;li&gt;最主要的原因可能是：@Autowired是Spring提供的，是特定IoC提供的特定注解，与框架形成了强绑定，一旦换用其他IoC框架，是无法支持注入的。而@Resource是JSR-250提供的，IoC容器应当去兼容它，即使更换容器，也可以正常工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Resource
private UserService userService;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式三：使用Lombok的&lt;code&gt;@RequiredArgsConstructor&lt;/code&gt;配合&lt;code&gt;final field&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequiredArgsConstructor
public class UserController {
    
    private final UserService userService;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;233-实验三完全注解开发&#34;&gt;2.3.3、实验三：完全注解开发&lt;/h3&gt;
&lt;p&gt;体验完全注解开发，是为了给将来学习 SpringBoot 打基础。因为在 SpringBoot 中，就是完全舍弃 XML 配置文件，全面使用注解来完成主要的配置。&lt;/p&gt;
&lt;h4 id=&#34;1创建配置类&#34;&gt;①创建配置类&lt;/h4&gt;
&lt;p&gt;使用 @Configuration 注解将一个普通的类标记为 Spring 的配置类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.atguigu.ioc.configuration;
    
import org.springframework.context.annotation.Configuration;
    
@Configuration
public class MyConfiguration {
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2根据配置类创建ioc容器对象&#34;&gt;②根据配置类创建IOC容器对象&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ClassPathXmlApplicationContext 根据 XML 配置文件创建 IOC 容器对象
private ApplicationContext ioc = new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;);

// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象
private ApplicationContext ioc = new AnnotationConfigApplicationContext(MyConfiguration.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3在配置类中配置bean&#34;&gt;③在配置类中配置bean&lt;/h4&gt;
&lt;p&gt;使用@Bean注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class MyConfiguration {
  
    // @Bean 注解相当于 XML 配置文件中的 bean 标签
    // @Bean 注解标记的方法的返回值会被放入 IOC 容器
    // 默认以方法名作为 bean 的 id
    @Bean
    public CommonComponent getComponent() {
      
        CommonComponent commonComponent = new CommonComponent();
      
        commonComponent.setComponentName(&amp;quot;created by annotation config&amp;quot;);
      
        return commonComponent;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4在配置类中配置自动扫描的包&#34;&gt;④在配置类中配置自动扫描的包&lt;/h4&gt;
&lt;p&gt;使用@ComponentScan注解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(&amp;quot;com.atguigu.ioc.component&amp;quot;)
public class MyConfiguration {
    ……
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;234-实验四整合junit4&#34;&gt;2.3.4、实验四：整合junit4&lt;/h3&gt;
&lt;h4 id=&#34;1整合的好处&#34;&gt;①整合的好处&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;好处1：不需要自己创建IOC容器对象了&lt;/li&gt;
&lt;li&gt;好处2：任何需要的bean都可以在测试类中直接享受自动装配&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2操作&#34;&gt;②操作&lt;/h4&gt;
&lt;p&gt;加入依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- Spring的测试包 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建测试类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// junit的@RunWith注解：指定Spring为Junit提供的运行器
@RunWith(SpringJUnit4ClassRunner.class)

// Spring的@ContextConfiguration指定Spring配置文件的位置
@ContextConfiguration(value = {&amp;quot;classpath:applicationContext.xml&amp;quot;})
public class JunitIntegrationSpring {
    
    @Autowired
    private SoldierController soldierController;
    
    @Test
    public void testIntegration() {
        System.out.println(&amp;quot;soldierController = &amp;quot; + soldierController);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-aop&#34;&gt;3、AOP&lt;/h1&gt;
&lt;h2 id=&#34;31-场景模拟&#34;&gt;3.1、场景模拟&lt;/h2&gt;
&lt;h3 id=&#34;311-声明接口&#34;&gt;3.1.1、声明接口&lt;/h3&gt;
&lt;p&gt;声明计算器接口Calculator，包含加减乘除的抽象方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Calculator {
    
    int add(int i, int j);
  
    int sub(int i, int j);
  
    int mul(int i, int j);
  
    int div(int i, int j);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;312-创建实现类&#34;&gt;3.1.2、创建实现类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721205610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CalculatorPureImpl implements Calculator {
    
    @Override
    public int add(int i, int j) {
        int result = i + j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        int result = i - j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        int result = i * j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        int result = i / j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;313-创建带日志功能的实现类&#34;&gt;3.1.3、创建带日志功能的实现类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721205850.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CalculatorLogImpl implements Calculator {
    
    @Override
    public int add(int i, int j) {
        System.out.println(&amp;quot;[日志] add 方法开始了，参数是：&amp;quot; + i + &amp;quot;,&amp;quot; + j);
        int result = i + j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        System.out.println(&amp;quot;[日志] add 方法结束了，结果是：&amp;quot; + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        System.out.println(&amp;quot;[日志] sub 方法开始了，参数是：&amp;quot; + i + &amp;quot;,&amp;quot; + j);
        int result = i - j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        System.out.println(&amp;quot;[日志] sub 方法结束了，结果是：&amp;quot; + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        System.out.println(&amp;quot;[日志] mul 方法开始了，参数是：&amp;quot; + i + &amp;quot;,&amp;quot; + j);
        int result = i * j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        System.out.println(&amp;quot;[日志] mul 方法结束了，结果是：&amp;quot; + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        System.out.println(&amp;quot;[日志] div 方法开始了，参数是：&amp;quot; + i + &amp;quot;,&amp;quot; + j);
        int result = i / j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        System.out.println(&amp;quot;[日志] div 方法结束了，结果是：&amp;quot; + result);
        return result;
    }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;314-提出问题&#34;&gt;3.1.4、提出问题&lt;/h3&gt;
&lt;h4 id=&#34;1现有代码缺陷&#34;&gt;①现有代码缺陷&lt;/h4&gt;
&lt;p&gt;针对带日志功能的实现类，我们发现有如下缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力&lt;/li&gt;
&lt;li&gt;附加功能分散在各个业务功能方法中，不利于统一维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2解决思路&#34;&gt;②解决思路&lt;/h4&gt;
&lt;p&gt;解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。&lt;/p&gt;
&lt;h4 id=&#34;3困难&#34;&gt;③困难&lt;/h4&gt;
&lt;p&gt;解决问题的困难：要抽取的代码在方法内部，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。&lt;/p&gt;
&lt;h2 id=&#34;32-代理模式&#34;&gt;3.2、代理模式&lt;/h2&gt;
&lt;h3 id=&#34;321-概念&#34;&gt;3.2.1、概念&lt;/h3&gt;
&lt;h4 id=&#34;1介绍&#34;&gt;①介绍&lt;/h4&gt;
&lt;p&gt;二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类&lt;strong&gt;间接&lt;/strong&gt;调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——&lt;strong&gt;解耦&lt;/strong&gt;。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721210816.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用代理后：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721210900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2生活中的代理&#34;&gt;②生活中的代理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;广告商找大明星拍广告需要经过经纪人&lt;/li&gt;
&lt;li&gt;合作伙伴找大老板谈合作要约见面时间需要经过秘书&lt;/li&gt;
&lt;li&gt;房产中介是买卖双方的代理&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3相关术语&#34;&gt;③相关术语&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。&lt;/li&gt;
&lt;li&gt;目标：&lt;strong&gt;被代理&lt;/strong&gt;“套用”了非核心逻辑代码的类、对象、方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;322-静态代理&#34;&gt;3.2.2、静态代理&lt;/h3&gt;
&lt;p&gt;创建静态代理类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CalculatorStaticProxy implements Calculator {
  
    // 将被代理的目标对象声明为成员变量
    private Calculator target;
  
    public CalculatorStaticProxy(Calculator target) {
        this.target = target;
    }
  
    @Override
    public int add(int i, int j) {
      
        // 附加功能由代理类中的代理方法来实现
        System.out.println(&amp;quot;[日志] add 方法开始了，参数是：&amp;quot; + i + &amp;quot;,&amp;quot; + j);
      
        // 通过目标对象来实现核心业务逻辑
        int addResult = target.add(i, j);
      
        System.out.println(&amp;quot;[日志] add 方法结束了，结果是：&amp;quot; + addResult);
      
        return addResult;
    }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;静态代理确实实现了解耦，但是由于代码都&lt;strong&gt;写死了&lt;/strong&gt;，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。&lt;/p&gt;
&lt;p&gt;提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;323-动态代理&#34;&gt;3.2.3、动态代理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721211704.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;生产代理对象的工厂类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ProxyFactory {
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    public Object getProxy() {

        /**
         * newProxyInstance()：创建一个代理实例
         * 其中有三个参数：
         * 1、classLoader：加载动态生成的代理类的类加载器
         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组
         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法
         */

        ClassLoader classLoader = target.getClass().getClassLoader();
        Class&amp;lt;?&amp;gt;[] interfaces = target.getClass().getInterfaces();
        InvocationHandler invocationHandler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args)
                    throws Throwable {
                /**
                 * proxy：代理对象
                 * method：代理对象需要实现的方法，即其中需要重写的方法
                 * args：method所对应方法的参数
                 */
                Object result = null;
                try {
                    System.out.println(&amp;quot;[动态代理][日志] &amp;quot; + method.getName() + &amp;quot;，参数：&amp;quot; + Arrays.toString(args));
                    result = method.invoke(target, args);
                    System.out.println(&amp;quot;[动态代理][日志] &amp;quot; + method.getName() + &amp;quot;，结果：&amp;quot; + result);
                } catch (Exception e) {
                    e.printStackTrace();
                    System.out.println(&amp;quot;[动态代理][日志] &amp;quot; + method.getName() + &amp;quot;，异常：&amp;quot; + e.getMessage());
                } finally {
                    System.out.println(&amp;quot;[动态代理][日志] &amp;quot; + method.getName() + &amp;quot;，方法执行完毕&amp;quot;);
                }
                return result;
            }
        };
        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;324-测试&#34;&gt;3.2.4、测试&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testDynamicProxy() {
    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());
    Calculator proxy = (Calculator) factory.getProxy();
    proxy.div(1, 0);
    //proxy.div(1,1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;33-aop概念及相关术语&#34;&gt;3.3、AOP概念及相关术语&lt;/h2&gt;
&lt;h3 id=&#34;331-概述&#34;&gt;3.3.1、概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术。&lt;/li&gt;
&lt;li&gt;AOP的核心套路&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721215952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;332-相关术语&#34;&gt;3.3.2、相关术语&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722120920.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;1横切关注点连接点&#34;&gt;①横切关注点(连接点)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。&lt;/li&gt;
&lt;li&gt;这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：&lt;strong&gt;有十个附加功能，就有十个横切关注点。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721220106.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2通知记住&#34;&gt;②通知【记住】&lt;/h4&gt;
&lt;p&gt;每一个横切关注点上要做的事情都需要写一个方法（&lt;strong&gt;实际增强的逻辑部分&lt;/strong&gt;）来实现，这样的方法就叫&lt;strong&gt;通知方法&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前置通知：在被代理的目标方法&lt;strong&gt;前&lt;/strong&gt;执行&lt;/li&gt;
&lt;li&gt;返回通知：在被代理的目标方法&lt;strong&gt;成功结束&lt;/strong&gt;后执行&lt;/li&gt;
&lt;li&gt;异常通知：在被代理的目标方法&lt;strong&gt;异常结束&lt;/strong&gt;后执行&lt;/li&gt;
&lt;li&gt;后置通知：在被代理的目标方法&lt;strong&gt;最终结束&lt;/strong&gt;后执行&lt;/li&gt;
&lt;li&gt;环绕通知：使用try...catch...finally结构围绕&lt;strong&gt;整个&lt;/strong&gt;被代理的目标方法，包括上面四种通知对应的所有位置&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721220834.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;3切面记住&#34;&gt;③切面【记住】&lt;/h4&gt;
&lt;p&gt;封装通知方法的&lt;strong&gt;类&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721221150.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;4目标&#34;&gt;④目标&lt;/h4&gt;
&lt;p&gt;被代理的&lt;strong&gt;目标对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;5代理&#34;&gt;⑤代理&lt;/h4&gt;
&lt;p&gt;向目标对象应用通知之后创建的&lt;strong&gt;代理对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;6连接点&#34;&gt;⑥连接点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类里面哪些方法可以被增强，这些方法称为连接点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这也是一个纯逻辑概念，不是语法定义的。&lt;/p&gt;
&lt;p&gt;把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721221557.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;7切入点记住&#34;&gt;⑦切入点【记住】&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实际被增强的方法，称为切入点。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定位连接点的方式。&lt;/p&gt;
&lt;p&gt;每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。&lt;/p&gt;
&lt;p&gt;如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。&lt;/p&gt;
&lt;p&gt;Spring 的 AOP 技术可以通过切入点定位到特定的连接点。&lt;/p&gt;
&lt;p&gt;切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。&lt;/p&gt;
&lt;h4 id=&#34;8织入&#34;&gt;⑧织入&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;织入是动作，就是把通知应用到切入点来创建代理对象的&lt;strong&gt;过程&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;333-作用&#34;&gt;3.3.3、作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简化代码：把方法中固定位置的重复的代码&lt;strong&gt;抽取&lt;/strong&gt;出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。&lt;/li&gt;
&lt;li&gt;代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被&lt;strong&gt;套用&lt;/strong&gt;了切面逻辑的方法就被切面给增强了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;34-基于注解的aop&#34;&gt;3.4、基于注解的AOP&lt;/h2&gt;
&lt;h3 id=&#34;341-技术说明&#34;&gt;3.4.1、技术说明&lt;/h3&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722142959.png&#34;/&gt;
&lt;ul&gt;
&lt;li&gt;动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求&lt;strong&gt;代理对象和目标对象实现同样的接口&lt;/strong&gt;（兄弟两个拜把子模式）。&lt;/li&gt;
&lt;li&gt;cglib：通过&lt;strong&gt;继承被代理的目标类&lt;/strong&gt;（认干爹模式）实现代理，所以不需要目标类实现接口。&lt;/li&gt;
&lt;li&gt;AspectJ：本质上是静态代理，&lt;strong&gt;将代理逻辑“织入”被代理的目标类编译得到的字节码文件&lt;/strong&gt;，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;342-准备工作&#34;&gt;3.4.2、准备工作&lt;/h3&gt;
&lt;h4 id=&#34;1添加依赖&#34;&gt;①添加依赖&lt;/h4&gt;
&lt;p&gt;在IOC所需依赖基础上再加入下面依赖即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&amp;gt;
&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;spring-aspects&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2准备被代理的目标资源&#34;&gt;②准备被代理的目标资源&lt;/h4&gt;
&lt;p&gt;接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Calculator {
    
    int add(int i, int j);
  
    int sub(int i, int j);
  
    int mul(int i, int j);
  
    int div(int i, int j);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CalculatorPureImpl implements Calculator {
    
    @Override
    public int add(int i, int j) {
        int result = i + j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        int result = i - j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        int result = i * j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        int result = i / j;
        System.out.println(&amp;quot;方法内部 result = &amp;quot; + result);
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;343-创建切面类并配置&#34;&gt;3.4.3、创建切面类并配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// @Aspect表示这个类是一个切面类
@Aspect
// @Component注解保证这个切面类能够放入IOC容器
@Component
public class LogAspect {

    // @Before注解：声明当前方法是前置通知方法
    // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上
    @Before(&amp;quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&amp;quot;)
    public void printLogBeforeCore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());
        System.out.println(&amp;quot;Logger--&amp;gt;前置通知，方法名：&amp;quot; + methodName + &amp;quot;，参数：&amp;quot; + args);
    }

    @Afterr(&amp;quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&amp;quot;)
    public void printLogFinallyEnd() {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&amp;quot;Logger--&amp;gt;后置通知，方法名：&amp;quot; + methodName);
    }

    @AfterReturningg(value = &amp;quot;execution(*
            com.atguigu.aop.annotation.CalculatorImpl.*(..))&amp;quot;, returning = &amp;quot;result&amp;quot;)

    public void printLogAfterException(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&amp;quot;Logger--&amp;gt;返回通知，方法名：&amp;quot; + methodName + &amp;quot;，结果：&amp;quot; + result);
    }


    @AfterThrowing(value = &amp;quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&amp;quot;, throwing = &amp;quot;ex&amp;quot;)
    public void printLogAfterSuccess(JoinPoint joinPoint, Throwable ex) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&amp;quot;Logger--&amp;gt;异常通知，方法名：&amp;quot; + methodName + &amp;quot;，异常：&amp;quot; + ex);
    }


    @Around(&amp;quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&amp;quot;)
    public Object aroundMethod(ProceedingJoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());
        Object result = null;
        try {
            System.out.println(&amp;quot;环绕通知--&amp;gt;目标对象方法执行之前&amp;quot;);
            //目标对象（连接点）方法的执行
            result = joinPoint.proceed();
            System.out.println(&amp;quot;环绕通知--&amp;gt;目标对象方法返回值之后&amp;quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            System.out.println(&amp;quot;环绕通知--&amp;gt;目标对象方法出现异常时&amp;quot;);
        } finally {
            System.out.println(&amp;quot;环绕通知--&amp;gt;目标对象方法执行完毕&amp;quot;);
        }
        return result;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Spring的配置文件中配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
基于注解的AOP的实现：
1、将目标对象和切面交给IOC容器管理（注解+扫描）
2、开启基于注解的AOP功能 (开启AspectJ的自动代理，为目标对象自动生成代理)
3、将切面类通过注解@Aspect标识
 --&amp;gt;

&amp;lt;!-- 配置自动扫描的包 --&amp;gt;
&amp;lt;context:component-scan base-package=&amp;quot;com.atguigu.aop.annotation&amp;quot;/&amp;gt;

&amp;lt;!-- 开启基于注解的AOP功能 --&amp;gt;
&amp;lt;aop:aspectj-autoproxy/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;344-各种通知&#34;&gt;3.4.4、各种通知&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;前置通知：使用@Before注解标识，在被代理的目标方法&lt;strong&gt;前&lt;/strong&gt;执行&lt;/li&gt;
&lt;li&gt;返回通知：使用@AfterReturning注解标识，在被代理的目标方法&lt;strong&gt;成功结束&lt;/strong&gt;后执行&lt;/li&gt;
&lt;li&gt;异常通知：使用@AfterThrowing注解标识，在被代理的目标方法&lt;strong&gt;异常结束&lt;/strong&gt;后执行&lt;/li&gt;
&lt;li&gt;后置通知：使用@After注解标识，在被代理的目标方法&lt;strong&gt;最终结束&lt;/strong&gt;后执行&lt;/li&gt;
&lt;li&gt;环绕通知：使用@Around注解标识，使用try...catch...finally结构围绕&lt;strong&gt;整个&lt;/strong&gt;被代理的目标方法，包括上面四种通知对应的所有位置&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;各种通知的执行顺序&#34;&gt;各种通知的执行顺序：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Spring版本5.3.x以前：
&lt;ul&gt;
&lt;li&gt;前置通知&lt;/li&gt;
&lt;li&gt;目标操作&lt;/li&gt;
&lt;li&gt;后置通知&lt;/li&gt;
&lt;li&gt;返回通知或异常通知&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spring版本5.3.x以后：
&lt;ul&gt;
&lt;li&gt;前置通知&lt;/li&gt;
&lt;li&gt;目标操作&lt;/li&gt;
&lt;li&gt;返回通知或异常通知&lt;/li&gt;
&lt;li&gt;后置通知&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;345-切入点表达式语法&#34;&gt;3.4.5、切入点表达式语法&lt;/h3&gt;
&lt;h4 id=&#34;1作用&#34;&gt;①作用&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722165001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2语法细节&#34;&gt;②语法细节&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用 * 号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限&lt;/li&gt;
&lt;li&gt;在包名的部分，一个 * 号只能代表包的层次结构中的一层，表示这一层是任意的。
&lt;ul&gt;
&lt;li&gt;例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在包名的部分，使用“*..”表示包名任意、包的层次深度任意&lt;/li&gt;
&lt;li&gt;在类名的部分，类名部分整体用*号代替，表示类名任意&lt;/li&gt;
&lt;li&gt;在类名的部分，可以使用*号代替类名的一部分
&lt;ul&gt;
&lt;li&gt;例如：*Service匹配所有名称以Service结尾的类或接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在方法名部分，可以使用*号表示方法名任意&lt;/li&gt;
&lt;li&gt;在方法名部分，可以使用*号代替方法名的一部分
&lt;ul&gt;
&lt;li&gt;例如：*Operation匹配所有方法名以Operation结尾的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在方法参数列表部分，使用(..)表示参数列表任意&lt;/li&gt;
&lt;li&gt;在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头&lt;/li&gt;
&lt;li&gt;在方法参数列表部分，基本数据类型和对应的包装类型是不一样的
&lt;ul&gt;
&lt;li&gt;切入点表达式中使用 int 和实际方法中 Integer 是不匹配的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符
&lt;ul&gt;
&lt;li&gt;例如：execution(public int ..Service.*(.., int)) &lt;code&gt;正确&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例如：execution(* int ..Service.*(.., int)) &lt;code&gt;错误&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722170459.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;tip&#34;&gt;TIP&lt;/h4&gt;
&lt;p&gt;虽然我们上面介绍过的切入点表达式语法细节很多，有很多变化，但是实际上具体在项目中应用时有比较固定的写法。&lt;/p&gt;
&lt;p&gt;典型场景：在基于 XML 的声明式事务配置中需要指定切入点表达式。这个切入点表达式通常都会套用到所有 Service 类（接口）的所有方法。那么切入点表达式将如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;execution(* *..*Service.*(..))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;346-重用切入点表达式&#34;&gt;3.4.6、重用切入点表达式&lt;/h3&gt;
&lt;h4 id=&#34;1声明&#34;&gt;①声明&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Pointcut(&amp;quot;execution(* com.atguigu.aop.annotation.*.*(..))&amp;quot;)
public void pointCut(){}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2在同一个切面中使用&#34;&gt;②在同一个切面中使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Before(&amp;quot;pointCut()&amp;quot;)
public void beforeMethod(JoinPoint joinPoint) {
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println(&amp;quot;Logger--&amp;gt;前置通知，方法名：&amp;quot; + methodName + &amp;quot;，参数：&amp;quot; + args);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3在不同切面中使用&#34;&gt;③在不同切面中使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Before(&amp;quot;com.atguigu.aop.CommonPointCut.pointCut()&amp;quot;)
public void beforeMethod(JoinPoint joinPoint) {
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println(&amp;quot;Logger--&amp;gt;前置通知，方法名：&amp;quot; + methodName + &amp;quot;，参数：&amp;quot; + args);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;347-获取通知的相关信息&#34;&gt;3.4.7、获取通知的相关信息&lt;/h3&gt;
&lt;h4 id=&#34;1获取连接点信息&#34;&gt;①获取连接点信息&lt;/h4&gt;
&lt;p&gt;获取连接点信息可以在通知方法的参数位置设置&lt;code&gt;JoinPoint&lt;/code&gt;类型的形参&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Before(&amp;quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&amp;quot;)
public void beforeMethod(JoinPoint joinPoint) {
    //获取连接点的签名信息
    String methodName = joinPoint.getSignature().getName();
    //获取目标方法到的实参信息
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println(&amp;quot;Logger--&amp;gt;前置通知，方法名：&amp;quot; + methodName + &amp;quot;，参数：&amp;quot; + args);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2获取目标方法的返回值&#34;&gt;②获取目标方法的返回值&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;@AfterReturning&lt;/code&gt;中的属性&lt;code&gt;returning&lt;/code&gt;，用来将通知方法的某个形参，接收目标方法的返回值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@AfterReturning(value = &amp;quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.* (..))&amp;quot;, returning = &amp;quot;result&amp;quot;)
public void afterReturningMethod(JoinPoint joinPoint, Object result) {
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&amp;quot;Logger--&amp;gt;返回通知，方法名：&amp;quot; + methodName + &amp;quot;，结果：&amp;quot; + result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3获取目标方法的异常&#34;&gt;③获取目标方法的异常&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;@AfterThrowing&lt;/code&gt;中的属性&lt;code&gt;throwing&lt;/code&gt;，用来将通知方法的某个形参，接收目标方法的异常&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@AfterThrowing(value = &amp;quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.* (..))&amp;quot;, throwing = &amp;quot;ex&amp;quot;)
public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex) {
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&amp;quot;Logger--&amp;gt;异常通知，方法名：&amp;quot; + methodName + &amp;quot;，异常：&amp;quot; + ex);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;348-环绕通知&#34;&gt;3.4.8、环绕通知&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;环绕通知类似于动态代理的具体实现&lt;/li&gt;
&lt;li&gt;注意环绕通知的JoinPoint类型是&lt;code&gt;ProceedingJoinPoint&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Around(&amp;quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&amp;quot;)
public Object aroundMethod(ProceedingJoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    Object result = null;
    try {
        System.out.println(&amp;quot;环绕通知--&amp;gt;目标对象方法执行之前&amp;quot;);
        //目标对象（连接点）方法的执行
        result = joinPoint.proceed();
        System.out.println(&amp;quot;环绕通知--&amp;gt;目标对象方法返回值之后&amp;quot;);
    } catch (Throwable throwable) {
        throwable.printStackTrace();
        System.out.println(&amp;quot;环绕通知--&amp;gt;目标对象方法出现异常时&amp;quot;);
    } finally {
        System.out.println(&amp;quot;环绕通知--&amp;gt;目标对象方法执行完毕&amp;quot;);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;349-切面的优先级&#34;&gt;3.4.9、切面的优先级&lt;/h3&gt;
&lt;h4 id=&#34;1概念-2&#34;&gt;①概念&lt;/h4&gt;
&lt;p&gt;相同目标方法上同时存在多个切面时，切面的优先级控制按照切面的&lt;code&gt;内外嵌套&lt;/code&gt;顺序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优先级高的切面：外面&lt;/li&gt;
&lt;li&gt;优先级低的切面：里面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;code&gt;@Order&lt;/code&gt;注解可以控制切面的优先级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Order(较小的数)：优先级高&lt;/li&gt;
&lt;li&gt;@Order(较大的数)：优先级低&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722173445.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2实际意义&#34;&gt;②实际意义&lt;/h4&gt;
&lt;p&gt;实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722174955.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722175037.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3410-没有接口的情况&#34;&gt;3.4.10、没有接口的情况&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。为了证明这一点，我们做下面的测试：&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1创建目标类&#34;&gt;①创建目标类&lt;/h4&gt;
&lt;p&gt;请确保这个类在自动扫描的包下，同时确保切面的切入点表达式能够覆盖到类中的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class EmployeeService {
    
    public void getEmpList() {
        System.out.println(&amp;quot;方法内部 com.atguigu.aop.imp.EmployeeService.getEmpList&amp;quot;);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2测试&#34;&gt;②测试&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired
private EmployeeService employeeService;

@Test
public void testNoInterfaceProxy() {
    employeeService.getEmpList();
    System.out.println();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3debug查看&#34;&gt;③Debug查看&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;没有实现接口情况&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722180742.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有实现接口的情况&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722180811.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时我们发现：Mybatis 调用的 Mapper 接口类型的对象其实也是动态代理机制&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722180853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;35-基于xml的aop了解&#34;&gt;3.5、基于XML的AOP（了解）&lt;/h2&gt;
&lt;h3 id=&#34;351-准备工作&#34;&gt;3.5.1、准备工作&lt;/h3&gt;
&lt;h4 id=&#34;1添加依赖-2&#34;&gt;①添加依赖&lt;/h4&gt;
&lt;p&gt;和基于注解的 AOP 时一样。&lt;/p&gt;
&lt;h4 id=&#34;2准备代码&#34;&gt;②准备代码&lt;/h4&gt;
&lt;p&gt;把测试基于注解功能时的Java类复制到新module中，去除所有注解。&lt;/p&gt;
&lt;h3 id=&#34;352-实现&#34;&gt;3.5.2、实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 配置目标类的bean --&amp;gt;
&amp;lt;bean id=&amp;quot;calculatorPure&amp;quot; class=&amp;quot;com.atguigu.aop.imp.CalculatorPureImpl&amp;quot;/&amp;gt;
    
&amp;lt;!-- 配置切面类的bean --&amp;gt;
&amp;lt;bean id=&amp;quot;logAspect&amp;quot; class=&amp;quot;com.atguigu.aop.aspect.LogAspect&amp;quot;/&amp;gt;
    
&amp;lt;!-- 配置AOP --&amp;gt;
&amp;lt;aop:config&amp;gt;
    
    &amp;lt;!-- 配置切入点表达式 --&amp;gt;
    &amp;lt;aop:pointcut id=&amp;quot;logPointCut&amp;quot; expression=&amp;quot;execution(* *..*.*(..))&amp;quot;/&amp;gt;
    
    &amp;lt;!-- aop:aspect标签：配置切面 --&amp;gt;
    &amp;lt;!-- ref属性：关联切面类的bean --&amp;gt;
    &amp;lt;aop:aspect ref=&amp;quot;logAspect&amp;quot;&amp;gt;
        &amp;lt;!-- aop:before标签：配置前置通知 --&amp;gt;
        &amp;lt;!-- method属性：指定前置通知的方法名 --&amp;gt;
        &amp;lt;!-- pointcut-ref属性：引用切入点表达式 --&amp;gt;
        &amp;lt;aop:before method=&amp;quot;printLogBeforeCore&amp;quot; pointcut-ref=&amp;quot;logPointCut&amp;quot;/&amp;gt;
    
        &amp;lt;!-- aop:after-returning标签：配置返回通知 --&amp;gt;
        &amp;lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&amp;gt;
        &amp;lt;aop:after-returning
                method=&amp;quot;printLogAfterCoreSuccess&amp;quot;
                pointcut-ref=&amp;quot;logPointCut&amp;quot;
                returning=&amp;quot;targetMethodReturnValue&amp;quot;/&amp;gt;
    
        &amp;lt;!-- aop:after-throwing标签：配置异常通知 --&amp;gt;
        &amp;lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&amp;gt;
        &amp;lt;aop:after-throwing
                method=&amp;quot;printLogAfterCoreException&amp;quot;
                pointcut-ref=&amp;quot;logPointCut&amp;quot;
                throwing=&amp;quot;targetMethodException&amp;quot;/&amp;gt;
    
        &amp;lt;!-- aop:after标签：配置后置通知 --&amp;gt;
        &amp;lt;aop:after method=&amp;quot;printLogCoreFinallyEnd&amp;quot; pointcut-ref=&amp;quot;logPointCut&amp;quot;/&amp;gt;
    
        &amp;lt;!-- aop:around标签：配置环绕通知 --&amp;gt;
        &amp;lt;!--&amp;lt;aop:around method=&amp;quot;……&amp;quot; pointcut-ref=&amp;quot;logPointCut&amp;quot;/&amp;gt;--&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
    
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;352-测试&#34;&gt;3.5.2、测试&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(value = {&amp;quot;classpath:spring-context.xml&amp;quot;})
public class AOPTest {
    
    @Autowired
    private Calculator calculator;
    
    @Test
    public void testLogAspect() {
        int add = calculator.add(10, 2);
        System.out.println(&amp;quot;add = &amp;quot; + add);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;36-aop-对获取-bean-的影响&#34;&gt;3.6、AOP 对获取 bean 的影响&lt;/h2&gt;
&lt;h3 id=&#34;351-实验&#34;&gt;3.5.1、实验&lt;/h3&gt;
&lt;h4 id=&#34;1情景一&#34;&gt;①情景一&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;声明一个接口&lt;/li&gt;
&lt;li&gt;接口有一个实现类&lt;/li&gt;
&lt;li&gt;创建一个切面类，对上面接口的实现类应用通知
&lt;ul&gt;
&lt;li&gt;测试：根据接口类型获取bean&lt;/li&gt;
&lt;li&gt;测试：根据类获取bean&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因分析：&lt;/p&gt;
&lt;p&gt;应用了切面后，真正放在IOC容器中的是代理类的对象&lt;/p&gt;
&lt;p&gt;目标类并没有被放到IOC容器中，所以&lt;code&gt;根据目标类的类型从IOC容器中是找不到的&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722191357.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从内存分析的角度来说，IOC容器中引用的是代理对象，代理对象引用的是目标对象。IOC容器并没有直接引用目标对象，所以根据目标类本身在IOC容器范围内查找不到。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722191614.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;debug查看代理类的类型：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722191640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2情景二&#34;&gt;②情景二&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明一个类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个切面类，对上面的类应用通知&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试：根据类获取 bean，能获取到。（实际上相当于根据父类类型获取子类bean，前提保证只有一个子类）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722192250.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;debug查看实际类型：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722192327.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;352-总结&#34;&gt;3.5.2、总结&lt;/h3&gt;
&lt;h4 id=&#34;1对实现了接口的类应用切面&#34;&gt;①对实现了接口的类应用切面&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;应用切面后的代理类&lt;/code&gt;放入IOC容器&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722190152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2对没实现接口的类应用切面&#34;&gt;②对没实现接口的类应用切面&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;CGLIB生成的代理类&lt;/code&gt;放入IOC容器&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722190211.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;4-声明式事务&#34;&gt;4、声明式事务&lt;/h1&gt;
&lt;h2 id=&#34;41-jdbctemplate&#34;&gt;4.1、JdbcTemplate&lt;/h2&gt;
&lt;h3 id=&#34;411-简介&#34;&gt;4.1.1、简介&lt;/h3&gt;
&lt;p&gt;Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作&lt;/p&gt;
&lt;h3 id=&#34;412-准备工作&#34;&gt;4.1.2、准备工作&lt;/h3&gt;
&lt;h4 id=&#34;1加入依赖-2&#34;&gt;①加入依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;

    &amp;lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Spring 持久化层支持jar包 --&amp;gt;
    &amp;lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&amp;gt;
    &amp;lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-orm&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Spring 测试相关 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- junit测试 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- MySQL驱动 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.1.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 数据源 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.31&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2创建jdbcproperties&#34;&gt;②创建jdbc.properties&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/ssm?characterEncoding=utf8&amp;amp;useUnicode=true
jdbc.username=root
jdbc.password=
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3配置spring的配置文件&#34;&gt;③配置Spring的配置文件&lt;/h4&gt;
&lt;p&gt;spring-jdbc.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 导入外部属性文件 --&amp;gt;
&amp;lt;context:property-placeholder location=&amp;quot;classpath:jdbc.properties&amp;quot; /&amp;gt;

&amp;lt;!-- 配置数据源 --&amp;gt;
&amp;lt;bean id=&amp;quot;druidDataSource&amp;quot; class=&amp;quot;com.alibaba.druid.pool.DruidDataSource&amp;quot;&amp;gt;
		&amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${atguigu.url}&amp;quot;/&amp;gt;
		&amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${atguigu.driver}&amp;quot;/&amp;gt;
		&amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${atguigu.username}&amp;quot;/&amp;gt;
		&amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${atguigu.password}&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!-- 配置 JdbcTemplate --&amp;gt;
&amp;lt;bean id=&amp;quot;jdbcTemplate&amp;quot; class=&amp;quot;org.springframework.jdbc.core.JdbcTemplate&amp;quot;&amp;gt;
		&amp;lt;!-- 装配数据源 --&amp;gt;
		&amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;druidDataSource&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;413-测试&#34;&gt;4.1.3、测试&lt;/h3&gt;
&lt;h4 id=&#34;1在测试类装配-jdbctemplate&#34;&gt;①在测试类装配 JdbcTemplate&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&amp;quot;classpath:spring-jdbc.xml&amp;quot;)
public class JDBCTemplateTest {
  
    @Autowired
    private JdbcTemplate jdbcTemplate;
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2测试增删改功能&#34;&gt;②测试增删改功能&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
//测试增删改功能
public void testUpdate() {
    String sql = &amp;quot;insert into t_emp values(null,?,?,?)&amp;quot;;
    int result = jdbcTemplate.update(sql, &amp;quot;张三&amp;quot;, 23, &amp;quot;男&amp;quot;);
    System.out.println(result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3查询一条数据为实体类对象&#34;&gt;③查询一条数据为实体类对象&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
//查询一条数据为一个实体类对象
public void testSelectEmpById() {
    String sql = &amp;quot;select * from t_emp where id = ?&amp;quot;;
    Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&amp;lt;&amp;gt;(Emp.class), 1);
    System.out.println(emp);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4查询多条数据为一个list集合&#34;&gt;④查询多条数据为一个list集合&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
//查询多条数据为一个list集合
public void testSelectList() {
    String sql = &amp;quot;select * from t_emp&amp;quot;;
    List&amp;lt;Emp&amp;gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&amp;lt;&amp;gt;(Emp.class));
    list.forEach(emp -&amp;gt; System.out.println(emp));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5查询单行单列的值&#34;&gt;⑤查询单行单列的值&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
//查询单行单列的值
public void selectCount() {
    String sql = &amp;quot;select count(id) from t_emp&amp;quot;;
    Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
    System.out.println(count);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;42-声明式事务概念&#34;&gt;4.2、声明式事务概念&lt;/h2&gt;
&lt;h3 id=&#34;421-编程式事务&#34;&gt;4.2.1、编程式事务&lt;/h3&gt;
&lt;p&gt;事务功能的相关操作全部通过自己编写代码来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Connection conn = ...;
	
try {
	
	// 开启事务：关闭事务的自动提交
	conn.setAutoCommit(false);
	
	// 核心操作
	
	// 提交事务
	conn.commit();
	
}catch(Exception e){
	
	// 回滚事务
	conn.rollBack();
	
}finally{
	
	// 释放数据库连接
	conn.close();
	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编程式的实现方式存在缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。&lt;/li&gt;
&lt;li&gt;代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;422-声明式事务&#34;&gt;4.2.2、声明式事务&lt;/h3&gt;
&lt;p&gt;既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。&lt;/p&gt;
&lt;p&gt;封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;好处1：提高开发效率&lt;/li&gt;
&lt;li&gt;好处2：消除了冗余的代码&lt;/li&gt;
&lt;li&gt;好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，我们可以总结下面两个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编程式&lt;/strong&gt;：&lt;strong&gt;自己写代码&lt;/strong&gt;实现功能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;声明式&lt;/strong&gt;：通过&lt;strong&gt;配置&lt;/strong&gt;让&lt;strong&gt;框架&lt;/strong&gt;实现功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;43-基于注解的声明式事务&#34;&gt;4.3、基于注解的声明式事务&lt;/h2&gt;
&lt;h3 id=&#34;431-准备工作&#34;&gt;4.3.1、准备工作&lt;/h3&gt;
&lt;h4 id=&#34;1加入依赖-3&#34;&gt;①加入依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;

    &amp;lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Spring 持久化层支持jar包 --&amp;gt;
    &amp;lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&amp;gt;
    &amp;lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-orm&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Spring 测试相关 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- junit测试 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- MySQL驱动 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.1.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 数据源 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.31&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2创建jdbcproperties-2&#34;&gt;②创建jdbc.properties&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/ssm?characterEncoding=utf8&amp;amp;useUnicode=true
jdbc.username=root
jdbc.password=
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3配置spring的配置文件-2&#34;&gt;③配置Spring的配置文件&lt;/h4&gt;
&lt;p&gt;tx-annotation.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--扫描组件--&amp;gt;
&amp;lt;context:component-scan base-package=&amp;quot;com.atguigu.spring.tx.annotation&amp;quot;&amp;gt;
&amp;lt;/context:component-scan&amp;gt;

&amp;lt;!-- 导入外部属性文件 --&amp;gt;
&amp;lt;context:property-placeholder location=&amp;quot;classpath:jdbc.properties&amp;quot;/&amp;gt;

&amp;lt;!-- 配置数据源 --&amp;gt;
&amp;lt;bean id=&amp;quot;druidDataSource&amp;quot; class=&amp;quot;com.alibaba.druid.pool.DruidDataSource&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${atguigu.url}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${atguigu.driver}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${atguigu.username}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${atguigu.password}&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!-- 配置 JdbcTemplate --&amp;gt;
&amp;lt;bean id=&amp;quot;jdbcTemplate&amp;quot; class=&amp;quot;org.springframework.jdbc.core.JdbcTemplate&amp;quot;&amp;gt;
    &amp;lt;!-- 装配数据源 --&amp;gt;
    &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;druidDataSource&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4创建表&#34;&gt;④创建表&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE `t_book` (
	`book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
	`book_name` varchar(20) DEFAULT NULL COMMENT &#39;图书名称&#39;,
	`price` int(11) DEFAULT NULL COMMENT &#39;价格&#39;,
	`stock` int(10) unsigned DEFAULT NULL COMMENT &#39;库存（无符号）&#39;,
PRIMARY KEY (`book_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,&#39;斗破苍
穹&#39;,80,100),(2,&#39;斗罗大陆&#39;,50,100);

CREATE TABLE `t_user` (
	`user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
	`username` varchar(20) DEFAULT NULL COMMENT &#39;用户名&#39;,
	`balance` int(10) unsigned DEFAULT NULL COMMENT &#39;余额（无符号）&#39;,
PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

insert into `t_user`(`user_id`,`username`,`balance`) values (1,&#39;admin&#39;,50);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5创建组件&#34;&gt;⑤创建组件&lt;/h4&gt;
&lt;p&gt;创建BookController&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class BookController {
  
    @Autowired
    private BookService bookService;
  
    public void buyBook(Integer bookId, Integer userId) {
        bookService.buyBook(bookId, userId);
    }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建接口BookService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BookService {
  
    void buyBook(Integer bookId, Integer userId);
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建实现类BookServiceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class BookServiceImpl implements BookService {
  
    @Autowired
    private BookDao bookDao;
  
    @Override
    public void buyBook(Integer bookId, Integer userId) {
        //查询图书的价格
        Integer price = bookDao.getPriceByBookId(bookId);
        //更新图书的库存
        bookDao.updateStock(bookId);
        //更新用户的余额
        bookDao.updateBalance(userId, price);
    }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建接口BookDao&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BookDao {

    Integer getPriceByBookId(Integer bookId);
    
    void updateStock(Integer bookId);
    
    void updateBalance(Integer userId, Integer price);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建实现类BookDaoImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class BookDaoImpl implements BookDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Override
    public Integer getPriceByBookId(Integer bookId) {
        String sql = &amp;quot;select price from t_book where book_id = ?&amp;quot;;
        return jdbcTemplate.queryForObject(sql, Integer.class, bookId);
    }
    @Override
    public void updateStock(Integer bookId) {
        String sql = &amp;quot;update t_book set stock = stock - 1 where book_id = ?&amp;quot;;
        jdbcTemplate.update(sql, bookId);
    }
    @Override
    public void updateBalance(Integer userId, Integer price) {
        String sql = &amp;quot;update t_user set balance = balance - ? where user_id = ? &amp;quot;;
        jdbcTemplate.update(sql, price, userId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;432-测试无事务情况&#34;&gt;4.3.2、测试无事务情况&lt;/h3&gt;
&lt;h4 id=&#34;1创建测试类&#34;&gt;①创建测试类&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&amp;quot;classpath:tx-annotation.xml&amp;quot;)
public class TxByAnnotationTest {
  
    @Autowired
    private BookController bookController;
  
    @Test
    public void testBuyBook() {
        bookController.buyBook(1, 1);
    }
 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2模拟场景&#34;&gt;②模拟场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假设用户id为1的用户，购买id为1的图书&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户余额为50，而图书价格为80&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时执行sql语句会抛出SQLException&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3观察结果&#34;&gt;③观察结果&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;因为没有添加事务，图书的库存更新了，但是用户的余额没有更新&lt;/li&gt;
&lt;li&gt;显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;433-加入事务&#34;&gt;4.3.3、加入事务&lt;/h3&gt;
&lt;h4 id=&#34;1添加事务配置&#34;&gt;①添加事务配置&lt;/h4&gt;
&lt;p&gt;在Spring的配置文件中添加配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--创建事务管理器bean--&amp;gt;
&amp;lt;bean id=&amp;quot;transactionManager&amp;quot;
      class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!--
 开启事务的注解驱动
 通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务
--&amp;gt;
&amp;lt;!--
 transaction-manager属性的默认值是transactionManager，
 如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性
--&amp;gt;
&amp;lt;tx:annotation-driven transaction-manager=&amp;quot;transactionManager&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：导入的名称空间需要 &lt;strong&gt;tx 结尾&lt;/strong&gt;的那个。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220723004522.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;该配置对应的注解方式为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@EnableTransactionManagement //启用事务管理&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;2添加事务注解&#34;&gt;②添加事务注解&lt;/h4&gt;
&lt;p&gt;因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理 在BookServiceImpl的buybook()添加注解&lt;code&gt;@Transactional&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;3观察结果-2&#34;&gt;③观察结果&lt;/h4&gt;
&lt;p&gt;由于使用了Spring的声明式事务，更新库存和更新余额都没有执行&lt;/p&gt;
&lt;h3 id=&#34;434-transactional注解标识的位置&#34;&gt;4.3.4、@Transactional注解标识的位置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;@Transactional标识在方法上，则只会影响该方法&lt;/li&gt;
&lt;li&gt;@Transactional标识的类上，则会影响类中所有的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;tip-2&#34;&gt;TIP&lt;/h4&gt;
&lt;p&gt;Spring 环境下很多场合都有类似设定，一个注解如果标记了类的每一个方法那么通常就可以提取到类级别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;435-事务属性只读&#34;&gt;4.3.5、事务属性：只读&lt;/h3&gt;
&lt;h4 id=&#34;1介绍-2&#34;&gt;①介绍&lt;/h4&gt;
&lt;p&gt;对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这 样数据库就能够针对查询操作来进行优化。&lt;/p&gt;
&lt;h4 id=&#34;2使用方式&#34;&gt;②使用方式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Transactional(readOnly = true)
public void buyBook(Integer bookId, Integer userId) {
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3注意&#34;&gt;③注意&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对增删改操作设置只读属性会抛出下面异常：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;436-事务属性超时&#34;&gt;4.3.6、事务属性：超时&lt;/h3&gt;
&lt;h4 id=&#34;1介绍-3&#34;&gt;①介绍&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间 占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;概括来说就是一句话：超时就要回滚，释放资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2使用方式-2&#34;&gt;②使用方式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Transactional(timeout = 3)
public void buyBook(Integer bookId, Integer userId) {
    try {
        TimeUnit.SECONDS.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
  
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3观察结果-3&#34;&gt;③观察结果&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;执行过程中抛出异常：&lt;/li&gt;
&lt;li&gt;org.springframework.transaction.&lt;strong&gt;TransactionTimedOutException&lt;/strong&gt;: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2022&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;437-事务属性回滚策略&#34;&gt;4.3.7、事务属性：回滚策略&lt;/h3&gt;
&lt;h4 id=&#34;1介绍-4&#34;&gt;①介绍&lt;/h4&gt;
&lt;p&gt;声明式事务默认只针对运行时异常回滚，编译时异常不回滚。&lt;/p&gt;
&lt;p&gt;可以通过@Transactional中相关属性设置回滚策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rollbackFor&lt;/code&gt;属性：需要设置一个Class类型的对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rollbackForClassName&lt;/code&gt;属性：需要设置一个字符串类型的全类名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noRollbackFor&lt;/code&gt;属性：需要设置一个Class类型的对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noRollbackFoClassNamer&lt;/code&gt;属性：需要设置一个字符串类型的全类名&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2使用方式-3&#34;&gt;②使用方式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Transactional(noRollbackFor = ArithmeticException.class)
//@Transactional(noRollbackForClassName = &amp;quot;java.lang.ArithmeticException&amp;quot;)
public void buyBook(Integer bookId, Integer userId) {
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
  
    //更新图书的库存
    bookDao.updateStock(bookId);
  
    //更新用户的余额
    bookDao.updateBalance(userId, price);
  
    System.out.println(1 / 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3观察结果-4&#34;&gt;③观察结果&lt;/h4&gt;
&lt;p&gt;虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当出现ArithmeticException不发生回滚，因此购买图书的操作正常执行&lt;/p&gt;
&lt;h3 id=&#34;438-事务属性事务隔离级别&#34;&gt;4.3.8、事务属性：事务隔离级别&lt;/h3&gt;
&lt;h4 id=&#34;1介绍-5&#34;&gt;①介绍&lt;/h4&gt;
&lt;p&gt;数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。&lt;/p&gt;
&lt;p&gt;隔离级别一共有四种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读未提交：READ UNCOMMITTED&lt;/p&gt;
&lt;p&gt;允许Transaction01读取Transaction02未提交的修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读已提交：READ COMMITTED&lt;/p&gt;
&lt;p&gt;要求Transaction01只能读取Transaction02已提交的修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重复读：REPEATABLE READ&lt;/p&gt;
&lt;p&gt;确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;串行化：SERIALIZABLE&lt;/p&gt;
&lt;p&gt;确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各个隔离级别解决并发问题的能力见下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;READ UNCOMMITTED&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;READ COMMITTED&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REPEATABLE READ&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;有（MySQL无）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SERIALIZABLE&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;各种数据库产品对事务隔离级别的支持程度：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;Oracle&lt;/th&gt;
&lt;th&gt;MySQL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;READ UNCOMMITTED&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;READ COMMITTED&lt;/td&gt;
&lt;td&gt;√(默认)&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REPEATABLE READ&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√(默认)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SERIALIZABLE&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;2使用方式-4&#34;&gt;②使用方式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别
@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交
@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交
@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读
@Transactional(isolation = Isolation.SERIALIZABLE)//串行化
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;439-事务属性事务传播行为&#34;&gt;4.3.9、事务属性：事务传播行为&lt;/h3&gt;
&lt;h4 id=&#34;1介绍-6&#34;&gt;①介绍&lt;/h4&gt;
&lt;p&gt;当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。&lt;/p&gt;
&lt;h4 id=&#34;2测试-2&#34;&gt;②测试&lt;/h4&gt;
&lt;p&gt;创建接口CheckoutService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface CheckoutService {

    void checkout(Integer[] bookIds, Integer userId);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建实现类CheckoutServiceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class CheckoutServiceImpl implements CheckoutService {
  
    @Autowired
    private BookService bookService;
  
    @Override
    @Transactional
    //一次购买多本图书
    public void checkout(Integer[] bookIds, Integer userId) {
        for (Integer bookId : bookIds) {
            bookService.buyBook(bookId, userId);
        }
    }
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在BookController中添加方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired
private CheckoutService checkoutService;

public void checkout(Integer[] bookIds, Integer userId) {
    checkoutService.checkout(bookIds, userId);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在数据库中将用户的余额修改为100元&lt;/p&gt;
&lt;h4 id=&#34;3观察结果-5&#34;&gt;③观察结果&lt;/h4&gt;
&lt;p&gt;可以通过@Transactional中的&lt;code&gt;propagation属性&lt;/code&gt;设置事务传播行为&lt;/p&gt;
&lt;p&gt;修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Transactional(propagation = Propagation.&lt;code&gt;REQUIRED&lt;/code&gt;)，&lt;strong&gt;默认&lt;/strong&gt;情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，&lt;strong&gt;即只要有一本书买不了，就都买不了&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;@Transactional(propagation = Propagation.&lt;code&gt;REQUIRES_NEW&lt;/code&gt;)，&lt;code&gt;建议使用&lt;/code&gt;。表示不管当前线程上是否有已经开启的事务，都要开启新事务。同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不影响，&lt;strong&gt;即能买几本就买几本&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;44-基于xml的声明式事务&#34;&gt;4.4、基于XML的声明式事务&lt;/h2&gt;
&lt;h3 id=&#34;431-场景模拟&#34;&gt;4.3.1、场景模拟&lt;/h3&gt;
&lt;p&gt;参考基于注解的声明式事务&lt;/p&gt;
&lt;h3 id=&#34;432-修改spring配置文件&#34;&gt;4.3.2、修改Spring配置文件&lt;/h3&gt;
&lt;p&gt;将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;aop:config&amp;gt;
    &amp;lt;!-- 配置事务通知和切入点表达式 --&amp;gt;
    &amp;lt;aop:advisor advice-ref=&amp;quot;txAdvice&amp;quot;
                 pointcut=&amp;quot;execution(* com.atguigu.spring.tx.xml.service.impl.*.*(..))&amp;quot;&amp;gt;&amp;lt;/aop:advisor&amp;gt;
&amp;lt;/aop:config&amp;gt;
&amp;lt;!-- tx:advice标签：配置事务通知 --&amp;gt;
&amp;lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&amp;gt;
&amp;lt;!-- transaction-manager属性：关联事务管理器 --&amp;gt;
&amp;lt;tx:advice id=&amp;quot;txAdvice&amp;quot; transaction-manager=&amp;quot;transactionManager&amp;quot;&amp;gt;
    &amp;lt;tx:attributes&amp;gt;
        &amp;lt;!-- tx:method标签：配置具体的事务方法 --&amp;gt;
        &amp;lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&amp;gt;
        &amp;lt;tx:method name=&amp;quot;get*&amp;quot; read-only=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;tx:method name=&amp;quot;query*&amp;quot; read-only=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;tx:method name=&amp;quot;find*&amp;quot; read-only=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;!-- read-only属性：设置只读属性 --&amp;gt;
        &amp;lt;!-- rollback-for属性：设置回滚的异常 --&amp;gt;
        &amp;lt;!-- no-rollback-for属性：设置不回滚的异常 --&amp;gt;
        &amp;lt;!-- isolation属性：设置事务的隔离级别 --&amp;gt;
        &amp;lt;!-- timeout属性：设置事务的超时属性 --&amp;gt;
        &amp;lt;!-- propagation属性：设置事务的传播行为 --&amp;gt;
        &amp;lt;tx:method name=&amp;quot;save*&amp;quot; read-only=&amp;quot;false&amp;quot; rollbackfor=&amp;quot;java.lang.Exception&amp;quot; propagation=&amp;quot;REQUIRES_NEW&amp;quot;/&amp;gt;
        &amp;lt;tx:method name=&amp;quot;update*&amp;quot; read-only=&amp;quot;false&amp;quot; rollbackfor=&amp;quot;java.lang.Exception&amp;quot; propagation=&amp;quot;REQUIRES_NEW&amp;quot;/&amp;gt;
        &amp;lt;tx:method name=&amp;quot;delete*&amp;quot; read-only=&amp;quot;false&amp;quot; rollbackfor=&amp;quot;java.lang.Exception&amp;quot; propagation=&amp;quot;REQUIRES_NEW&amp;quot;/&amp;gt;
    &amp;lt;/tx:attributes&amp;gt;
&amp;lt;/tx:advice&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：基于xml实现的声明式事务，必须引入aspectJ的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-aspects&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;5-spring5-新特性&#34;&gt;5、Spring5 新特性&lt;/h1&gt;
&lt;h2 id=&#34;51-jsr305标准相关注解&#34;&gt;5.1、JSR305标准相关注解&lt;/h2&gt;
&lt;h2 id=&#34;52-整合junit5&#34;&gt;5.2、整合junit5&lt;/h2&gt;
">Spring笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/springmvc-bi-ji/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;视频课程链接：&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1Ry4y1574R&#34;&gt;🔗bilibili（分集观看更方便）&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=pS5HrZuvXLc&amp;amp;list=PLmOn9nNkQxJE3V_Eev79ao-g3a6BplSQG&#34;&gt;🔗YouTube（下载资料更方便）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;一-springmvc简介&#34;&gt;一、SpringMVC简介&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是mvc&#34;&gt;1、什么是MVC&lt;/h2&gt;
&lt;p&gt;MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分&lt;/p&gt;
&lt;p&gt;M：Model，模型层，指工程中的JavaBean，作用是处理数据&lt;/p&gt;
&lt;p&gt;JavaBean分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一类称为实体类Bean：专门存储业务数据的，如 Student、User 等&lt;/li&gt;
&lt;li&gt;一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据&lt;/p&gt;
&lt;p&gt;C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器&lt;/p&gt;
&lt;p&gt;MVC的工作流程：&lt;br&gt;
用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器&lt;/p&gt;
&lt;h2 id=&#34;2-什么是springmvc&#34;&gt;2、什么是SpringMVC&lt;/h2&gt;
&lt;p&gt;SpringMVC是Spring的一个后续产品，是Spring的一个子项目&lt;/p&gt;
&lt;p&gt;SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目&lt;strong&gt;表述层&lt;/strong&gt;开发的&lt;strong&gt;首选方案&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层.表述层表示前台页面和后台servlet&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表述层框架要解决的基本问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求映射&lt;/li&gt;
&lt;li&gt;数据输入&lt;/li&gt;
&lt;li&gt;视图界面&lt;/li&gt;
&lt;li&gt;请求分发&lt;/li&gt;
&lt;li&gt;表单回显&lt;/li&gt;
&lt;li&gt;会话控制&lt;/li&gt;
&lt;li&gt;过滤拦截&lt;/li&gt;
&lt;li&gt;异步交互&lt;/li&gt;
&lt;li&gt;文件上传&lt;/li&gt;
&lt;li&gt;文件下载&lt;/li&gt;
&lt;li&gt;数据校验&lt;/li&gt;
&lt;li&gt;类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-springmvc的特点&#34;&gt;3、SpringMVC的特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;mark&gt;Spring 家族原生产品&lt;/mark&gt;，与 IOC 容器等基础设施无缝对接&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;基于原生的Servlet&lt;/mark&gt;，通过了功能强大的&lt;mark&gt;前端控制器DispatcherServlet&lt;/mark&gt;，对请求和响应进行统一处理&lt;/li&gt;
&lt;li&gt;表述层各细分领域需要解决的问题&lt;mark&gt;全方位覆盖&lt;/mark&gt;，提供&lt;mark&gt;全面解决方案&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;代码清新简洁&lt;/mark&gt;，大幅度提升开发效率&lt;/li&gt;
&lt;li&gt;内部组件化程度高，可插拔式组件&lt;mark&gt;即插即用&lt;/mark&gt;，想要什么功能配置相应组件即可&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;性能卓著&lt;/mark&gt;，尤其适合现代大型、超大型互联网项目要求&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二-helloworld&#34;&gt;二、HelloWorld&lt;/h1&gt;
&lt;h2 id=&#34;1-开发环境&#34;&gt;1、开发环境&lt;/h2&gt;
&lt;p&gt;IDE：idea 2019.2&lt;/p&gt;
&lt;p&gt;构建工具：maven3.5.4&lt;/p&gt;
&lt;p&gt;服务器：tomcat7&lt;/p&gt;
&lt;p&gt;Spring版本：5.3.1&lt;/p&gt;
&lt;h2 id=&#34;2-创建maven工程&#34;&gt;2、创建maven工程&lt;/h2&gt;
&lt;h3 id=&#34;a添加web模块&#34;&gt;a&amp;gt;添加web模块&lt;/h3&gt;
&lt;h3 id=&#34;b打包方式war&#34;&gt;b&amp;gt;打包方式：war&lt;/h3&gt;
&lt;h3 id=&#34;c引入依赖&#34;&gt;c&amp;gt;引入依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;!-- SpringMVC --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- 日志 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- ServletAPI --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Spring5和Thymeleaf整合包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.thymeleaf&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;thymeleaf-spring5&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.0.12.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220715092439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-配置webxml&#34;&gt;3、配置web.xml&lt;/h2&gt;
&lt;p&gt;注册SpringMVC的前端控制器DispatcherServlet&lt;/p&gt;
&lt;h3 id=&#34;a默认配置方式&#34;&gt;a&amp;gt;默认配置方式&lt;/h3&gt;
&lt;p&gt;此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&amp;lt;servlet-name&amp;gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&amp;gt;
&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt;
    &amp;lt;!--
        设置springMVC的核心控制器所能处理的请求的请求路径
        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径
        但是/不能匹配.jsp请求路径的请求
    --&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;b扩展配置方式&#34;&gt;b&amp;gt;扩展配置方式&lt;/h3&gt;
&lt;p&gt;可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&amp;gt;
&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;!-- contextConfigLocation为固定值 --&amp;gt;
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
        &amp;lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&amp;gt;
        &amp;lt;param-value&amp;gt;classpath:springMVC.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;!-- 
 		作为框架的核心组件，在启动过程中有大量的初始化操作要做
		而这些操作放在第一次请求时才执行会严重影响访问速度
		因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时
	--&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt;
    &amp;lt;!--
        设置springMVC的核心控制器所能处理的请求的请求路径
        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径
        但是/不能匹配.jsp请求路径的请求
    --&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;&amp;lt;url-pattern&amp;gt;标签中使用/和/*的区别：&lt;/p&gt;
&lt;p&gt;/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求&lt;/p&gt;
&lt;p&gt;因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面&lt;/p&gt;
&lt;p&gt;/*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-创建请求控制器&#34;&gt;4、创建请求控制器&lt;/h2&gt;
&lt;p&gt;由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器&lt;/p&gt;
&lt;p&gt;请求控制器中每一个处理请求的方法成为控制器方法&lt;/p&gt;
&lt;p&gt;因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class HelloController {
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-创建springmvc的配置文件&#34;&gt;5、创建springMVC的配置文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 自动扫描包 --&amp;gt;
&amp;lt;context:component-scan base-package=&amp;quot;com.atguigu.mvc.controller&amp;quot;/&amp;gt;

&amp;lt;!-- 配置Thymeleaf视图解析器 --&amp;gt;
&amp;lt;bean id=&amp;quot;viewResolver&amp;quot; class=&amp;quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;order&amp;quot; value=&amp;quot;1&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;characterEncoding&amp;quot; value=&amp;quot;UTF-8&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;templateEngine&amp;quot;&amp;gt;
        &amp;lt;bean class=&amp;quot;org.thymeleaf.spring5.SpringTemplateEngine&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;templateResolver&amp;quot;&amp;gt;
                &amp;lt;bean class=&amp;quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&amp;quot;&amp;gt;
    
                    &amp;lt;!-- 视图前缀 --&amp;gt;
                    &amp;lt;property name=&amp;quot;prefix&amp;quot; value=&amp;quot;/WEB-INF/templates/&amp;quot;/&amp;gt;
    
                    &amp;lt;!-- 视图后缀 --&amp;gt;
                    &amp;lt;property name=&amp;quot;suffix&amp;quot; value=&amp;quot;.html&amp;quot;/&amp;gt;
                    &amp;lt;property name=&amp;quot;templateMode&amp;quot; value=&amp;quot;HTML5&amp;quot;/&amp;gt;
                    &amp;lt;property name=&amp;quot;characterEncoding&amp;quot; value=&amp;quot;UTF-8&amp;quot; /&amp;gt;
                &amp;lt;/bean&amp;gt;
            &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!-- 
   处理静态资源，例如html、js、css、jpg
  若只设置该标签，则只能访问静态资源，其他请求则无法访问
  此时必须设置&amp;lt;mvc:annotation-driven/&amp;gt;解决问题
 --&amp;gt;
&amp;lt;mvc:default-servlet-handler/&amp;gt;

&amp;lt;!-- 开启mvc注解驱动 --&amp;gt;
&amp;lt;mvc:annotation-driven&amp;gt;
    &amp;lt;mvc:message-converters&amp;gt;
        &amp;lt;!-- 处理响应中文内容乱码 --&amp;gt;
        &amp;lt;bean class=&amp;quot;org.springframework.http.converter.StringHttpMessageConverter&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;defaultCharset&amp;quot; value=&amp;quot;UTF-8&amp;quot; /&amp;gt;
            &amp;lt;property name=&amp;quot;supportedMediaTypes&amp;quot;&amp;gt;
                &amp;lt;list&amp;gt;
                    &amp;lt;value&amp;gt;text/html&amp;lt;/value&amp;gt;
                    &amp;lt;value&amp;gt;application/json&amp;lt;/value&amp;gt;
                &amp;lt;/list&amp;gt;
            &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;/mvc:message-converters&amp;gt;
&amp;lt;/mvc:annotation-driven&amp;gt;

&amp;lt;!-- 处理CORS --&amp;gt;
&amp;lt;mvc:cors&amp;gt;
    &amp;lt;!--
        allowed-origins: &amp;lt;origin&amp;gt; | *
        其中，origin 参数的值指定允许访问该资源的外域 origin 域名。
        对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符*，表示允许来自所有域的请求。
    --&amp;gt;
    &amp;lt;!--&amp;lt;mvc:mapping path=&amp;quot;/**&amp;quot; allowed-origins=&amp;quot;http:/z/example.com/&amp;quot; allowed-methods=&amp;quot;GET,POST&amp;quot; max-age=&amp;quot;3600&amp;quot;/&amp;gt;--&amp;gt;
    &amp;lt;!--
        allowed-origin-patterns
        替代llowed-origins，此属性允许更灵活的模式，例如 *.domain1.com
    --&amp;gt;
    &amp;lt;mvc:mapping path=&amp;quot;/**&amp;quot; allowed-origin-patterns=&amp;quot;http://localhost:*&amp;quot; allowed-methods=&amp;quot;GET,POST&amp;quot; max-age=&amp;quot;3600&amp;quot;/&amp;gt;
&amp;lt;/mvc:cors&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-测试helloworld&#34;&gt;6、测试HelloWorld&lt;/h2&gt;
&lt;h3 id=&#34;a实现对首页的访问&#34;&gt;a&amp;gt;实现对首页的访问&lt;/h3&gt;
&lt;p&gt;在请求控制器中创建处理请求的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// @RequestMapping注解：处理请求和控制器方法之间的映射关系
// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径
// localhost:8080/springMVC/
@RequestMapping(&amp;quot;/&amp;quot;)
public String index() {
    //设置视图名称
    return &amp;quot;index&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;b通过超链接跳转到指定页面&#34;&gt;b&amp;gt;通过超链接跳转到指定页面&lt;/h3&gt;
&lt;p&gt;在主页index.html中设置超链接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;首页&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;首页&amp;lt;/h1&amp;gt;
    &amp;lt;a th:href=&amp;quot;@{/hello}&amp;quot;&amp;gt;HelloWorld&amp;lt;/a&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在请求控制器中创建处理请求的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/hello&amp;quot;)
public String HelloWorld() {
    return &amp;quot;target&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-总结&#34;&gt;7、总结&lt;/h2&gt;
&lt;p&gt;浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面&lt;/p&gt;
&lt;h1 id=&#34;三-requestmapping注解&#34;&gt;三、@RequestMapping注解&lt;/h1&gt;
&lt;h2 id=&#34;1-requestmapping注解的功能&#34;&gt;1、@RequestMapping注解的功能&lt;/h2&gt;
&lt;p&gt;从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。&lt;/p&gt;
&lt;p&gt;SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。&lt;/p&gt;
&lt;h2 id=&#34;2-requestmapping注解的位置&#34;&gt;2、@RequestMapping注解的位置&lt;/h2&gt;
&lt;p&gt;@RequestMapping标识一个类：设置映射请求的请求路径的初始信息&lt;/p&gt;
&lt;p&gt;@RequestMapping标识一个方法：设置映射请求请求路径的具体信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(&amp;quot;/test&amp;quot;)
public class RequestMappingController {

	//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping
    @RequestMapping(&amp;quot;/testRequestMapping&amp;quot;)
    public String testRequestMapping(){
        return &amp;quot;success&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-requestmapping注解的value属性&#34;&gt;3、@RequestMapping注解的value属性&lt;/h2&gt;
&lt;p&gt;@RequestMapping注解的value属性通过请求的请求地址匹配请求映射&lt;/p&gt;
&lt;p&gt;@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求&lt;/p&gt;
&lt;p&gt;@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a th:href=&amp;quot;@{/testRequestMapping}&amp;quot;&amp;gt;测试@RequestMapping的value属性--&amp;gt;/testRequestMapping&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;a th:href=&amp;quot;@{/test}&amp;quot;&amp;gt;测试@RequestMapping的value属性--&amp;gt;/test&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(
        value = {&amp;quot;/testRequestMapping&amp;quot;, &amp;quot;/test&amp;quot;}
)
public String testRequestMapping(){
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-requestmapping注解的method属性&#34;&gt;4、@RequestMapping注解的method属性&lt;/h2&gt;
&lt;p&gt;@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射&lt;/p&gt;
&lt;p&gt;@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求&lt;/p&gt;
&lt;p&gt;若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method &#39;POST&#39; not supported&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a th:href=&amp;quot;@{/test}&amp;quot;&amp;gt;测试@RequestMapping的value属性--&amp;gt;/test&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;form th:action=&amp;quot;@{/test}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(
        value = {&amp;quot;/testRequestMapping&amp;quot;, &amp;quot;/test&amp;quot;},
        method = {RequestMethod.GET, RequestMethod.POST}
)
public String testRequestMapping(){
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解&lt;/p&gt;
&lt;p&gt;处理get请求的映射--&amp;gt;@GetMapping&lt;/p&gt;
&lt;p&gt;处理post请求的映射--&amp;gt;@PostMapping&lt;/p&gt;
&lt;p&gt;处理put请求的映射--&amp;gt;@PutMapping&lt;/p&gt;
&lt;p&gt;处理delete请求的映射--&amp;gt;@DeleteMapping&lt;/p&gt;
&lt;p&gt;2、常用的请求方式有get，post，put，delete&lt;/p&gt;
&lt;p&gt;但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理&lt;/p&gt;
&lt;p&gt;若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-requestmapping注解的params属性了解&#34;&gt;5、@RequestMapping注解的params属性（了解）&lt;/h2&gt;
&lt;p&gt;@RequestMapping注解的params属性通过请求的请求参数匹配请求映射&lt;/p&gt;
&lt;p&gt;@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系&lt;/p&gt;
&lt;p&gt;&amp;quot;param&amp;quot;：要求请求映射所匹配的请求必须携带param请求参数&lt;/p&gt;
&lt;p&gt;&amp;quot;!param&amp;quot;：要求请求映射所匹配的请求必须不能携带param请求参数&lt;/p&gt;
&lt;p&gt;&amp;quot;param=value&amp;quot;：要求请求映射所匹配的请求必须携带param请求参数且param=value&lt;/p&gt;
&lt;p&gt;&amp;quot;param!=value&amp;quot;：要求请求映射所匹配的请求必须携带param请求参数但是param!=value&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a th:href=&amp;quot;@{/test(username=&#39;admin&#39;,password=123456)&amp;quot;&amp;gt;测试@RequestMapping的params属性--&amp;gt;/test&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(
        value = {&amp;quot;/testRequestMapping&amp;quot;, &amp;quot;/test&amp;quot;}
        ,method = {RequestMethod.GET, RequestMethod.POST}
        ,params = {&amp;quot;username&amp;quot;,&amp;quot;password!=123456&amp;quot;}
)
public String testRequestMapping(){
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions &amp;quot;username, password!=123456&amp;quot; not met for actual request parameters: username={admin}, password={123456}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;6-requestmapping注解的headers属性了解&#34;&gt;6、@RequestMapping注解的headers属性（了解）&lt;/h2&gt;
&lt;p&gt;@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射&lt;/p&gt;
&lt;p&gt;@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系&lt;/p&gt;
&lt;p&gt;&amp;quot;header&amp;quot;：要求请求映射所匹配的请求必须携带header请求头信息&lt;/p&gt;
&lt;p&gt;&amp;quot;!header&amp;quot;：要求请求映射所匹配的请求必须不能携带header请求头信息&lt;/p&gt;
&lt;p&gt;&amp;quot;header=value&amp;quot;：要求请求映射所匹配的请求必须携带header请求头信息且header=value&lt;/p&gt;
&lt;p&gt;&amp;quot;header!=value&amp;quot;：要求请求映射所匹配的请求必须携带header请求头信息且header!=value&lt;/p&gt;
&lt;p&gt;若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到&lt;/p&gt;
&lt;h2 id=&#34;7-springmvc支持ant风格的路径&#34;&gt;7、SpringMVC支持ant风格的路径&lt;/h2&gt;
&lt;p&gt;？：表示任意的单个字符&lt;/p&gt;
&lt;p&gt;*：表示任意的0个或多个字符&lt;/p&gt;
&lt;p&gt;**：表示任意的一层或多层目录&lt;/p&gt;
&lt;p&gt;注意：在使用**时，只能使用/**/xxx的方式&lt;/p&gt;
&lt;h2 id=&#34;8-springmvc支持路径中的占位符重点&#34;&gt;8、SpringMVC支持路径中的占位符（重点）&lt;/h2&gt;
&lt;p&gt;原始方式：/deleteUser?id=1&lt;/p&gt;
&lt;p&gt;rest方式：/deleteUser/1&lt;/p&gt;
&lt;p&gt;SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与 @RequestParam 类似的，若占位符名称与形参名称相同，则无须填写 @PathVariable 的 value 属性&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a th:href=&amp;quot;@{/testRest/1/admin}&amp;quot;&amp;gt;测试路径中的占位符--&amp;gt;/testRest&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testRest/{id}/{username}&amp;quot;)
public String testRest(@PathVariable(&amp;quot;id&amp;quot;) String id, @PathVariable(&amp;quot;username&amp;quot;) String username){
    System.out.println(&amp;quot;id:&amp;quot;+id+&amp;quot;,username:&amp;quot;+username);
    return &amp;quot;success&amp;quot;;
}
//最终输出的内容为--&amp;gt;id:1,username:admin
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-springmvc获取请求参数&#34;&gt;四、SpringMVC获取请求参数&lt;/h1&gt;
&lt;h2 id=&#34;1-通过servletapi获取&#34;&gt;1、通过ServletAPI获取&lt;/h2&gt;
&lt;p&gt;将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testParam&amp;quot;)
public String testParam(HttpServletRequest request){
    String username = request.getParameter(&amp;quot;username&amp;quot;);
    String password = request.getParameter(&amp;quot;password&amp;quot;);
    System.out.println(&amp;quot;username:&amp;quot;+username+&amp;quot;,password:&amp;quot;+password);
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-通过控制器方法的形参获取请求参数&#34;&gt;2、通过控制器方法的形参获取请求参数&lt;/h2&gt;
&lt;p&gt;在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a th:href=&amp;quot;@{/testParam(username=&#39;admin&#39;,password=123456)}&amp;quot;&amp;gt;测试获取请求参数--&amp;gt;/testParam&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testParam&amp;quot;)
public String testParam(String username, String password){
    System.out.println(&amp;quot;username:&amp;quot;+username+&amp;quot;,password:&amp;quot;+password);
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数&lt;/p&gt;
&lt;p&gt;若使用字符串数组类型的形参，此参数的数组中包含了每一个数据&lt;/p&gt;
&lt;p&gt;若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-requestparam&#34;&gt;3、@RequestParam&lt;/h2&gt;
&lt;p&gt;@RequestParam是将请求参数和控制器方法的形参创建映射关系&lt;/p&gt;
&lt;p&gt;@RequestParam注解一共有三个属性：&lt;/p&gt;
&lt;p&gt;value：指定为形参赋值的请求参数的参数名&lt;/p&gt;
&lt;p&gt;required：设置是否必须传输此请求参数，默认值为true&lt;/p&gt;
&lt;p&gt;若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter &#39;xxx&#39; is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null&lt;/p&gt;
&lt;p&gt;defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为&amp;quot;&amp;quot;时，则使用默认值为形参赋值&lt;/p&gt;
&lt;h2 id=&#34;4-requestheader&#34;&gt;4、@RequestHeader&lt;/h2&gt;
&lt;p&gt;@RequestHeader是将请求头信息和控制器方法的形参创建映射关系&lt;/p&gt;
&lt;p&gt;@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam&lt;/p&gt;
&lt;h2 id=&#34;5-cookievalue&#34;&gt;5、@CookieValue&lt;/h2&gt;
&lt;p&gt;@CookieValue是将cookie数据和控制器方法的形参创建映射关系&lt;/p&gt;
&lt;p&gt;@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam&lt;/p&gt;
&lt;h2 id=&#34;6-通过pojo获取请求参数&#34;&gt;6、通过POJO获取请求参数&lt;/h2&gt;
&lt;p&gt;可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form th:action=&amp;quot;@{/testpojo}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    用户名：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    密码：&amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    性别：&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;sex&amp;quot; value=&amp;quot;男&amp;quot;&amp;gt;男&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;sex&amp;quot; value=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;br&amp;gt;
    年龄：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;age&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    邮箱：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;email&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testpojo&amp;quot;)
public String testPOJO(User user){
    System.out.println(user);
    return &amp;quot;success&amp;quot;;
}
//最终结果--&amp;gt;User{id=null, username=&#39;张三&#39;, password=&#39;123&#39;, age=23, sex=&#39;男&#39;, email=&#39;123@qq.com&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-解决获取请求参数的乱码问题&#34;&gt;7、解决获取请求参数的乱码问题&lt;/h2&gt;
&lt;p&gt;解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--配置springMVC的编码过滤器--&amp;gt;
&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
     &amp;lt;!--如果只设置encoding属性参数，则编码过滤器只对request生效--&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
     &amp;lt;!--设置forceResponseEncoding属性参数为true，编码过滤器才对respose生效--&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;forceResponseEncoding&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;五-域对象共享数据&#34;&gt;五、域对象共享数据&lt;/h1&gt;
&lt;h2 id=&#34;1-使用servletapi向request域对象共享数据&#34;&gt;1、使用ServletAPI向request域对象共享数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testServletAPI&amp;quot;)
public String testServletAPI(HttpServletRequest request){
    request.setAttribute(&amp;quot;testScope&amp;quot;, &amp;quot;hello,servletAPI&amp;quot;);
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-使用modelandview向request域对象共享数据&#34;&gt;2、使用ModelAndView向request域对象共享数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testModelAndView&amp;quot;)
public ModelAndView testModelAndView(){
    /**
     * ModelAndView有Model和View的功能
     * Model主要用于向请求域共享数据
     * View主要用于设置视图，实现页面跳转
     */
    ModelAndView mav = new ModelAndView();
    //向请求域共享数据
    mav.addObject(&amp;quot;testScope&amp;quot;, &amp;quot;hello,ModelAndView&amp;quot;);
    //设置视图，实现页面跳转
    mav.setViewName(&amp;quot;success&amp;quot;);
    return mav;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-使用model向request域对象共享数据&#34;&gt;3、使用Model向request域对象共享数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testModel&amp;quot;)
public String testModel(Model model){
    model.addAttribute(&amp;quot;testScope&amp;quot;, &amp;quot;hello,Model&amp;quot;);
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-使用map向request域对象共享数据&#34;&gt;4、使用map向request域对象共享数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testMap&amp;quot;)
public String testMap(Map&amp;lt;String, Object&amp;gt; map){
    map.put(&amp;quot;testScope&amp;quot;, &amp;quot;hello,Map&amp;quot;);
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-使用modelmap向request域对象共享数据&#34;&gt;5、使用ModelMap向request域对象共享数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testModelMap&amp;quot;)
public String testModelMap(ModelMap modelMap){
    modelMap.addAttribute(&amp;quot;testScope&amp;quot;, &amp;quot;hello,ModelMap&amp;quot;);
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-model-modelmap-map的关系&#34;&gt;6、Model、ModelMap、Map的关系&lt;/h2&gt;
&lt;p&gt;Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Model{}
public class ModelMap extends LinkedHashMap&amp;lt;String, Object&amp;gt; {}
public class ExtendedModelMap extends ModelMap implements Model {}
public class BindingAwareModelMap extends ExtendedModelMap {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-向session域共享数据&#34;&gt;7、向session域共享数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testSession&amp;quot;)
public String testSession(HttpSession session){
    session.setAttribute(&amp;quot;testSessionScope&amp;quot;, &amp;quot;hello,session&amp;quot;);
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-向application域共享数据&#34;&gt;8、向application域共享数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testApplication&amp;quot;)
public String testApplication(HttpSession session){
	ServletContext application = session.getServletContext();
    application.setAttribute(&amp;quot;testApplicationScope&amp;quot;, &amp;quot;hello,application&amp;quot;);
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六-springmvc的视图&#34;&gt;六、SpringMVC的视图&lt;/h1&gt;
&lt;p&gt;SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户&lt;/p&gt;
&lt;p&gt;SpringMVC视图的种类很多，默认有转发视图和重定向视图&lt;/p&gt;
&lt;p&gt;当工程引入jstl的依赖，转发视图会自动转换为JstlView&lt;/p&gt;
&lt;p&gt;若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView&lt;/p&gt;
&lt;h2 id=&#34;1-thymeleafview&#34;&gt;1、ThymeleafView&lt;/h2&gt;
&lt;p&gt;当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testHello&amp;quot;)
public String testHello(){
    return &amp;quot;hello&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220715095947.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-转发视图&#34;&gt;2、转发视图&lt;/h2&gt;
&lt;p&gt;SpringMVC中默认的转发视图是InternalResourceView&lt;/p&gt;
&lt;p&gt;SpringMVC中创建转发视图的情况：&lt;/p&gt;
&lt;p&gt;当控制器方法中所设置的视图名称以&amp;quot;forward:&amp;quot;为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀&amp;quot;forward:&amp;quot;去掉，剩余部分作为最终路径通过转发的方式实现跳转&lt;/p&gt;
&lt;p&gt;例如&amp;quot;forward:/&amp;quot;，&amp;quot;forward:/employee&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testForward&amp;quot;)
public String testForward(){
    return &amp;quot;forward:/testHello&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220715100145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-重定向视图&#34;&gt;3、重定向视图&lt;/h2&gt;
&lt;p&gt;SpringMVC中默认的重定向视图是RedirectView&lt;/p&gt;
&lt;p&gt;当控制器方法中所设置的视图名称以&amp;quot;redirect:&amp;quot;为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀&amp;quot;redirect:&amp;quot;去掉，剩余部分作为最终路径通过重定向的方式实现跳转&lt;/p&gt;
&lt;p&gt;例如&amp;quot;redirect:/&amp;quot;，&amp;quot;redirect:/employee&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testRedirect&amp;quot;)
public String testRedirect(){
    return &amp;quot;redirect:/testHello&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220715102446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-视图控制器view-controller&#34;&gt;4、视图控制器view-controller&lt;/h2&gt;
&lt;p&gt;当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
	path：设置处理的请求地址
	view-name：设置请求地址所对应的视图名称
--&amp;gt;
&amp;lt;mvc:view-controller path=&amp;quot;/testView&amp;quot; view-name=&amp;quot;success&amp;quot;&amp;gt;&amp;lt;/mvc:view-controller&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：&lt;/p&gt;
&lt;p&gt;&amp;lt;mvc:annotation-driven /&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;七-restful&#34;&gt;七、RESTful&lt;/h1&gt;
&lt;h2 id=&#34;1-restful简介&#34;&gt;1、RESTful简介&lt;/h2&gt;
&lt;p&gt;REST：&lt;strong&gt;Re&lt;/strong&gt;presentational &lt;strong&gt;S&lt;/strong&gt;tate &lt;strong&gt;T&lt;/strong&gt;ransfer，表现层资源状态转移。&lt;/p&gt;
&lt;h3 id=&#34;a资源&#34;&gt;a&amp;gt;资源&lt;/h3&gt;
&lt;p&gt;资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。&lt;/p&gt;
&lt;h3 id=&#34;b资源的表述&#34;&gt;b&amp;gt;资源的表述&lt;/h3&gt;
&lt;p&gt;资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。&lt;/p&gt;
&lt;h3 id=&#34;c状态转移&#34;&gt;c&amp;gt;状态转移&lt;/h3&gt;
&lt;p&gt;状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。&lt;/p&gt;
&lt;h2 id=&#34;2-restful的实现&#34;&gt;2、RESTful的实现&lt;/h2&gt;
&lt;p&gt;具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。&lt;/p&gt;
&lt;p&gt;它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。&lt;/p&gt;
&lt;p&gt;REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;传统方式&lt;/th&gt;
&lt;th&gt;REST风格&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;查询操作&lt;/td&gt;
&lt;td&gt;getUserById?id=1&lt;/td&gt;
&lt;td&gt;user/1--&amp;gt;get请求方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;保存操作&lt;/td&gt;
&lt;td&gt;saveUser&lt;/td&gt;
&lt;td&gt;user--&amp;gt;post请求方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除操作&lt;/td&gt;
&lt;td&gt;deleteUser?id=1&lt;/td&gt;
&lt;td&gt;user/1--&amp;gt;delete请求方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;更新操作&lt;/td&gt;
&lt;td&gt;updateUser&lt;/td&gt;
&lt;td&gt;user--&amp;gt;put请求方式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3-hiddenhttpmethodfilter&#34;&gt;3、HiddenHttpMethodFilter&lt;/h2&gt;
&lt;p&gt;由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？&lt;/p&gt;
&lt;p&gt;SpringMVC 提供了 &lt;strong&gt;HiddenHttpMethodFilter&lt;/strong&gt; 帮助我们&lt;strong&gt;将 POST 请求转换为 DELETE 或 PUT 请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HiddenHttpMethodFilter&lt;/strong&gt; 处理put和delete请求的条件：&lt;/p&gt;
&lt;p&gt;a&amp;gt;当前请求的请求方式必须为post&lt;/p&gt;
&lt;p&gt;b&amp;gt;当前请求必须传输请求参数_method&lt;/p&gt;
&lt;p&gt;满足以上条件，&lt;strong&gt;HiddenHttpMethodFilter&lt;/strong&gt; 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式&lt;/p&gt;
&lt;p&gt;在web.xml中注册&lt;strong&gt;HiddenHttpMethodFilter&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;HiddenHttpMethodFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.springframework.web.filter.HiddenHttpMethodFilter&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;HiddenHttpMethodFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter&lt;/p&gt;
&lt;p&gt;在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;String paramValue = request.getParameter(this.methodParam);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;八-restful案例&#34;&gt;八、RESTful案例&lt;/h1&gt;
&lt;h2 id=&#34;1-准备工作&#34;&gt;1、准备工作&lt;/h2&gt;
&lt;p&gt;和传统 CRUD 一样，实现对员工信息的增删改查。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;搭建环境&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.atguigu.mvc.bean;

public class Employee {

   private Integer id;
   private String lastName;

   private String email;
   //1 male, 0 female
   private Integer gender;
   
   public Integer getId() {
      return id;
   }

   public void setId(Integer id) {
      this.id = id;
   }

   public String getLastName() {
      return lastName;
   }

   public void setLastName(String lastName) {
      this.lastName = lastName;
   }

   public String getEmail() {
      return email;
   }

   public void setEmail(String email) {
      this.email = email;
   }

   public Integer getGender() {
      return gender;
   }

   public void setGender(Integer gender) {
      this.gender = gender;
   }

   public Employee(Integer id, String lastName, String email, Integer gender) {
      super();
      this.id = id;
      this.lastName = lastName;
      this.email = email;
      this.gender = gender;
   }

   public Employee() {
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备dao模拟数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.atguigu.mvc.dao;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import com.atguigu.mvc.bean.Employee;
import org.springframework.stereotype.Repository;


@Repository
public class EmployeeDao {

   private static Map&amp;lt;Integer, Employee&amp;gt; employees = null;
   
   static{
      employees = new HashMap&amp;lt;Integer, Employee&amp;gt;();

      employees.put(1001, new Employee(1001, &amp;quot;E-AA&amp;quot;, &amp;quot;aa@163.com&amp;quot;, 1));
      employees.put(1002, new Employee(1002, &amp;quot;E-BB&amp;quot;, &amp;quot;bb@163.com&amp;quot;, 1));
      employees.put(1003, new Employee(1003, &amp;quot;E-CC&amp;quot;, &amp;quot;cc@163.com&amp;quot;, 0));
      employees.put(1004, new Employee(1004, &amp;quot;E-DD&amp;quot;, &amp;quot;dd@163.com&amp;quot;, 0));
      employees.put(1005, new Employee(1005, &amp;quot;E-EE&amp;quot;, &amp;quot;ee@163.com&amp;quot;, 1));
   }
   
   private static Integer initId = 1006;
   
   public void save(Employee employee){
      if(employee.getId() == null){
         employee.setId(initId++);
      }
      employees.put(employee.getId(), employee);
   }
   
   public Collection&amp;lt;Employee&amp;gt; getAll(){
      return employees.values();
   }
   
   public Employee get(Integer id){
      return employees.get(id);
   }
   
   public void delete(Integer id){
      employees.remove(id);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-功能清单&#34;&gt;2、功能清单&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;URL 地址&lt;/th&gt;
&lt;th&gt;请求方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;访问首页√&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;查询全部数据√&lt;/td&gt;
&lt;td&gt;/employee&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除√&lt;/td&gt;
&lt;td&gt;/employee/2&lt;/td&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;跳转到添加数据页面√&lt;/td&gt;
&lt;td&gt;/toAdd&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;执行保存√&lt;/td&gt;
&lt;td&gt;/employee&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;跳转到更新数据页面√&lt;/td&gt;
&lt;td&gt;/employee/2&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;执行更新√&lt;/td&gt;
&lt;td&gt;/employee&lt;/td&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3-具体功能访问首页&#34;&gt;3、具体功能：访问首页&lt;/h2&gt;
&lt;h3 id=&#34;a配置view-controller&#34;&gt;a&amp;gt;配置view-controller&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;mvc:view-controller path=&amp;quot;/&amp;quot; view-name=&amp;quot;index&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;b创建页面&#34;&gt;b&amp;gt;创建页面&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; &amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;首页&amp;lt;/h1&amp;gt;
&amp;lt;a th:href=&amp;quot;@{/employee}&amp;quot;&amp;gt;访问员工信息&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-具体功能查询所有员工数据&#34;&gt;4、具体功能：查询所有员工数据&lt;/h2&gt;
&lt;h3 id=&#34;a控制器方法&#34;&gt;a&amp;gt;控制器方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(value = &amp;quot;/employee&amp;quot;, method = RequestMethod.GET)
public String getEmployeeList(Model model){
    Collection&amp;lt;Employee&amp;gt; employeeList = employeeDao.getAll();
    model.addAttribute(&amp;quot;employeeList&amp;quot;, employeeList);
    return &amp;quot;employee_list&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;b创建employee_listhtml&#34;&gt;b&amp;gt;创建employee_list.html&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Employee Info&amp;lt;/title&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; th:src=&amp;quot;@{/static/js/vue.js}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

    &amp;lt;table border=&amp;quot;1&amp;quot; cellpadding=&amp;quot;0&amp;quot; cellspacing=&amp;quot;0&amp;quot; style=&amp;quot;text-align: center;&amp;quot; id=&amp;quot;dataTable&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th colspan=&amp;quot;5&amp;quot;&amp;gt;Employee Info&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;id&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;lastName&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;email&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;gender&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;options(&amp;lt;a th:href=&amp;quot;@{/toAdd}&amp;quot;&amp;gt;add&amp;lt;/a&amp;gt;)&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr th:each=&amp;quot;employee : ${employeeList}&amp;quot;&amp;gt;
            &amp;lt;td th:text=&amp;quot;${employee.id}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${employee.lastName}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${employee.email}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td th:text=&amp;quot;${employee.gender}&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;a class=&amp;quot;deleteA&amp;quot; @click=&amp;quot;deleteEmployee&amp;quot; th:href=&amp;quot;@{&#39;/employee/&#39;+${employee.id}}&amp;quot;&amp;gt;delete&amp;lt;/a&amp;gt;
                &amp;lt;a th:href=&amp;quot;@{&#39;/employee/&#39;+${employee.id}}&amp;quot;&amp;gt;update&amp;lt;/a&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-具体功能删除&#34;&gt;5、具体功能：删除&lt;/h2&gt;
&lt;h3 id=&#34;a创建处理delete请求方式的表单&#34;&gt;a&amp;gt;创建处理delete请求方式的表单&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&amp;gt;
&amp;lt;form id=&amp;quot;delete_form&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    &amp;lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&amp;gt;
    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;_method&amp;quot; value=&amp;quot;delete&amp;quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;b删除超链接绑定点击事件&#34;&gt;b&amp;gt;删除超链接绑定点击事件&lt;/h3&gt;
&lt;p&gt;引入vue.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; th:src=&amp;quot;@{/static/js/vue.js}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除超链接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a class=&amp;quot;deleteA&amp;quot; @click=&amp;quot;deleteEmployee&amp;quot; th:href=&amp;quot;@{&#39;/employee/&#39;+${employee.id}}&amp;quot;&amp;gt;delete&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过vue处理点击事件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    var vue = new Vue({
        el:&amp;quot;#dataTable&amp;quot;,
        methods:{
            //event表示当前事件
            deleteEmployee:function (event) {
                //通过id获取表单标签
                var delete_form = document.getElementById(&amp;quot;delete_form&amp;quot;);
                //将触发事件的超链接的href属性为表单的action属性赋值
                delete_form.action = event.target.href;
                //提交表单
                delete_form.submit();
                //阻止超链接的默认跳转行为
                event.preventDefault();
            }
        }
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;c控制器方法&#34;&gt;c&amp;gt;控制器方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(value = &amp;quot;/employee/{id}&amp;quot;, method = RequestMethod.DELETE)
public String deleteEmployee(@PathVariable(&amp;quot;id&amp;quot;) Integer id){
    employeeDao.delete(id);
    return &amp;quot;redirect:/employee&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-具体功能跳转到添加数据页面&#34;&gt;6、具体功能：跳转到添加数据页面&lt;/h2&gt;
&lt;h3 id=&#34;a配置view-controller-2&#34;&gt;a&amp;gt;配置view-controller&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;mvc:view-controller path=&amp;quot;/toAdd&amp;quot; view-name=&amp;quot;employee_add&amp;quot;&amp;gt;&amp;lt;/mvc:view-controller&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;b创建employee_addhtml&#34;&gt;b&amp;gt;创建employee_add.html&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Add Employee&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;form th:action=&amp;quot;@{/employee}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    lastName:&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;lastName&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    email:&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;email&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    gender:&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;gender&amp;quot; value=&amp;quot;1&amp;quot;&amp;gt;male
    &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;gender&amp;quot; value=&amp;quot;0&amp;quot;&amp;gt;female&amp;lt;br&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;add&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-具体功能执行保存&#34;&gt;7、具体功能：执行保存&lt;/h2&gt;
&lt;h3 id=&#34;a控制器方法-2&#34;&gt;a&amp;gt;控制器方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(value = &amp;quot;/employee&amp;quot;, method = RequestMethod.POST)
public String addEmployee(Employee employee){
    employeeDao.save(employee);
    return &amp;quot;redirect:/employee&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-具体功能跳转到更新数据页面&#34;&gt;8、具体功能：跳转到更新数据页面&lt;/h2&gt;
&lt;h3 id=&#34;a修改超链接&#34;&gt;a&amp;gt;修改超链接&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a th:href=&amp;quot;@{&#39;/employee/&#39;+${employee.id}}&amp;quot;&amp;gt;update&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;b控制器方法&#34;&gt;b&amp;gt;控制器方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(value = &amp;quot;/employee/{id}&amp;quot;, method = RequestMethod.GET)
public String getEmployeeById(@PathVariable(&amp;quot;id&amp;quot;) Integer id, Model model){
    Employee employee = employeeDao.get(id);
    model.addAttribute(&amp;quot;employee&amp;quot;, employee);
    return &amp;quot;employee_update&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;c创建employee_updatehtml&#34;&gt;c&amp;gt;创建employee_update.html&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Update Employee&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;form th:action=&amp;quot;@{/employee}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;_method&amp;quot; value=&amp;quot;put&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;id&amp;quot; th:value=&amp;quot;${employee.id}&amp;quot;&amp;gt;
    lastName:&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;lastName&amp;quot; th:value=&amp;quot;${employee.lastName}&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    email:&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;email&amp;quot; th:value=&amp;quot;${employee.email}&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;!--
        th:field=&amp;quot;${employee.gender}&amp;quot;可用于单选框或复选框的回显
        若单选框的value和employee.gender的值一致，则添加checked=&amp;quot;checked&amp;quot;属性
    --&amp;gt;
    gender:&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;gender&amp;quot; value=&amp;quot;1&amp;quot; th:field=&amp;quot;${employee.gender}&amp;quot;&amp;gt;male
    &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;gender&amp;quot; value=&amp;quot;0&amp;quot; th:field=&amp;quot;${employee.gender}&amp;quot;&amp;gt;female&amp;lt;br&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;update&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-具体功能执行更新&#34;&gt;9、具体功能：执行更新&lt;/h2&gt;
&lt;h3 id=&#34;a控制器方法-3&#34;&gt;a&amp;gt;控制器方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(value = &amp;quot;/employee&amp;quot;, method = RequestMethod.PUT)
public String updateEmployee(Employee employee){
    employeeDao.save(employee);
    return &amp;quot;redirect:/employee&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;八-httpmessageconverter&#34;&gt;八、HttpMessageConverter&lt;/h1&gt;
&lt;p&gt;HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文&lt;/p&gt;
&lt;p&gt;HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，&lt;/p&gt;
&lt;p&gt;ResponseEntity&lt;/p&gt;
&lt;h2 id=&#34;1-requestbody&#34;&gt;1、@RequestBody&lt;/h2&gt;
&lt;p&gt;@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form th:action=&amp;quot;@{/testRequestBody}&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    用户名：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    密码：&amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testRequestBody&amp;quot;)
public String testRequestBody(@RequestBody String requestBody){
    System.out.println(&amp;quot;requestBody:&amp;quot;+requestBody);
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;requestBody:username=admin&amp;amp;password=123456&lt;/p&gt;
&lt;h2 id=&#34;2-requestentity&#34;&gt;2、RequestEntity&lt;/h2&gt;
&lt;p&gt;RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testRequestEntity&amp;quot;)
public String testRequestEntity(RequestEntity&amp;lt;String&amp;gt; requestEntity){
    System.out.println(&amp;quot;requestHeader:&amp;quot;+requestEntity.getHeaders());
    System.out.println(&amp;quot;requestBody:&amp;quot;+requestEntity.getBody());
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;br&gt;
requestHeader:[host:&amp;quot;localhost:8080&amp;quot;, connection:&amp;quot;keep-alive&amp;quot;, content-length:&amp;quot;27&amp;quot;, cache-control:&amp;quot;max-age=0&amp;quot;, sec-ch-ua:&amp;quot;&amp;quot; Not A;Brand&amp;quot;;v=&amp;quot;99&amp;quot;, &amp;quot;Chromium&amp;quot;;v=&amp;quot;90&amp;quot;, &amp;quot;Google Chrome&amp;quot;;v=&amp;quot;90&amp;quot;&amp;quot;, sec-ch-ua-mobile:&amp;quot;?0&amp;quot;, upgrade-insecure-requests:&amp;quot;1&amp;quot;, origin:&amp;quot;http://localhost:8080&amp;quot;, user-agent:&amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&amp;quot;]&lt;br&gt;
requestBody:username=admin&amp;amp;password=123&lt;/p&gt;
&lt;h2 id=&#34;3-responsebody&#34;&gt;3、@ResponseBody&lt;/h2&gt;
&lt;p&gt;@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testResponseBody&amp;quot;)
@ResponseBody
public String testResponseBody(){
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：浏览器页面显示success&lt;/p&gt;
&lt;h2 id=&#34;4-springmvc处理json&#34;&gt;4、SpringMVC处理json&lt;/h2&gt;
&lt;p&gt;@ResponseBody处理json的步骤：&lt;/p&gt;
&lt;p&gt;a&amp;gt;导入jackson的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.12.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b&amp;gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;mvc:annotation-driven /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c&amp;gt;在处理器方法上使用@ResponseBody注解进行标识&lt;/p&gt;
&lt;p&gt;d&amp;gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testResponseUser&amp;quot;)
@ResponseBody
public User testResponseUser(){
    return new User(1001,&amp;quot;admin&amp;quot;,&amp;quot;123456&amp;quot;,23,&amp;quot;男&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浏览器的页面中展示的结果：&lt;/p&gt;
&lt;p&gt;{&amp;quot;id&amp;quot;:1001,&amp;quot;username&amp;quot;:&amp;quot;admin&amp;quot;,&amp;quot;password&amp;quot;:&amp;quot;123456&amp;quot;,&amp;quot;age&amp;quot;:23,&amp;quot;sex&amp;quot;:&amp;quot;男&amp;quot;}&lt;/p&gt;
&lt;h2 id=&#34;5-springmvc处理ajax&#34;&gt;5、SpringMVC处理ajax&lt;/h2&gt;
&lt;p&gt;a&amp;gt;请求超链接：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
	&amp;lt;a th:href=&amp;quot;@{/testAjax}&amp;quot; @click=&amp;quot;testAjax&amp;quot;&amp;gt;testAjax&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b&amp;gt;通过vue和axios处理点击事件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; th:src=&amp;quot;@{/static/js/vue.js}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; th:src=&amp;quot;@{/static/js/axios.min.js}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    var vue = new Vue({
        el:&amp;quot;#app&amp;quot;,
        methods:{
            testAjax:function (event) {
                axios({
                    method:&amp;quot;post&amp;quot;,
                    url:event.target.href,
                    params:{
                        username:&amp;quot;admin&amp;quot;,
                        password:&amp;quot;123456&amp;quot;
                    }
                }).then(function (response) {
                    alert(response.data);
                });
                event.preventDefault();
            }
        }
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c&amp;gt;控制器方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testAjax&amp;quot;)
@ResponseBody
public String testAjax(String username, String password){
    System.out.println(&amp;quot;username:&amp;quot;+username+&amp;quot;,password:&amp;quot;+password);
    return &amp;quot;hello,ajax&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-restcontroller注解&#34;&gt;6、@RestController注解&lt;/h2&gt;
&lt;p&gt;@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解&lt;/p&gt;
&lt;h2 id=&#34;7-responseentity&#34;&gt;7、ResponseEntity&lt;/h2&gt;
&lt;p&gt;ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文&lt;/p&gt;
&lt;h1 id=&#34;九-文件上传和下载&#34;&gt;九、文件上传和下载&lt;/h1&gt;
&lt;h2 id=&#34;1-文件下载&#34;&gt;1、文件下载&lt;/h2&gt;
&lt;p&gt;使用ResponseEntity实现下载文件的功能&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testDown&amp;quot;)
public ResponseEntity&amp;lt;byte[]&amp;gt; testResponseEntity(HttpSession session) throws IOException {
    //获取ServletContext对象
    ServletContext servletContext = session.getServletContext();
    //获取服务器中文件的真实路径
    String realPath = servletContext.getRealPath(&amp;quot;/static/img/1.jpg&amp;quot;);
    // 创建输入流
    //InputStream is = new FileInputStream(realPath);
    InputStream is = Files.newInputStream(Paths.get(realPath));
    //创建字节数组
    byte[] bytes = new byte[is.available()];
    //将流读到字节数组中
    is.read(bytes);
    //创建HttpHeaders对象设置响应头信息
    MultiValueMap&amp;lt;String, String&amp;gt; headers = new HttpHeaders();
    //设置要下载方式以及下载文件的名字
    headers.add(&amp;quot;Content-Disposition&amp;quot;, &amp;quot;attachment;filename=1.jpg&amp;quot;);
    //设置响应状态码
    HttpStatus statusCode = HttpStatus.OK;
    //创建ResponseEntity对象
    ResponseEntity&amp;lt;byte[]&amp;gt; responseEntity = new ResponseEntity&amp;lt;&amp;gt;(bytes, headers, statusCode);
    //关闭输入流
    is.close();
    return responseEntity;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-文件上传&#34;&gt;2、文件上传&lt;/h2&gt;
&lt;p&gt;文件上传要求form表单的请求方式必须为post，并且添加属性enctype=&amp;quot;multipart/form-data&amp;quot;&lt;/p&gt;
&lt;p&gt;SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息&lt;/p&gt;
&lt;p&gt;上传步骤：&lt;/p&gt;
&lt;p&gt;a&amp;gt;添加依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b&amp;gt;在SpringMVC的配置文件中添加配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&amp;gt;
&amp;lt;bean id=&amp;quot;multipartResolver&amp;quot; class=&amp;quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c&amp;gt;控制器方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/testUp&amp;quot;)
public String testUp(MultipartFile photo, HttpSession session) throws IOException {
    //获取上传的文件的文件名
    String fileName = photo.getOriginalFilename();
    //处理文件重名问题
    String suffixName = fileName.substring(fileName.lastIndexOf(&amp;quot;.&amp;quot;));
    fileName = UUID.randomUUID().toString() + suffixName;
    //获取服务器中photo目录的路径
    ServletContext servletContext = session.getServletContext();
    String photoPath = servletContext.getRealPath(&amp;quot;photo&amp;quot;);
    File file = new File(photoPath);
    if(!file.exists()){
        file.mkdir();
    }
    String finalPath = photoPath + File.separator + fileName;
    //实现上传功能
    photo.transferTo(new File(finalPath));
    return &amp;quot;success&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;十-拦截器&#34;&gt;十、拦截器&lt;/h1&gt;
&lt;h2 id=&#34;1-拦截器的配置&#34;&gt;1、拦截器的配置&lt;/h2&gt;
&lt;p&gt;SpringMVC中的拦截器用于拦截控制器方法的执行&lt;/p&gt;
&lt;p&gt;SpringMVC中的拦截器需要实现HandlerInterceptor接口&lt;/p&gt;
&lt;p&gt;SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean class=&amp;quot;com.atguigu.interceptor.FirstInterceptor&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;ref bean=&amp;quot;firstInterceptor&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
&amp;lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&amp;gt;
&amp;lt;mvc:interceptor&amp;gt;
    &amp;lt;mvc:mapping path=&amp;quot;/**&amp;quot;/&amp;gt;
    &amp;lt;mvc:exclude-mapping path=&amp;quot;/testRequestEntity&amp;quot;/&amp;gt;
    &amp;lt;ref bean=&amp;quot;firstInterceptor&amp;quot;&amp;gt;&amp;lt;/ref&amp;gt;
&amp;lt;/mvc:interceptor&amp;gt;
&amp;lt;!-- 
	以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-拦截器的三个抽象方法&#34;&gt;2、拦截器的三个抽象方法&lt;/h2&gt;
&lt;p&gt;SpringMVC中的拦截器有三个抽象方法：&lt;/p&gt;
&lt;p&gt;preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法&lt;/p&gt;
&lt;p&gt;postHandle：控制器方法执行之后执行postHandle()&lt;/p&gt;
&lt;p&gt;afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()&lt;/p&gt;
&lt;h2 id=&#34;3-多个拦截器的执行顺序&#34;&gt;3、多个拦截器的执行顺序&lt;/h2&gt;
&lt;p&gt;a&amp;gt;若每个拦截器的preHandle()都返回true&lt;/p&gt;
&lt;p&gt;此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：&lt;/p&gt;
&lt;p&gt;preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行&lt;/p&gt;
&lt;p&gt;b&amp;gt;若某个拦截器的preHandle()返回了false&lt;/p&gt;
&lt;p&gt;preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行&lt;/p&gt;
&lt;h1 id=&#34;十一-异常处理器&#34;&gt;十一、异常处理器&lt;/h1&gt;
&lt;h2 id=&#34;1-基于配置的异常处理&#34;&gt;1、基于配置的异常处理&lt;/h2&gt;
&lt;p&gt;SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver&lt;/p&gt;
&lt;p&gt;HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver&lt;/p&gt;
&lt;p&gt;SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean class=&amp;quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;exceptionMappings&amp;quot;&amp;gt;
        &amp;lt;props&amp;gt;
        	&amp;lt;!--
        		properties的键表示处理器方法执行过程中出现的异常
        		properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面
        	--&amp;gt;
            &amp;lt;prop key=&amp;quot;java.lang.ArithmeticException&amp;quot;&amp;gt;error&amp;lt;/prop&amp;gt;
        &amp;lt;/props&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!--
    	exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享
    --&amp;gt;
    &amp;lt;property name=&amp;quot;exceptionAttribute&amp;quot; value=&amp;quot;ex&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-基于注解的异常处理&#34;&gt;2、基于注解的异常处理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// @ControllerAdvice将当前类标识为异常处理的组件
// 或 @RestControllerAdvice，将当前类标识为异常处理的组件，同时将该方法的返回值直接作为响应报文的响应体响应到浏览器
@ControllerAdvice
public class ExceptionController {

    // @ExceptionHandler用于设置所标识方法处理的异常
    @ExceptionHandler(ArithmeticException.class)
    //ex表示当前请求处理中出现的异常对象
    public String handleArithmeticException(Exception ex, Model model){
      	// 我们可以自己手动将异常对象存入模型
        model.addAttribute(&amp;quot;ex&amp;quot;, ex);
        return &amp;quot;error&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;十二-注解配置springmvc&#34;&gt;十二、注解配置SpringMVC&lt;/h1&gt;
&lt;p&gt;使用配置类和注解代替web.xml和SpringMVC配置文件的功能&lt;/p&gt;
&lt;h2 id=&#34;1-创建初始化类代替webxml&#34;&gt;1、创建初始化类，代替web.xml&lt;/h2&gt;
&lt;p&gt;在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。&lt;br&gt;
Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {

    /**
     * 指定spring的配置类
     * @return
     */
    @Override
    protected Class&amp;lt;?&amp;gt;[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    /**
     * 指定SpringMVC的配置类
     * @return
     */
    @Override
    protected Class&amp;lt;?&amp;gt;[] getServletConfigClasses() {
        return new Class[]{WebConfig.class};
    }

    /**
     * 指定DispatcherServlet的映射规则，即url-pattern
     * @return
     */
    @Override
    protected String[] getServletMappings() {
        return new String[]{&amp;quot;/&amp;quot;};
    }

    /**
     * 添加过滤器
     * @return
     */
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();
        encodingFilter.setEncoding(&amp;quot;UTF-8&amp;quot;);
        encodingFilter.setForceRequestEncoding(true);
        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();
        return new Filter[]{encodingFilter, hiddenHttpMethodFilter};
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-创建springconfig配置类代替spring的配置文件&#34;&gt;2、创建SpringConfig配置类，代替spring的配置文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SpringConfig {
	//ssm整合之后，spring的配置信息写在此类中
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-创建webconfig配置类代替springmvc的配置文件&#34;&gt;3、创建WebConfig配置类，代替SpringMVC的配置文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
//扫描组件
@ComponentScan(&amp;quot;com.atguigu.mvc.controller&amp;quot;)
//开启MVC注解驱动
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    //使用默认的servlet处理静态资源
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }

    //配置文件上传解析器
    @Bean
    public CommonsMultipartResolver multipartResolver(){
        return new CommonsMultipartResolver();
    }

    //配置拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        FirstInterceptor firstInterceptor = new FirstInterceptor();
        registry.addInterceptor(firstInterceptor).addPathPatterns(&amp;quot;/**&amp;quot;);
    }
    
    //配置视图控制
    
    /*@Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController(&amp;quot;/&amp;quot;).setViewName(&amp;quot;index&amp;quot;);
    }*/
    
    //配置异常映射
    /*@Override
    public void configureHandlerExceptionResolvers(List&amp;lt;HandlerExceptionResolver&amp;gt; resolvers) {
        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();
        Properties prop = new Properties();
        prop.setProperty(&amp;quot;java.lang.ArithmeticException&amp;quot;, &amp;quot;error&amp;quot;);
        //设置异常映射
        exceptionResolver.setExceptionMappings(prop);
        //设置共享异常信息的键
        exceptionResolver.setExceptionAttribute(&amp;quot;ex&amp;quot;);
        resolvers.add(exceptionResolver);
    }*/

    //配置生成模板解析器
    @Bean
    public ITemplateResolver templateResolver() {
        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();
        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得
        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(
                webApplicationContext.getServletContext());
        templateResolver.setPrefix(&amp;quot;/WEB-INF/templates/&amp;quot;);
        templateResolver.setSuffix(&amp;quot;.html&amp;quot;);
        templateResolver.setCharacterEncoding(&amp;quot;UTF-8&amp;quot;);
        templateResolver.setTemplateMode(TemplateMode.HTML);
        return templateResolver;
    }

    //生成模板引擎并为模板引擎注入模板解析器
    @Bean
    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.setTemplateResolver(templateResolver);
        return templateEngine;
    }

    //生成视图解析器并未解析器注入模板引擎
    @Bean
    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {
        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
        viewResolver.setCharacterEncoding(&amp;quot;UTF-8&amp;quot;);
        viewResolver.setTemplateEngine(templateEngine);
        return viewResolver;
    }


}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-测试功能&#34;&gt;4、测试功能&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/&amp;quot;)
public String index(){
    return &amp;quot;index&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;十三-springmvc执行流程&#34;&gt;十三、SpringMVC执行流程&lt;/h1&gt;
&lt;h2 id=&#34;1-springmvc常用组件&#34;&gt;1、SpringMVC常用组件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DispatcherServlet：&lt;strong&gt;前端控制器&lt;/strong&gt;，不需要工程师开发，由框架提供&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HandlerMapping：&lt;strong&gt;处理器映射器&lt;/strong&gt;，不需要工程师开发，由框架提供&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：根据请求的url、method等信息查找Handler，即控制器方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handler：&lt;strong&gt;处理器&lt;/strong&gt;，需要工程师开发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HandlerAdapter：&lt;strong&gt;处理器适配器&lt;/strong&gt;，不需要工程师开发，由框架提供&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：通过HandlerAdapter对处理器（控制器方法）进行执行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ViewResolver：&lt;strong&gt;视图解析器&lt;/strong&gt;，不需要工程师开发，由框架提供&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View：&lt;strong&gt;视图&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：将模型数据通过页面展示给用户&lt;/p&gt;
&lt;h2 id=&#34;2-dispatcherservlet初始化过程&#34;&gt;2、DispatcherServlet初始化过程&lt;/h2&gt;
&lt;p&gt;DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220718092604.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;a初始化webapplicationcontext&#34;&gt;a&amp;gt;初始化WebApplicationContext&lt;/h3&gt;
&lt;p&gt;所在类：org.springframework.web.servlet.FrameworkServlet&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected WebApplicationContext initWebApplicationContext() {
    WebApplicationContext rootContext =
        WebApplicationContextUtils.getWebApplicationContext(getServletContext());
    WebApplicationContext wac = null;

    if (this.webApplicationContext != null) {
        // A context instance was injected at construction time -&amp;gt; use it
        wac = this.webApplicationContext;
        if (wac instanceof ConfigurableWebApplicationContext) {
            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
            if (!cwac.isActive()) {
                // The context has not yet been refreshed -&amp;gt; provide services such as
                // setting the parent context, setting the application context id, etc
                if (cwac.getParent() == null) {
                    // The context instance was injected without an explicit parent -&amp;gt; set
                    // the root application context (if any; may be null) as the parent
                    cwac.setParent(rootContext);
                }
                configureAndRefreshWebApplicationContext(cwac);
            }
        }
    }
    if (wac == null) {
        // No context instance was injected at construction time -&amp;gt; see if one
        // has been registered in the servlet context. If one exists, it is assumed
        // that the parent context (if any) has already been set and that the
        // user has performed any initialization such as setting the context id
        wac = findWebApplicationContext();
    }
    if (wac == null) {
        // No context instance is defined for this servlet -&amp;gt; create a local one
        // 创建WebApplicationContext
        wac = createWebApplicationContext(rootContext);
    }

    if (!this.refreshEventReceived) {
        // Either the context is not a ConfigurableApplicationContext with refresh
        // support or the context injected at construction time had already been
        // refreshed -&amp;gt; trigger initial onRefresh manually here.
        synchronized (this.onRefreshMonitor) {
            // 刷新WebApplicationContext
            onRefresh(wac);
        }
    }

    if (this.publishContext) {
        // Publish the context as a servlet context attribute.
        // 将IOC容器在应用域共享
        String attrName = getServletContextAttributeName();
        getServletContext().setAttribute(attrName, wac);
    }

    return wac;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;b创建webapplicationcontext&#34;&gt;b&amp;gt;创建WebApplicationContext&lt;/h3&gt;
&lt;p&gt;所在类：org.springframework.web.servlet.FrameworkServlet&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {
    Class&amp;lt;?&amp;gt; contextClass = getContextClass();
    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
        throw new ApplicationContextException(
            &amp;quot;Fatal initialization error in servlet with name &#39;&amp;quot; + getServletName() +
            &amp;quot;&#39;: custom WebApplicationContext class [&amp;quot; + contextClass.getName() +
            &amp;quot;] is not of type ConfigurableWebApplicationContext&amp;quot;);
    }
    // 通过反射创建 IOC 容器对象
    ConfigurableWebApplicationContext wac =
        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);

    wac.setEnvironment(getEnvironment());
    // 设置父容器
    wac.setParent(parent);
    String configLocation = getContextConfigLocation();
    if (configLocation != null) {
        wac.setConfigLocation(configLocation);
    }
    configureAndRefreshWebApplicationContext(wac);

    return wac;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cdispatcherservlet初始化策略&#34;&gt;c&amp;gt;DispatcherServlet初始化策略&lt;/h3&gt;
&lt;p&gt;FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件&lt;/p&gt;
&lt;p&gt;所在类：org.springframework.web.servlet.DispatcherServlet&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void initStrategies(ApplicationContext context) {
   initMultipartResolver(context);
   initLocaleResolver(context);
   initThemeResolver(context);
   initHandlerMappings(context);
   initHandlerAdapters(context);
   initHandlerExceptionResolvers(context);
   initRequestToViewNameTranslator(context);
   initViewResolvers(context);
   initFlashMapManager(context);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-dispatcherservlet调用组件处理请求&#34;&gt;3、DispatcherServlet调用组件处理请求&lt;/h2&gt;
&lt;h3 id=&#34;aprocessrequest&#34;&gt;a&amp;gt;processRequest()&lt;/h3&gt;
&lt;p&gt;FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)&lt;/p&gt;
&lt;p&gt;所在类：org.springframework.web.servlet.FrameworkServlet&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException {

    long startTime = System.currentTimeMillis();
    Throwable failureCause = null;

    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
    LocaleContext localeContext = buildLocaleContext(request);

    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());

    initContextHolders(request, localeContext, requestAttributes);

    try {
		// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写
        doService(request, response);
    }
    catch (ServletException | IOException ex) {
        failureCause = ex;
        throw ex;
    }
    catch (Throwable ex) {
        failureCause = ex;
        throw new NestedServletException(&amp;quot;Request processing failed&amp;quot;, ex);
    }

    finally {
        resetContextHolders(request, previousLocaleContext, previousAttributes);
        if (requestAttributes != null) {
            requestAttributes.requestCompleted();
        }
        logResult(request, response, failureCause, asyncManager);
        publishRequestHandledEvent(request, response, startTime, failureCause);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;bdoservice&#34;&gt;b&amp;gt;doService()&lt;/h3&gt;
&lt;p&gt;所在类：org.springframework.web.servlet.DispatcherServlet&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
    logRequest(request);

    // Keep a snapshot of the request attributes in case of an include,
    // to be able to restore the original attributes after the include.
    Map&amp;lt;String, Object&amp;gt; attributesSnapshot = null;
    if (WebUtils.isIncludeRequest(request)) {
        attributesSnapshot = new HashMap&amp;lt;&amp;gt;();
        Enumeration&amp;lt;?&amp;gt; attrNames = request.getAttributeNames();
        while (attrNames.hasMoreElements()) {
            String attrName = (String) attrNames.nextElement();
            if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {
                attributesSnapshot.put(attrName, request.getAttribute(attrName));
            }
        }
    }

    // Make framework objects available to handlers and view objects.
    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

    if (this.flashMapManager != null) {
        FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
        if (inputFlashMap != null) {
            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
        }
        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);
    }

    RequestPath requestPath = null;
    if (this.parseRequestPath &amp;amp;&amp;amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) {
        requestPath = ServletRequestPathUtils.parseAndCache(request);
    }

    try {
        // 处理请求和响应
        doDispatch(request, response);
    }
    finally {
        if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
            // Restore the original attribute snapshot, in case of an include.
            if (attributesSnapshot != null) {
                restoreAttributesAfterInclude(request, attributesSnapshot);
            }
        }
        if (requestPath != null) {
            ServletRequestPathUtils.clearParsedRequestPath(request);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cdodispatch&#34;&gt;c&amp;gt;doDispatch()&lt;/h3&gt;
&lt;p&gt;所在类：org.springframework.web.servlet.DispatcherServlet&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // Determine handler for the current request.
            /*
            	mappedHandler：调用链
                包含handler、interceptorList、interceptorIndex
            	handler：浏览器发送的请求所匹配的控制器方法
            	interceptorList：处理控制器方法的所有拦截器集合
            	interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行
            */
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            // Determine handler adapter for the current request.
           	// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            String method = request.getMethod();
            boolean isGet = &amp;quot;GET&amp;quot;.equals(method);
            if (isGet || &amp;quot;HEAD&amp;quot;.equals(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp; isGet) {
                    return;
                }
            }
			
            // 调用拦截器的preHandle()
            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }

            // Actually invoke the handler.
            // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) {
                return;
            }

            applyDefaultViewName(processedRequest, mv);
            // 调用拦截器的postHandle()
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            // As of 4.3, we&#39;re processing Errors thrown from handler methods as well,
            // making them available for @ExceptionHandler methods and other scenarios.
            dispatchException = new NestedServletException(&amp;quot;Handler dispatch failed&amp;quot;, err);
        }
        // 后续处理：处理模型数据和渲染视图
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    catch (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    catch (Throwable err) {
        triggerAfterCompletion(processedRequest, response, mappedHandler,
                               new NestedServletException(&amp;quot;Handler processing failed&amp;quot;, err));
    }
    finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            // Instead of postHandle and afterCompletion
            if (mappedHandler != null) {
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        }
        else {
            // Clean up any resources used by a multipart request.
            if (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dprocessdispatchresult&#34;&gt;d&amp;gt;processDispatchResult()&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
                                   @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
                                   @Nullable Exception exception) throws Exception {

    boolean errorView = false;

    if (exception != null) {
        if (exception instanceof ModelAndViewDefiningException) {
            logger.debug(&amp;quot;ModelAndViewDefiningException encountered&amp;quot;, exception);
            mv = ((ModelAndViewDefiningException) exception).getModelAndView();
        }
        else {
            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
            mv = processHandlerException(request, response, handler, exception);
            errorView = (mv != null);
        }
    }

    // Did the handler return a view to render?
    if (mv != null &amp;amp;&amp;amp; !mv.wasCleared()) {
        // 处理模型数据和渲染视图
        render(mv, request, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
    else {
        if (logger.isTraceEnabled()) {
            logger.trace(&amp;quot;No view rendering, null ModelAndView returned.&amp;quot;);
        }
    }

    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
        // Concurrent handling started during a forward
        return;
    }

    if (mappedHandler != null) {
        // Exception (if any) is already handled..
        // 调用拦截器的afterCompletion()
        mappedHandler.triggerAfterCompletion(request, response, null);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-springmvc的执行流程&#34;&gt;4、SpringMVC的执行流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a) 不存在&lt;/p&gt;
&lt;p&gt;i. 再判断是否配置了mvc:default-servlet-handler&lt;/p&gt;
&lt;p&gt;ii. 如果&lt;code&gt;没配置&lt;/code&gt;，则控制台报映射查找不到，客户端展示404错误&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220718093730.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220718093758.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;iii. 如果&lt;code&gt;有配置&lt;/code&gt;，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220718093843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220718093904.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;b) 存在则执行下面的流程&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括HandlerMethod以及Handler对象对应的拦截器和拦截器的索引值），最后以HandlerExecutionChain执行链对象的形式返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息&lt;/p&gt;
&lt;p&gt;b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等&lt;/p&gt;
&lt;p&gt;c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等&lt;/p&gt;
&lt;p&gt;d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;p&gt;Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时将开始执行拦截器的postHandle(...)方法【逆向】。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据返回的ModelAndView选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将渲染结果返回给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">SpringMVC笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/mybatis-bi-ji/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;视频课程链接：&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1VP4y1c7j7&#34;&gt;🔗bilibili（分集观看更方便）&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=PG1lABauiSc&amp;amp;list=PLmOn9nNkQxJEWFBs6hVmDC5m8SbbIiDwY&#34;&gt;🔗YouTube（下载资料更方便）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;一-mybatis简介&#34;&gt;一、Mybatis简介&lt;/h1&gt;
&lt;h2 id=&#34;1-mybatis历史&#34;&gt;1、MyBatis历史&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github&lt;/li&gt;
&lt;li&gt;iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-mybatis特性&#34;&gt;2、MyBatis特性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架&lt;/li&gt;
&lt;li&gt;MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集&lt;/li&gt;
&lt;li&gt;MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录&lt;/li&gt;
&lt;li&gt;MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-mybatis下载&#34;&gt;3、MyBatis下载&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mybatis/mybatis-3&#34;&gt;MyBatis下载地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713164610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-和其它持久化层技术对比&#34;&gt;4、和其它持久化层技术对比&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JDBC
&lt;ul&gt;
&lt;li&gt;SQL 夹杂在Java代码中耦合度高，导致硬编码内伤&lt;/li&gt;
&lt;li&gt;维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见&lt;/li&gt;
&lt;li&gt;代码冗长，开发效率低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hibernate 和 JPA
&lt;ul&gt;
&lt;li&gt;操作简便，开发效率高&lt;/li&gt;
&lt;li&gt;程序中的长难复杂 SQL 需要绕过框架&lt;/li&gt;
&lt;li&gt;内部自动生产的 SQL，不容易做特殊优化&lt;/li&gt;
&lt;li&gt;基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。&lt;/li&gt;
&lt;li&gt;反射操作太多，导致数据库性能下降&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MyBatis
&lt;ul&gt;
&lt;li&gt;轻量级，性能出色&lt;/li&gt;
&lt;li&gt;SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据&lt;/li&gt;
&lt;li&gt;开发效率稍逊于HIbernate，但是完全能够接受&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-mybatis中使用的设计模式&#34;&gt;5、Mybatis中使用的设计模式&lt;/h2&gt;
&lt;p&gt;构建SqlSessionFactory时使用了&lt;code&gt;构建者设计模式&lt;/code&gt;&lt;br&gt;
open，SqlSession时使用了&lt;code&gt;工厂模式&lt;/code&gt;&lt;br&gt;
获取Mapper接口代理对象时使用了&lt;code&gt;代理模式&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220712203944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中关于&lt;code&gt;构建者设计模式&lt;/code&gt;和&lt;code&gt;工厂模式&lt;/code&gt;的区别：建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使&lt;code&gt;同样的构建过程可以创建不同的表示&lt;/code&gt;。所以主要区别就是构建者模式注重零部件的&lt;code&gt;组装&lt;/code&gt;过程，而工厂模式更注重零部件的&lt;code&gt;创建&lt;/code&gt;过程，但两者可以结合使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;二-搭建mybatis&#34;&gt;二、搭建MyBatis&lt;/h1&gt;
&lt;h2 id=&#34;1-开发环境&#34;&gt;1、开发环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IDE：idea 2019.2&lt;/li&gt;
&lt;li&gt;构建工具：maven 3.5.4&lt;/li&gt;
&lt;li&gt;MySQL版本：MySQL 5.7&lt;/li&gt;
&lt;li&gt;MyBatis版本：MyBatis 3.5.7&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-创建maven工程&#34;&gt;2、创建maven工程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;打包方式：jar&lt;/li&gt;
&lt;li&gt;引入依赖&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
	&amp;lt;!-- MyBatis核心 --&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;3.5.7&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;!-- juit测试 --&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
		&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;!-- MySQL驱动 --&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;5.1.3&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-创建mybatis的核心配置文件&#34;&gt;3、创建MyBatis的核心配置文件&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;习惯上命名为&lt;code&gt;mybatis-config.xml&lt;/code&gt;，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。&lt;br&gt;
核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息&lt;br&gt;
核心配置文件存放的位置是src/main/resources目录下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;

&amp;lt;configuration&amp;gt;
    &amp;lt;!-- 引入properties文件 --&amp;gt;
    &amp;lt;properties resource=&amp;quot;jdbc.properties&amp;quot;&amp;gt;&amp;lt;/properties&amp;gt;
    &amp;lt;settings&amp;gt;
        &amp;lt;!--将表中字段的下划线自动转换为驼峰--&amp;gt;
        &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;!--开启延迟加载--&amp;gt;
        &amp;lt;setting name=&amp;quot;lazyLoadingEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;
    &amp;lt;!--设置类型别名--&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;!-- &amp;lt;package name=&amp;quot;mybatisdemo2.pojo&amp;quot;/&amp;gt; --&amp;gt;
        &amp;lt;package name=&amp;quot;实体类包的引用名&amp;quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;

    &amp;lt;!--配置连接数据库的环境--&amp;gt;
    &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;!--设置执行SQL时事务管理器类型：JDBC ——&amp;gt; 事务的提交或回滚需要手动处理--&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;&amp;gt;&amp;lt;/transactionManager&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

    &amp;lt;!--引入映射文件--&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&amp;quot;mybatisdemo/mappers/UserMapper.xml&amp;quot;/&amp;gt;
        &amp;lt;!--        &amp;lt;mapper resource=&amp;quot;mybatisdemo/mappers/UserMapper.xml&amp;quot;/&amp;gt;--&amp;gt;
        &amp;lt;!--
        以包为单位，将包下所有的映射文件引入核心配置文件
        注意：
			1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下
			2. mapper接口要和mapper映射文件的名字一致
			&amp;lt;package name=&amp;quot;com.example.mybatis.mapper&amp;quot;/&amp;gt;
        --&amp;gt;
        &amp;lt;!--        &amp;lt;package name=&amp;quot;&amp;quot;/&amp;gt;--&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建jdbc.properties&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/mydb?characterEncoding=utf8&amp;amp;useUnicode=true
jdbc.username=root
jdbc.password=
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-mybatis对单表的增删改查&#34;&gt;4、MyBatis对单表的增删改查&lt;/h2&gt;
&lt;h3 id=&#34;创建实体类&#34;&gt;创建实体类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package mybatisdemo.entity;

public class User {
    private int id;
    private String name;
    private String pwd;

    public User() {
    }

    public User(String name, String pwd) {
        this.name = name;
        this.pwd = pwd;
    }

    public User(int id, String name, String pwd) {
        this.id = id;
        this.name = name;
        this.pwd = pwd;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPwd() {
        return pwd;
    }

    public void setPwd(String pwd) {
        this.pwd = pwd;
    }

    @Override
    public String toString() {
        return &amp;quot;User{&amp;quot; +
                &amp;quot;id=&amp;quot; + id +
                &amp;quot;, name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &amp;quot;, pwd=&#39;&amp;quot; + pwd + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建mapper接口&#34;&gt;创建mapper接口&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package mybatisdemo.mapper;

public interface UserMapper {

    /**
     * MyBatis面向接口编程的两个一致：
     * 映射文件的namespace要和mapper接口的全类名保持一致
     * 映射文件中SQL语句的id要和mapper接口中的方法名一致
     */

    /**
     * 查询所有的用户
     *
     * @return List&amp;lt;User&amp;gt;
     */
    List&amp;lt;User&amp;gt; getAllUsers();

    /**
     * 添加用户
     *
     * @param user
     */
    int addUser(User user);

    /**
     * 通过id删除指定的用户
     */
    void deleteUserById(int id);

    /**
     * 通过id修改用户
     *
     * @param user
     */
    boolean updateUserById(User user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;：对于增删改的操作，方法可以有返回值，也可以没有返回值。有返回值其值即受影响的行数。&lt;/p&gt;
&lt;h3 id=&#34;创建mybatis的映射文件&#34;&gt;创建MyBatis的映射文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;相关概念：ORM（Object Relationship Mapping）对象关系映射。
&lt;ul&gt;
&lt;li&gt;对象：Java的实体类对象&lt;/li&gt;
&lt;li&gt;关系：关系型数据库&lt;/li&gt;
&lt;li&gt;映射：二者之间的对应关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Java概念&lt;/th&gt;
&lt;th&gt;数据库概念&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;类&lt;/td&gt;
&lt;td&gt;表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;字段/列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;对象&lt;/td&gt;
&lt;td&gt;记录/行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;映射文件的命名规则
&lt;ul&gt;
&lt;li&gt;表所对应的实体类的类名+Mapper.xml&lt;/li&gt;
&lt;li&gt;例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml&lt;/li&gt;
&lt;li&gt;因此一个映射文件对应一个实体类，对应一张表的操作&lt;/li&gt;
&lt;li&gt;MyBatis映射文件用于编写SQL，访问以及操作表中的数据&lt;/li&gt;
&lt;li&gt;MyBatis映射文件存放的位置是src/main/resources/mappers目录下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MyBatis中可以面向接口操作数据，要保证两个一致
&lt;ul&gt;
&lt;li&gt;mapper接口的全类名和映射文件的命名空间（namespace）保持一致&lt;/li&gt;
&lt;li&gt;mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;

&amp;lt;mapper namespace=&amp;quot;mybatisdemo.dao.UserDao&amp;quot;&amp;gt;
&amp;lt;!--    List&amp;lt;User&amp;gt; getAllUsers()--&amp;gt;
&amp;lt;!--    设置类型别名后即可使用类型别名，别名不区分大小写--&amp;gt;
    &amp;lt;select id=&amp;quot;getAllUsers&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
        SELECT * FROM `user`;
    &amp;lt;/select&amp;gt;

&amp;lt;!--    int addUser(User user)--&amp;gt;
&amp;lt;!--    parameterType 可以省略--&amp;gt;
    &amp;lt;insert id=&amp;quot;addUser&amp;quot; parameterType=&amp;quot;mybatisdemo.entity.User&amp;quot;&amp;gt;
        INSERT INTO `user`(name,pwd)
        VALUES(#{name},#{pwd});
    &amp;lt;/insert&amp;gt;

&amp;lt;!--    void deleteUserById(int id)--&amp;gt;
    &amp;lt;delete id=&amp;quot;deleteUserById&amp;quot;&amp;gt;
        DELETE FROM `user`
        WHERE id = #{id};
    &amp;lt;/delete&amp;gt;

&amp;lt;!--    void updateUserById(User user)--&amp;gt;
    &amp;lt;update id=&amp;quot;updateUserById&amp;quot;&amp;gt;
        UPDATE `user`
        SET `name` = #{name},
            pwd = #{pwd}
        WHERE id =  #{id};
    &amp;lt;/update&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;：设置类型别名后即可使用类型别名，别名不区分大小写&lt;br&gt;
&lt;code&gt;注意&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  
	- resultType：自动映射，用于属性名和表中字段名一致的情况  
	- resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况  
2. 当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值
3. 所有SQL标签的parameterType属性可以省略
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建junit测试类&#34;&gt;创建JUnit测试类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）&lt;/li&gt;
&lt;li&gt;SqlSessionFactory：是“生产”SqlSession的“工厂”&lt;/li&gt;
&lt;li&gt;工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserMapperTest {
    @Test
    public void testInsertUser() throws IOException {
        //读取MyBatis的核心配置文件
        InputStream resourceAsStream = Resources.getResourceAsStream(&amp;quot;mybatis-config.xml&amp;quot;);
        //获取SqlSessionFactoryBuilder对象
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
        //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象
        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(resourceAsStream);
        //获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务
        //SqlSession sqlSession = sqlSessionFactory.openSession();
	    //获取SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  
		SqlSession sqlSession = sqlSessionFactory.openSession(true);
        //通过代理模式创建UserMapper接口的代理实现类对象
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句
        //添加一条数据
        int i = userDao.addUser(new User(&amp;quot;张三&amp;quot;, &amp;quot;123&amp;quot;));
        System.out.println(i);
        //查询所有用户
        List&amp;lt;User&amp;gt; userList = userDao.getAllUsers();
        userList.forEach(System.out::println);
        //提交事务
        //sqlSession.commit();
        //关闭资源
        sqlSession.close();
        try {
                resourceAsStream.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;：此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用SqlSession sqlSession = sqlSessionFactory.openSession(&lt;code&gt;true&lt;/code&gt;);，传入一个Boolean类型的参数，值为true，这样就可以自动提交&lt;/p&gt;
&lt;h3 id=&#34;加入log4j日志功能&#34;&gt;加入Log4j日志功能&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;加入依赖&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- log4j日志 --&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;加入log4j的配置文件
&lt;ul&gt;
&lt;li&gt;log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下&lt;/li&gt;
&lt;li&gt;日志的级别：FATAL(致命)&amp;gt;ERROR(错误)&amp;gt;WARN(警告)&amp;gt;INFO(信息)&amp;gt;DEBUG(调试) 从左到右打印的内容越来越详细&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE log4j:configuration SYSTEM &amp;quot;log4j.dtd&amp;quot;&amp;gt;
&amp;lt;log4j:configuration xmlns:log4j=&amp;quot;http://jakarta.apache.org/log4j/&amp;quot;&amp;gt;
    &amp;lt;appender name=&amp;quot;STDOUT&amp;quot; class=&amp;quot;org.apache.log4j.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;param name=&amp;quot;Encoding&amp;quot; value=&amp;quot;UTF-8&amp;quot; /&amp;gt;
        &amp;lt;layout class=&amp;quot;org.apache.log4j.PatternLayout&amp;quot;&amp;gt;
			&amp;lt;param name=&amp;quot;ConversionPattern&amp;quot; value=&amp;quot;%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \n&amp;quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;logger name=&amp;quot;java.sql&amp;quot;&amp;gt;
        &amp;lt;level value=&amp;quot;debug&amp;quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;logger name=&amp;quot;org.apache.ibatis&amp;quot;&amp;gt;
        &amp;lt;level value=&amp;quot;info&amp;quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;root&amp;gt;
        &amp;lt;level value=&amp;quot;debug&amp;quot; /&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/log4j:configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;封装sqlsessionutils工具类&#34;&gt;封装SqlSessionUtils工具类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package mybatisdemo.utils;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

public class SqlSessionUtils {
    public static SqlSession getSqlSession() {
        SqlSession sqlSession = null;
        InputStream resourceAsStream = null;
        try {
            resourceAsStream = Resources.getResourceAsStream(&amp;quot;mybatis-config.xml&amp;quot;);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
            sqlSession = sqlSessionFactory.openSession(true);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                if (null != resourceAsStream)
                    resourceAsStream.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return sqlSession;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;在idea中设置核心配置文件和映射文件的模版&#34;&gt;在IDEA中设置核心配置文件和映射文件的模版&lt;/h3&gt;
&lt;p&gt;mybatis-config.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;properties resource=&amp;quot;jdbc.properties&amp;quot;&amp;gt;&amp;lt;/properties&amp;gt;
    
    &amp;lt;settings&amp;gt;
        &amp;lt;!--将表中字段的下划线自动转换为驼峰--&amp;gt;
        &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;

    &amp;lt;!--设置类型别名--&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;package name=&amp;quot;${typeAliases_PACKAGE_NAME}&amp;quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;

    &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;&amp;gt;&amp;lt;/transactionManager&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

    &amp;lt;!--引入映射文件--&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;!--        &amp;lt;mapper resource=&amp;quot;mybatisdemo/mappers/UserMapper.xml&amp;quot;/&amp;gt;--&amp;gt;
        &amp;lt;!--
        以包为单位，将包下所有的映射文件引入核心配置文件
        注意：
			1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下
			2. mapper接口要和mapper映射文件的名字一致
			&amp;lt;package name=&amp;quot;com.example.mybatis.mapper&amp;quot;/&amp;gt;
        --&amp;gt;
        &amp;lt;!--        &amp;lt;package name=&amp;quot;&amp;quot;/&amp;gt;--&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jdbc.properties&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;jdbc.driver=com.mysql.jdbc.Driver
dbc.url=jdbc:mysql://127.0.0.1:3305/mydb?characterEncoding=utf8&amp;amp;useUnicode=true
jdbc.username=root
jdbc.password=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mybatis-mapper.xml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;

&amp;lt;mapper namespace=&amp;quot;${NAMESPACE}&amp;quot;&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-核心配置文件详解&#34;&gt;三、核心配置文件详解&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：&lt;br&gt;
properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//MyBatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--&amp;gt;
    &amp;lt;properties resource=&amp;quot;jdbc.properties&amp;quot;&amp;gt;&amp;lt;/properties&amp;gt;
    &amp;lt;settings&amp;gt;
        &amp;lt;!--将表中字段的下划线自动转换为驼峰--&amp;gt;
        &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;!--开启延迟加载--&amp;gt;
        &amp;lt;setting name=&amp;quot;lazyLoadingEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;!--
        typeAlias：设置某个具体的类型的别名
        属性：
        type：需要设置别名的类型的全类名
        alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名
        --&amp;gt;
        &amp;lt;!--&amp;lt;typeAlias type=&amp;quot;com.atguigu.mybatis.bean.User&amp;quot;&amp;gt;&amp;lt;/typeAlias&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;typeAlias type=&amp;quot;com.atguigu.mybatis.bean.User&amp;quot; alias=&amp;quot;user&amp;quot;&amp;gt;
        &amp;lt;/typeAlias&amp;gt;--&amp;gt;
        &amp;lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&amp;gt;
        &amp;lt;package name=&amp;quot;com.atguigu.mybatis.bean&amp;quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;
    &amp;lt;!--
    environments：设置多个连接数据库的环境
    属性：
	    default：设置默认使用的环境的id
    --&amp;gt;
    &amp;lt;environments default=&amp;quot;mysql_test&amp;quot;&amp;gt;
        &amp;lt;!--
        environment：设置具体的连接数据库的环境信息
        属性：
	        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境
        --&amp;gt;
        &amp;lt;environment id=&amp;quot;mysql_test&amp;quot;&amp;gt;
            &amp;lt;!--
            transactionManager：设置事务管理方式
            属性：
	            type：设置事务管理方式，type=&amp;quot;JDBC|MANAGED&amp;quot;
	            type=&amp;quot;JDBC&amp;quot;：设置当前环境的事务管理都必须手动处理
	            type=&amp;quot;MANAGED&amp;quot;：设置事务被管理，例如spring中的AOP
            --&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;
            &amp;lt;!--
            dataSource：设置数据源
            属性：
	            type：设置数据源的类型，type=&amp;quot;POOLED|UNPOOLED|JNDI&amp;quot;
	            type=&amp;quot;POOLED&amp;quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建
	            type=&amp;quot;UNPOOLED&amp;quot;：不使用数据库连接池，即每次使用连接都需要重新创建
	            type=&amp;quot;JNDI&amp;quot;：调用上下文中的数据源
            --&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;!--设置驱动类的全类名--&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;/&amp;gt;
                &amp;lt;!--设置连接数据库的连接地址--&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;/&amp;gt;
                &amp;lt;!--设置连接数据库的用户名--&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;/&amp;gt;
                &amp;lt;!--设置连接数据库的密码--&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;!--引入映射文件--&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;!-- &amp;lt;mapper resource=&amp;quot;UserMapper.xml&amp;quot;/&amp;gt; --&amp;gt;
        &amp;lt;!--
        以包为单位，将包下所有的映射文件引入核心配置文件
        注意：
			1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下
			2. mapper接口要和mapper映射文件的名字一致
        --&amp;gt;
        &amp;lt;package name=&amp;quot;com.atguigu.mybatis.mapper&amp;quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220620022217.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;默认的类型别名&#34;&gt;默认的类型别名&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220620022314.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220620022341.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;四-mybatis获取参数值的两种方式重点&#34;&gt;四、MyBatis获取参数值的两种方式（重点）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;MyBatis获取参数值的两种方式：${}和#{}&lt;/li&gt;
&lt;li&gt;${}的本质就是字符串拼接，#{}的本质就是占位符赋值&lt;/li&gt;
&lt;li&gt;${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号&lt;/li&gt;
&lt;li&gt;⚠️为了避免SQL注入，仍然建议使用#{}&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-单个形参非实体类&#34;&gt;1、单个形参（非实体类）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--User getUserByUsername(String username);--&amp;gt;
&amp;lt;select id=&amp;quot;getUserByUsername&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
	select * from t_user where username = #{username}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--User getUserByUsername(String username);--&amp;gt;
&amp;lt;select id=&amp;quot;getUserByUsername&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;  
	select * from t_user where username = &#39;${username}&#39;  
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-多个形参非实体类&#34;&gt;2、多个形参（非实体类）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以arg0,arg1...为键，以参数为值；&lt;/li&gt;
&lt;li&gt;以param1,param2...为键，以参数为值；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--User checkLogin(String username,String password);--&amp;gt;
&amp;lt;select id=&amp;quot;checkLogin&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;  
	select * from t_user where username = #{arg0} and password = #{arg1}  
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--User checkLogin(String username,String password);--&amp;gt;
&amp;lt;select id=&amp;quot;checkLogin&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
	select * from t_user where username = &#39;${param1}&#39; and password = &#39;${param2}&#39;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-map集合类型的参数&#34;&gt;3、map集合类型的参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--User checkLoginByMap(Map&amp;lt;String,Object&amp;gt; map);--&amp;gt;
&amp;lt;select id=&amp;quot;checkLoginByMap&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
	select * from t_user where username = #{username} and password = #{password}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void checkLoginByMap() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);
	Map&amp;lt;String,Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
	map.put(&amp;quot;usermane&amp;quot;,&amp;quot;admin&amp;quot;);
	map.put(&amp;quot;password&amp;quot;,&amp;quot;123456&amp;quot;);
	User user = mapper.checkLoginByMap(map);
	System.out.println(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-实体类类型的参数&#34;&gt;4、实体类类型的参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--int insertUser(User user);--&amp;gt;
&amp;lt;insert id=&amp;quot;insertUser&amp;quot;&amp;gt;
	insert into t_user values(null,#{username},#{password},#{age},#{sex},#{email})
&amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void insertUser() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);
	User user = new User(null,&amp;quot;Tom&amp;quot;,&amp;quot;123456&amp;quot;,12,&amp;quot;男&amp;quot;,&amp;quot;123@321.com&amp;quot;);
	mapper.insertUser(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-使用param标识参数&#34;&gt;5、使用@Param标识参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以@Param注解的value属性值为键，以参数为值；&lt;/li&gt;
&lt;li&gt;以param1,param2...为键，以参数为值；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--User CheckLoginByParam(@Param(&amp;quot;username&amp;quot;) String username, @Param(&amp;quot;password&amp;quot;) String password);--&amp;gt;
    &amp;lt;select id=&amp;quot;CheckLoginByParam&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
        select * from t_user where username = #{username} and password = #{password}
    &amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void checkLoginByParam() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);
	mapper.CheckLoginByParam(&amp;quot;admin&amp;quot;,&amp;quot;123456&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-总结&#34;&gt;6、总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;建议分成两种情况进行处理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实体类类型的参数&lt;/li&gt;
&lt;li&gt;使用@Param标识参数&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;五-mybatis的各种查询功能&#34;&gt;五、MyBatis的各种查询功能&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;如果查询出的数据只有一条，可以通过
&lt;ol&gt;
&lt;li&gt;实体类对象接收&lt;/li&gt;
&lt;li&gt;List集合接收&lt;/li&gt;
&lt;li&gt;Map集合接收，结果&lt;code&gt;{password=123456, sex=男, id=1, age=23, username=admin}&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过
&lt;ol&gt;
&lt;li&gt;实体类类型的LIst集合接收&lt;/li&gt;
&lt;li&gt;Map类型的LIst集合接收&lt;/li&gt;
&lt;li&gt;在mapper接口的方法上添加@MapKey注解&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-查询一个实体类对象&#34;&gt;1、查询一个实体类对象&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 根据用户id查询用户信息
 * @param id
 * @return
 */
User getUserById(@Param(&amp;quot;id&amp;quot;) int id);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--User getUserById(@Param(&amp;quot;id&amp;quot;) int id);--&amp;gt;
&amp;lt;select id=&amp;quot;getUserById&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
	select * from t_user where id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-查询一个list集合&#34;&gt;2、查询一个List集合&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 查询所有用户信息
 * @return
 */
List&amp;lt;User&amp;gt; getUserList();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--List&amp;lt;User&amp;gt; getUserList();--&amp;gt;
&amp;lt;select id=&amp;quot;getUserList&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
	select * from t_user
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-查询单个数据&#34;&gt;3、查询单个数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**  
 * 查询用户的总记录数  
 * @return  
 * 在MyBatis中，对于Java中常用的类型都设置了类型别名  
 * 例如：java.lang.Integer--&amp;gt;int|integer  
 * 例如：int--&amp;gt;_int|_integer  
 * 例如：Map--&amp;gt;map,List--&amp;gt;list  
 */  
int getCount();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--int getCount();--&amp;gt;
&amp;lt;select id=&amp;quot;getCount&amp;quot; resultType=&amp;quot;_integer&amp;quot;&amp;gt;
	select count(id) from t_user
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-查询一条数据为map集合&#34;&gt;4、查询一条数据为map集合&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**  
 * 根据用户id查询用户信息为map集合  
 * @param id  
 * @return  
 */  
Map&amp;lt;String, Object&amp;gt; getUserToMap(@Param(&amp;quot;id&amp;quot;) int id);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--Map&amp;lt;String, Object&amp;gt; getUserToMap(@Param(&amp;quot;id&amp;quot;) int id);--&amp;gt;
&amp;lt;select id=&amp;quot;getUserToMap&amp;quot; resultType=&amp;quot;map&amp;quot;&amp;gt;
	select * from t_user where id = #{id}
&amp;lt;/select&amp;gt;
&amp;lt;!--结果：{password=123456, sex=男, id=1, age=23, username=admin}--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-查询多条数据为map集合&#34;&gt;5、查询多条数据为map集合&lt;/h2&gt;
&lt;h3 id=&#34;方法一&#34;&gt;方法一&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**  
 * 查询所有用户信息为map集合  
 * @return  
 * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  
 */  
List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; getAllUserToMap();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--Map&amp;lt;String, Object&amp;gt; getAllUserToMap();--&amp;gt;  
&amp;lt;select id=&amp;quot;getAllUserToMap&amp;quot; resultType=&amp;quot;map&amp;quot;&amp;gt;  
	select * from t_user  
&amp;lt;/select&amp;gt;
&amp;lt;!--
	结果：
	[{password=123456, sex=男, id=1, age=23, username=admin},
	{password=123456, sex=男, id=2, age=23, username=张三},
	{password=123456, sex=男, id=3, age=23, username=张三}]
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方法二&#34;&gt;方法二&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 查询所有用户信息为map集合
 * @return
 * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合
 */
@MapKey(&amp;quot;id&amp;quot;)
Map&amp;lt;String, Object&amp;gt; getAllUserToMap();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--Map&amp;lt;String, Object&amp;gt; getAllUserToMap();--&amp;gt;
&amp;lt;select id=&amp;quot;getAllUserToMap&amp;quot; resultType=&amp;quot;map&amp;quot;&amp;gt;
	select * from t_user
&amp;lt;/select&amp;gt;
&amp;lt;!--
	结果：
	{
	1={password=123456, sex=男, id=1, age=23, username=admin},
	2={password=123456, sex=男, id=2, age=23, username=张三},
	3={password=123456, sex=男, id=3, age=23, username=张三}
	}
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六-特殊sql的执行&#34;&gt;六、特殊SQL的执行&lt;/h1&gt;
&lt;h2 id=&#34;1-模糊查询&#34;&gt;1、模糊查询&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 根据用户名进行模糊查询
 * @param username 
 * @return java.util.List&amp;lt;com.atguigu.mybatis.pojo.User&amp;gt;
 * @date 2022/2/26 21:56
 */
List&amp;lt;User&amp;gt; getUserByLike(@Param(&amp;quot;username&amp;quot;) String username);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--List&amp;lt;User&amp;gt; getUserByLike(@Param(&amp;quot;username&amp;quot;) String username);--&amp;gt;
&amp;lt;select id=&amp;quot;getUserByLike&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
	&amp;lt;!--select * from t_user where username like &#39;%${mohu}%&#39;--&amp;gt;  
	&amp;lt;!--select * from t_user where username like concat(&#39;%&#39;,#{mohu},&#39;%&#39;)--&amp;gt;  
	select * from t_user where username like &amp;quot;%&amp;quot;#{mohu}&amp;quot;%&amp;quot;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;其中&lt;code&gt;select * from t_user where username like &amp;quot;%&amp;quot;#{mohu}&amp;quot;%&amp;quot;&lt;/code&gt;是最常用的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-批量删除&#34;&gt;2、批量删除&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;只能使用${}，如果使用#{}，则解析后的sql语句为&lt;code&gt;delete from t_user where id in (&#39;1,2,3&#39;)&lt;/code&gt;，这样是将&lt;code&gt;1,2,3&lt;/code&gt;看做是一个整体，只有id为&lt;code&gt;1,2,3&lt;/code&gt;的数据会被删除。正确的语句应该是&lt;code&gt;delete from t_user where id in (1,2,3)&lt;/code&gt;，或者&lt;code&gt;delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 根据id批量删除
 * @param ids 
 * @return int
 * @date 2022/2/26 22:06
 */
int deleteMore(@Param(&amp;quot;ids&amp;quot;) String ids);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;delete id=&amp;quot;deleteMore&amp;quot;&amp;gt;
	delete from t_user where id in (${ids})
&amp;lt;/delete&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//测试类
@Test
public void deleteMore() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);
	int result = mapper.deleteMore(&amp;quot;1,2,3,8&amp;quot;);
	System.out.println(result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-动态设置表名&#34;&gt;3、动态设置表名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;只能使用${}，因为表名不能加单引号&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 查询指定表中的数据
 * @param tableName 
 * @return java.util.List&amp;lt;com.atguigu.mybatis.pojo.User&amp;gt;
 * @date 2022/2/27 14:41
 */
List&amp;lt;User&amp;gt; getUserByTable(@Param(&amp;quot;tableName&amp;quot;) String tableName);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--List&amp;lt;User&amp;gt; getUserByTable(@Param(&amp;quot;tableName&amp;quot;) String tableName);--&amp;gt;
&amp;lt;select id=&amp;quot;getUserByTable&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;
	select * from ${tableName}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-添加功能获取自增的主键&#34;&gt;4、添加功能获取自增的主键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用场景
&lt;ul&gt;
&lt;li&gt;t_clazz(clazz_id,clazz_name)&lt;/li&gt;
&lt;li&gt;t_student(student_id,student_name,clazz_id)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;添加班级信息&lt;/li&gt;
&lt;li&gt;获取新添加的班级的id&lt;/li&gt;
&lt;li&gt;为班级分配学生，即将某学的班级id修改为新添加的班级的id&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在mapper.xml中设置两个属性
&lt;ul&gt;
&lt;li&gt;useGeneratedKeys：设置使用自增的主键&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 添加用户信息
 * @param user 
 * @date 2022/2/27 15:04
 */
void insertUser(User user);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--void insertUser(User user);--&amp;gt;
&amp;lt;insert id=&amp;quot;insertUser&amp;quot; useGeneratedKeys=&amp;quot;true&amp;quot; keyProperty=&amp;quot;id&amp;quot;&amp;gt;
	insert into t_user values (null,#{username},#{password},#{age},#{sex},#{email})
&amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//测试类
@Test
public void insertUser() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);
	User user = new User(null, &amp;quot;ton&amp;quot;, &amp;quot;123&amp;quot;, 23, &amp;quot;男&amp;quot;, &amp;quot;123@321.com&amp;quot;);
	mapper.insertUser(user);
	System.out.println(user);
	//输出：user{id=10, username=&#39;ton&#39;, password=&#39;123&#39;, age=23, sex=&#39;男&#39;, email=&#39;123@321.com&#39;}，自增主键存放到了user的id属性中
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;七-自定义映射resultmap&#34;&gt;七、自定义映射resultMap&lt;/h1&gt;
&lt;h2 id=&#34;1-resultmap处理字段和属性的映射关系&#34;&gt;1、resultMap处理字段和属性的映射关系&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;resultMap：设置自定义映射
&lt;ul&gt;
&lt;li&gt;属性：
&lt;ul&gt;
&lt;li&gt;id：表示自定义映射的唯一标识，不能重复&lt;/li&gt;
&lt;li&gt;type：查询的数据要映射的实体类的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子标签：
&lt;ul&gt;
&lt;li&gt;id：设置主键的映射关系&lt;/li&gt;
&lt;li&gt;result：设置普通字段的映射关系&lt;/li&gt;
&lt;li&gt;子标签属性：
&lt;ul&gt;
&lt;li&gt;property：设置映射关系中实体类中的属性名&lt;/li&gt;
&lt;li&gt;column：设置映射关系中表中的字段名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;resultMap id=&amp;quot;empResultMap&amp;quot; type=&amp;quot;Emp&amp;quot;&amp;gt;
	&amp;lt;id property=&amp;quot;eid&amp;quot; column=&amp;quot;eid&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
	&amp;lt;result property=&amp;quot;empName&amp;quot; column=&amp;quot;emp_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;age&amp;quot; column=&amp;quot;age&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;sex&amp;quot; column=&amp;quot;sex&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;email&amp;quot; column=&amp;quot;email&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;!--List&amp;lt;Emp&amp;gt; getAllEmp();--&amp;gt;
&amp;lt;select id=&amp;quot;getAllEmp&amp;quot; resultMap=&amp;quot;empResultMap&amp;quot;&amp;gt;
	select * from t_emp
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系
&lt;ol&gt;
&lt;li&gt;可以通过为字段起别名的方式，保证和实体类中的属性名保持一致&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--List&amp;lt;Emp&amp;gt; getAllEmp();--&amp;gt;
&amp;lt;select id=&amp;quot;getAllEmp&amp;quot; resultType=&amp;quot;Emp&amp;quot;&amp;gt;
	select eid,emp_name empName,age,sex,email from t_emp
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;可以在MyBatis的核心配置文件中的&lt;code&gt;setting&lt;/code&gt;标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。&lt;a href=&#34;#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3&#34;&gt;核心配置文件详解&lt;/a&gt;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--
&amp;lt;settings&amp;gt;
    &amp;lt;settingDELETEME name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-多对一映射处理&#34;&gt;2、多对一映射处理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;查询员工信息以及员工所对应的部门信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Emp {  
	private Integer eid;  
	private String empName;  
	private Integer age;  
	private String sex;  
	private String email;  
	private Dept dept;
	//...构造器、get、set方法等
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;级联方式处理映射关系&#34;&gt;级联方式处理映射关系&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;resultMap id=&amp;quot;empAndDeptResultMapOne&amp;quot; type=&amp;quot;Emp&amp;quot;&amp;gt;
	&amp;lt;id property=&amp;quot;eid&amp;quot; column=&amp;quot;eid&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
	&amp;lt;result property=&amp;quot;empName&amp;quot; column=&amp;quot;emp_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;age&amp;quot; column=&amp;quot;age&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;sex&amp;quot; column=&amp;quot;sex&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;email&amp;quot; column=&amp;quot;email&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;dept.did&amp;quot; column=&amp;quot;did&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;dept.deptName&amp;quot; column=&amp;quot;dept_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;!--Emp getEmpAndDept(@Param(&amp;quot;eid&amp;quot;)Integer eid);--&amp;gt;
&amp;lt;select id=&amp;quot;getEmpAndDept&amp;quot; resultMap=&amp;quot;empAndDeptResultMapOne&amp;quot;&amp;gt;
	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用association处理映射关系&#34;&gt;使用association处理映射关系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;association：处理多对一的映射关系&lt;/li&gt;
&lt;li&gt;property：需要处理多对的映射关系的属性名&lt;/li&gt;
&lt;li&gt;javaType：该属性的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;resultMap id=&amp;quot;empAndDeptResultMapTwo&amp;quot; type=&amp;quot;Emp&amp;quot;&amp;gt;
	&amp;lt;id property=&amp;quot;eid&amp;quot; column=&amp;quot;eid&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
	&amp;lt;result property=&amp;quot;empName&amp;quot; column=&amp;quot;emp_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;age&amp;quot; column=&amp;quot;age&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;sex&amp;quot; column=&amp;quot;sex&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;email&amp;quot; column=&amp;quot;email&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;association property=&amp;quot;dept&amp;quot; javaType=&amp;quot;Dept&amp;quot;&amp;gt;
		&amp;lt;id property=&amp;quot;did&amp;quot; column=&amp;quot;did&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
		&amp;lt;result property=&amp;quot;deptName&amp;quot; column=&amp;quot;dept_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;/association&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;!--
    autoMapping : 自动映射
    即，我们可以发现上述设置关系映射关系时 property 和 column 是可以自动映射的。所有以上代码可以简化为：
--&amp;gt;
&amp;lt;resultMap id=&amp;quot;empAndDeptResultMapTwo&amp;quot; type=&amp;quot;Emp&amp;quot; autoMapping=&amp;quot;true&amp;quot;&amp;gt;
	&amp;lt;association property=&amp;quot;dept&amp;quot; javaType=&amp;quot;Dept&amp;quot; autoMapping=&amp;quot;true&amp;quot;&amp;gt;
	&amp;lt;/association&amp;gt;
&amp;lt;/resultMap&amp;gt;

&amp;lt;!--Emp getEmpAndDept(@Param(&amp;quot;eid&amp;quot;)Integer eid);--&amp;gt;
&amp;lt;select id=&amp;quot;getEmpAndDept&amp;quot; resultMap=&amp;quot;empAndDeptResultMapTwo&amp;quot;&amp;gt;
	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分步查询&#34;&gt;分步查询&lt;/h3&gt;
&lt;h4 id=&#34;1-查询员工信息&#34;&gt;1. 查询员工信息&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）&lt;/li&gt;
&lt;li&gt;column：设置分步查询的条件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//EmpMapper里的方法
/**
 * 通过分步查询，员工及所对应的部门信息
 * 分步查询第一步：查询员工信息
 * @param  
 * @return com.atguigu.mybatis.pojo.Emp
 * @date 2022/2/27 20:17
 */
Emp getEmpAndDeptByStepOne(@Param(&amp;quot;eid&amp;quot;) Integer eid);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;resultMap id=&amp;quot;empAndDeptByStepResultMap&amp;quot; type=&amp;quot;Emp&amp;quot;&amp;gt;
	&amp;lt;id property=&amp;quot;eid&amp;quot; column=&amp;quot;eid&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
	&amp;lt;result property=&amp;quot;empName&amp;quot; column=&amp;quot;emp_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;age&amp;quot; column=&amp;quot;age&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;sex&amp;quot; column=&amp;quot;sex&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;email&amp;quot; column=&amp;quot;email&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;association property=&amp;quot;dept&amp;quot;
				 select=&amp;quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&amp;quot;
				 column=&amp;quot;did&amp;quot;&amp;gt;&amp;lt;/association&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;!--Emp getEmpAndDeptByStepOne(@Param(&amp;quot;eid&amp;quot;) Integer eid);--&amp;gt;
&amp;lt;select id=&amp;quot;getEmpAndDeptByStepOne&amp;quot; resultMap=&amp;quot;empAndDeptByStepResultMap&amp;quot;&amp;gt;
	select * from t_emp where eid = #{eid}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-查询部门信息&#34;&gt;2. 查询部门信息&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//DeptMapper里的方法
/**
 * 通过分步查询，员工及所对应的部门信息
 * 分步查询第二步：通过did查询员工对应的部门信息
 * @param
 * @return com.atguigu.mybatis.pojo.Emp
 * @date 2022/2/27 20:23
 */
Dept getEmpAndDeptByStepTwo(@Param(&amp;quot;did&amp;quot;) Integer did);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--此处的resultMap仅是处理字段和属性的映射关系--&amp;gt;
&amp;lt;resultMap id=&amp;quot;EmpAndDeptByStepTwoResultMap&amp;quot; type=&amp;quot;Dept&amp;quot;&amp;gt;
	&amp;lt;id property=&amp;quot;did&amp;quot; column=&amp;quot;did&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
	&amp;lt;result property=&amp;quot;deptName&amp;quot; column=&amp;quot;dept_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;!--Dept getEmpAndDeptByStepTwo(@Param(&amp;quot;did&amp;quot;) Integer did);--&amp;gt;
&amp;lt;select id=&amp;quot;getEmpAndDeptByStepTwo&amp;quot; resultMap=&amp;quot;EmpAndDeptByStepTwoResultMap&amp;quot;&amp;gt;
	select * from t_dept where did = #{did}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-一对多映射处理&#34;&gt;3、一对多映射处理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Dept {
    private Integer did;
    private String deptName;
    private List&amp;lt;Emp&amp;gt; emps;
	//...构造器、get、set方法等
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;collection&#34;&gt;collection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;collection：用来处理一对多的映射关系&lt;/li&gt;
&lt;li&gt;ofType：表示该属性对饮的集合中存储的数据的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;resultMap id=&amp;quot;DeptAndEmpResultMap&amp;quot; type=&amp;quot;Dept&amp;quot;&amp;gt;
	&amp;lt;id property=&amp;quot;did&amp;quot; column=&amp;quot;did&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
	&amp;lt;result property=&amp;quot;deptName&amp;quot; column=&amp;quot;dept_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;collection property=&amp;quot;emps&amp;quot; ofType=&amp;quot;Emp&amp;quot;&amp;gt;
		&amp;lt;id property=&amp;quot;eid&amp;quot; column=&amp;quot;eid&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
		&amp;lt;result property=&amp;quot;empName&amp;quot; column=&amp;quot;emp_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
		&amp;lt;result property=&amp;quot;age&amp;quot; column=&amp;quot;age&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
		&amp;lt;result property=&amp;quot;sex&amp;quot; column=&amp;quot;sex&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
		&amp;lt;result property=&amp;quot;email&amp;quot; column=&amp;quot;email&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;/collection&amp;gt;
&amp;lt;/resultMap&amp;gt;    
&amp;lt;!--
    autoMapping : 自动映射
    即，我们可以发现上述设置关系映射关系时 property 和 column 是可以自动映射的。所有以上代码可以简化为：
--&amp;gt;
&amp;lt;resultMap id=&amp;quot;DeptAndEmpResultMap&amp;quot; type=&amp;quot;Dept&amp;quot; autoMapping=&amp;quot;true&amp;quot;&amp;gt;
	&amp;lt;collection property=&amp;quot;emps&amp;quot; ofType=&amp;quot;Emp&amp;quot; autoMapping=&amp;quot;true&amp;quot;&amp;gt;
	&amp;lt;/collection&amp;gt;
&amp;lt;/resultMap&amp;gt;    

&amp;lt;!--Dept getDeptAndEmp(@Param(&amp;quot;did&amp;quot;) Integer did);--&amp;gt;
&amp;lt;select id=&amp;quot;getDeptAndEmp&amp;quot; resultMap=&amp;quot;DeptAndEmpResultMap&amp;quot;&amp;gt;
	select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分步查询-2&#34;&gt;分步查询&lt;/h3&gt;
&lt;h4 id=&#34;1-查询部门信息&#34;&gt;1. 查询部门信息&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 通过分步查询，查询部门及对应的所有员工信息
 * 分步查询第一步：查询部门信息
 * @param did 
 * @return com.atguigu.mybatis.pojo.Dept
 * @date 2022/2/27 22:04
 */
Dept getDeptAndEmpByStepOne(@Param(&amp;quot;did&amp;quot;) Integer did);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;resultMap id=&amp;quot;DeptAndEmpByStepOneResultMap&amp;quot; type=&amp;quot;Dept&amp;quot;&amp;gt;
	&amp;lt;id property=&amp;quot;did&amp;quot; column=&amp;quot;did&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
	&amp;lt;result property=&amp;quot;deptName&amp;quot; column=&amp;quot;dept_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;collection property=&amp;quot;emps&amp;quot;
				select=&amp;quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&amp;quot;
				column=&amp;quot;did&amp;quot;&amp;gt;&amp;lt;/collection&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;!--Dept getDeptAndEmpByStepOne(@Param(&amp;quot;did&amp;quot;) Integer did);--&amp;gt;
&amp;lt;select id=&amp;quot;getDeptAndEmpByStepOne&amp;quot; resultMap=&amp;quot;DeptAndEmpByStepOneResultMap&amp;quot;&amp;gt;
	select * from t_dept where did = #{did}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-根据部门id查询部门中的所有员工&#34;&gt;2. 根据部门id查询部门中的所有员工&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 通过分步查询，查询部门及对应的所有员工信息
 * 分步查询第二步：根据部门id查询部门中的所有员工
 * @param did
 * @return java.util.List&amp;lt;com.atguigu.mybatis.pojo.Emp&amp;gt;
 * @date 2022/2/27 22:10
 */
List&amp;lt;Emp&amp;gt; getDeptAndEmpByStepTwo(@Param(&amp;quot;did&amp;quot;) Integer did);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--List&amp;lt;Emp&amp;gt; getDeptAndEmpByStepTwo(@Param(&amp;quot;did&amp;quot;) Integer did);--&amp;gt;
&amp;lt;select id=&amp;quot;getDeptAndEmpByStepTwo&amp;quot; resultType=&amp;quot;Emp&amp;quot;&amp;gt;
	select * from t_emp where did = #{did}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-延迟加载&#34;&gt;4、延迟加载&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：
&lt;ul&gt;
&lt;li&gt;lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载&lt;/li&gt;
&lt;li&gt;aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=&amp;quot;lazy(延迟加载)|eager(立即加载)&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;settings&amp;gt;
	&amp;lt;!--开启延迟加载--&amp;gt;
	&amp;lt;setting name=&amp;quot;lazyLoadingEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void getEmpAndDeptByStepOne() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
	Emp emp = mapper.getEmpAndDeptByStepOne(1);
	System.out.println(emp.getEmpName());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;关闭延迟加载，两条SQL语句都运行了&lt;img src=&#34;Resources/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%951.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;开启延迟加载，只运行获取emp的SQL语句&lt;br&gt;
&lt;img src=&#34;Resources/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void getEmpAndDeptByStepOne() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
	Emp emp = mapper.getEmpAndDeptByStepOne(1);
	System.out.println(emp.getEmpName());
	System.out.println(&amp;quot;----------------&amp;quot;);
	System.out.println(emp.getDept());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开启后，需要用到查询dept的时候才会调用相应的SQL语句&lt;img src=&#34;Resources/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%953.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType=&amp;quot;lazy(延迟加载)|eager(立即加载)&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;resultMap id=&amp;quot;empAndDeptByStepResultMap&amp;quot; type=&amp;quot;Emp&amp;quot;&amp;gt;
	&amp;lt;id property=&amp;quot;eid&amp;quot; column=&amp;quot;eid&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
	&amp;lt;result property=&amp;quot;empName&amp;quot; column=&amp;quot;emp_name&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;age&amp;quot; column=&amp;quot;age&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;sex&amp;quot; column=&amp;quot;sex&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;result property=&amp;quot;email&amp;quot; column=&amp;quot;email&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
	&amp;lt;association property=&amp;quot;dept&amp;quot;
				 select=&amp;quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&amp;quot;
				 column=&amp;quot;did&amp;quot;
				 fetchType=&amp;quot;lazy&amp;quot;&amp;gt;&amp;lt;/association&amp;gt;
&amp;lt;/resultMap&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;八-动态sql&#34;&gt;八、动态SQL&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;if&#34;&gt;if&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行&lt;/li&gt;
&lt;li&gt;在where后面添加一个恒成立条件&lt;code&gt;1=1&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;这个恒成立条件并不会影响查询的结果&lt;/li&gt;
&lt;li&gt;这个&lt;code&gt;1=1&lt;/code&gt;可以用来拼接&lt;code&gt;and&lt;/code&gt;语句，例如：当empName为null时
&lt;ul&gt;
&lt;li&gt;如果不加上恒成立条件，则SQL语句为&lt;code&gt;select * from t_emp where and age = ? and sex = ? and email = ?&lt;/code&gt;，此时&lt;code&gt;where&lt;/code&gt;会与&lt;code&gt;and&lt;/code&gt;连用，SQL语句会报错&lt;/li&gt;
&lt;li&gt;如果加上一个恒成立条件，则SQL语句为&lt;code&gt;select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?&lt;/code&gt;，此时不报错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--List&amp;lt;Emp&amp;gt; getEmpByCondition(Emp emp);--&amp;gt;
&amp;lt;select id=&amp;quot;getEmpByCondition&amp;quot; resultType=&amp;quot;Emp&amp;quot;&amp;gt;
	select * from t_emp where 1=1
	&amp;lt;if test=&amp;quot;empName != null and empName !=&#39;&#39;&amp;quot;&amp;gt;
		and emp_name = #{empName}
	&amp;lt;/if&amp;gt;
	&amp;lt;if test=&amp;quot;age != null and age !=&#39;&#39;&amp;quot;&amp;gt;
		and age = #{age}
	&amp;lt;/if&amp;gt;
	&amp;lt;if test=&amp;quot;sex != null and sex !=&#39;&#39;&amp;quot;&amp;gt;
		and sex = #{sex}
	&amp;lt;/if&amp;gt;
	&amp;lt;if test=&amp;quot;email != null and email !=&#39;&#39;&amp;quot;&amp;gt;
		and email = #{email}
	&amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;where&#34;&gt;where&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;where和if一般结合使用：
&lt;ul&gt;
&lt;li&gt;若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字&lt;/li&gt;
&lt;li&gt;若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and/or去掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--List&amp;lt;Emp&amp;gt; getEmpByCondition(Emp emp);--&amp;gt;
&amp;lt;select id=&amp;quot;getEmpByCondition&amp;quot; resultType=&amp;quot;Emp&amp;quot;&amp;gt;
	select * from t_emp
	&amp;lt;where&amp;gt;
		&amp;lt;if test=&amp;quot;empName != null and empName !=&#39;&#39;&amp;quot;&amp;gt;
			emp_name = #{empName}
		&amp;lt;/if&amp;gt;
		&amp;lt;if test=&amp;quot;age != null and age !=&#39;&#39;&amp;quot;&amp;gt;
			and age = #{age}
		&amp;lt;/if&amp;gt;
		&amp;lt;if test=&amp;quot;sex != null and sex !=&#39;&#39;&amp;quot;&amp;gt;
			and sex = #{sex}
		&amp;lt;/if&amp;gt;
		&amp;lt;if test=&amp;quot;email != null and email !=&#39;&#39;&amp;quot;&amp;gt;
			and email = #{email}
		&amp;lt;/if&amp;gt;
	&amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注意：where标签不能去掉条件后多余的and/or&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&amp;gt;
&amp;lt;if test=&amp;quot;empName != null and empName !=&#39;&#39;&amp;quot;&amp;gt;
emp_name = #{empName} and
&amp;lt;/if&amp;gt;
&amp;lt;if test=&amp;quot;age != null and age !=&#39;&#39;&amp;quot;&amp;gt;
	age = #{age}
&amp;lt;/if&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;set&#34;&gt;set&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;set与where类似，一般和if结合使用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;	&amp;lt;update id=&amp;quot;update&amp;quot; parameterType=&amp;quot;User&amp;quot;&amp;gt;
        UPDATE user
        &amp;lt;set&amp;gt;
            &amp;lt;if test=&amp;quot;username != null&amp;quot;&amp;gt;
                username=#{username},
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;birthday != null&amp;quot;&amp;gt;
                birthday=#{birthday},
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sex != null&amp;quot;&amp;gt;
                sex=#{sex},
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;address != null&amp;quot;&amp;gt;
                address=#{address},
            &amp;lt;/if&amp;gt;
        &amp;lt;/set&amp;gt;
        WHERE id=#{id}
    &amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;trim&#34;&gt;trim&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;trim一般也是和if结合使用，用于去掉或添加标签中的内容，&lt;/li&gt;
&lt;li&gt;常用属性
&lt;ul&gt;
&lt;li&gt;prefix：在trim标签中的内容的前面添加某些内容&lt;/li&gt;
&lt;li&gt;suffix：在trim标签中的内容的后面添加某些内容&lt;/li&gt;
&lt;li&gt;prefixOverrides：在trim标签中的内容的前面去掉某些内容&lt;/li&gt;
&lt;li&gt;suffixOverrides：在trim标签中的内容的后面去掉某些内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下&lt;code&gt;select * from t_emp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--List&amp;lt;Emp&amp;gt; getEmpByCondition(Emp emp);--&amp;gt;
&amp;lt;select id=&amp;quot;getEmpByCondition&amp;quot; resultType=&amp;quot;Emp&amp;quot;&amp;gt;
	select * from t_emp
	&amp;lt;trim prefix=&amp;quot;where&amp;quot; suffixOverrides=&amp;quot;and|or&amp;quot;&amp;gt;
		&amp;lt;if test=&amp;quot;empName != null and empName !=&#39;&#39;&amp;quot;&amp;gt;
			emp_name = #{empName} and
		&amp;lt;/if&amp;gt;
		&amp;lt;if test=&amp;quot;age != null and age !=&#39;&#39;&amp;quot;&amp;gt;
			age = #{age} and
		&amp;lt;/if&amp;gt;
		&amp;lt;if test=&amp;quot;sex != null and sex !=&#39;&#39;&amp;quot;&amp;gt;
			sex = #{sex} or
		&amp;lt;/if&amp;gt;
		&amp;lt;if test=&amp;quot;email != null and email !=&#39;&#39;&amp;quot;&amp;gt;
			email = #{email}
		&amp;lt;/if&amp;gt;
	&amp;lt;/trim&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//测试类
@Test
public void getEmpByCondition() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);
	List&amp;lt;Emp&amp;gt; emps= mapper.getEmpByCondition(new Emp(null, &amp;quot;张三&amp;quot;, null, null, null, null));
	System.out.println(emps);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;Resources/trim%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;choose-when-otherwise&#34;&gt;choose、when、otherwise&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;choose、when、otherwise&lt;/code&gt;相当于&lt;code&gt;if...else if..else&lt;/code&gt;&lt;br&gt;
choose是根标签，when至少要有一个，otherwise至多只有一个&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;getEmpByChoose&amp;quot; resultType=&amp;quot;Emp&amp;quot;&amp;gt;
	select * from t_emp
	&amp;lt;where&amp;gt;
		&amp;lt;choose&amp;gt;
			&amp;lt;when test=&amp;quot;empName != null and empName != &#39;&#39;&amp;quot;&amp;gt;
				emp_name = #{empName}
			&amp;lt;/when&amp;gt;
			&amp;lt;when test=&amp;quot;age != null and age != &#39;&#39;&amp;quot;&amp;gt;
				age = #{age}
			&amp;lt;/when&amp;gt;
			&amp;lt;when test=&amp;quot;sex != null and sex != &#39;&#39;&amp;quot;&amp;gt;
				sex = #{sex}
			&amp;lt;/when&amp;gt;
			&amp;lt;when test=&amp;quot;email != null and email != &#39;&#39;&amp;quot;&amp;gt;
				email = #{email}
			&amp;lt;/when&amp;gt;
			&amp;lt;otherwise&amp;gt;
				did = 1
			&amp;lt;/otherwise&amp;gt;
		&amp;lt;/choose&amp;gt;
	&amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void getEmpByChoose() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);
	List&amp;lt;Emp&amp;gt; emps = mapper.getEmpByChoose(new Emp(null, &amp;quot;张三&amp;quot;, 23, &amp;quot;男&amp;quot;, &amp;quot;123@qq.com&amp;quot;, null));
	System.out.println(emps);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;Resources/choose%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;相当于&lt;code&gt;if a else if b else if c else d&lt;/code&gt;，只会执行其中一个&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;foreach&#34;&gt;foreach&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;collection：设置要循环的数组或集合&lt;/li&gt;
&lt;li&gt;item：表示集合或数组中的每一个数据&lt;/li&gt;
&lt;li&gt;separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如&lt;code&gt;,&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;open：设置foreach标签中的内容的开始符&lt;/li&gt;
&lt;li&gt;close：设置foreach标签中的内容的结束符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;批量删除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--int deleteMoreByArray(Integer[] eids);--&amp;gt;
&amp;lt;delete id=&amp;quot;deleteMoreByArray&amp;quot;&amp;gt;
	delete from t_emp where eid in
	&amp;lt;foreach collection=&amp;quot;eids&amp;quot; item=&amp;quot;eid&amp;quot; separator=&amp;quot;,&amp;quot; open=&amp;quot;(&amp;quot; close=&amp;quot;)&amp;quot;&amp;gt;
		#{eid}
	&amp;lt;/foreach&amp;gt;
&amp;lt;/delete&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void deleteMoreByArray() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);
	int result = mapper.deleteMoreByArray(new Integer[]{6, 7, 8, 9});
	System.out.println(result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;Resources/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;批量添加&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--int insertMoreByList(@Param(&amp;quot;emps&amp;quot;) List&amp;lt;Emp&amp;gt; emps);--&amp;gt;
&amp;lt;insert id=&amp;quot;insertMoreByList&amp;quot;&amp;gt;
	insert into t_emp values
	&amp;lt;foreach collection=&amp;quot;emps&amp;quot; item=&amp;quot;emp&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
		(null,#{emp.empName},#{emp.age},#{emp.sex},#{emp.email},null)
	&amp;lt;/foreach&amp;gt;
&amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void insertMoreByList() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);
	Emp emp1 = new Emp(null,&amp;quot;a&amp;quot;,1,&amp;quot;男&amp;quot;,&amp;quot;123@321.com&amp;quot;,null);
	Emp emp2 = new Emp(null,&amp;quot;b&amp;quot;,1,&amp;quot;男&amp;quot;,&amp;quot;123@321.com&amp;quot;,null);
	Emp emp3 = new Emp(null,&amp;quot;c&amp;quot;,1,&amp;quot;男&amp;quot;,&amp;quot;123@321.com&amp;quot;,null);
	List&amp;lt;Emp&amp;gt; emps = Arrays.asList(emp1, emp2, emp3);
	int result = mapper.insertMoreByList(emps);
	System.out.println(result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;Resources/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sql片段&#34;&gt;SQL片段&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入&lt;/li&gt;
&lt;li&gt;声明sql片段：&lt;code&gt;&amp;lt;sql&amp;gt;&lt;/code&gt;标签&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;sql id=&amp;quot;empColumns&amp;quot;&amp;gt;eid,emp_name,age,sex,email&amp;lt;/sql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;引用sql片段：&lt;code&gt;&amp;lt;include&amp;gt;&lt;/code&gt;标签&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--List&amp;lt;Emp&amp;gt; getEmpByCondition(Emp emp);--&amp;gt;
&amp;lt;select id=&amp;quot;getEmpByCondition&amp;quot; resultType=&amp;quot;Emp&amp;quot;&amp;gt;
	select &amp;lt;include refid=&amp;quot;empColumns&amp;quot;&amp;gt;&amp;lt;/include&amp;gt; from t_emp
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;拓展：&lt;br&gt;
SQL 代码片段的参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;sql id=&amp;quot;userColumns&amp;quot;&amp;gt; ${alias}.id,${alias}.username,${alias}.password &amp;lt;/sql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个 SQL 片段可以在其它语句中使用，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;select id=&amp;quot;selectUsers&amp;quot; resultType=&amp;quot;map&amp;quot;&amp;gt;
  select
    &amp;lt;include refid=&amp;quot;userColumns&amp;quot;&amp;gt;&amp;lt;property name=&amp;quot;alias&amp;quot; value=&amp;quot;t1&amp;quot;/&amp;gt;&amp;lt;/include&amp;gt;,
    &amp;lt;include refid=&amp;quot;userColumns&amp;quot;&amp;gt;&amp;lt;property name=&amp;quot;alias&amp;quot; value=&amp;quot;t2&amp;quot;/&amp;gt;&amp;lt;/include&amp;gt;
  from some_table t1
    cross join some_table t2
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以在 include 元素的 refid 属性或内部语句中使用属性值，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;sql id=&amp;quot;sometable&amp;quot;&amp;gt;
  ${prefix}Table
&amp;lt;/sql&amp;gt;

&amp;lt;sql id=&amp;quot;someinclude&amp;quot;&amp;gt;
  from
    &amp;lt;include refid=&amp;quot;${include_target}&amp;quot;/&amp;gt;
&amp;lt;/sql&amp;gt;

&amp;lt;select id=&amp;quot;select&amp;quot; resultType=&amp;quot;map&amp;quot;&amp;gt;
  select
    field1, field2, field3
  &amp;lt;include refid=&amp;quot;someinclude&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;prefix&amp;quot; value=&amp;quot;Some&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;include_target&amp;quot; value=&amp;quot;sometable&amp;quot;/&amp;gt;
  &amp;lt;/include&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;九-mybatis的缓存&#34;&gt;九、MyBatis的缓存&lt;/h1&gt;
&lt;h2 id=&#34;1-mybatis的一级缓存&#34;&gt;1、MyBatis的一级缓存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使一级缓存失效的四种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同的SqlSession对应不同的一级缓存&lt;/li&gt;
&lt;li&gt;同一个SqlSession但是查询条件不同&lt;/li&gt;
&lt;li&gt;同一个SqlSession两次查询期间执行了任何一次增删改操作&lt;/li&gt;
&lt;li&gt;同一个SqlSession两次查询期间手动清空了缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-mybatis的二级缓存&#34;&gt;2、MyBatis的二级缓存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二级缓存开启的条件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在核心配置文件中，设置全局配置属性cacheEnabled=&amp;quot;true&amp;quot;，默认为true，不需要设置&lt;/li&gt;
&lt;li&gt;在映射文件中设置标签&lt;code&gt;&amp;lt;cache /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;二级缓存必须在SqlSession关闭或提交之后有效&lt;/li&gt;
&lt;li&gt;查询的数据所转换的实体类类型必须实现序列化的接口&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使二级缓存失效的（唯一一种）情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-二级缓存的相关配置&#34;&gt;3、二级缓存的相关配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在mapper配置文件中添加的cache标签可以设置一些属性&lt;/li&gt;
&lt;li&gt;eviction属性：缓存回收策略
&lt;ul&gt;
&lt;li&gt;LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。&lt;/li&gt;
&lt;li&gt;FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。&lt;/li&gt;
&lt;li&gt;SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。&lt;/li&gt;
&lt;li&gt;WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。&lt;/li&gt;
&lt;li&gt;默认的是 LRU&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;flushInterval属性：刷新间隔，单位毫秒
&lt;ul&gt;
&lt;li&gt;默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;size属性：引用数目，正整数
&lt;ul&gt;
&lt;li&gt;代表缓存最多可以存储多少个对象，太大容易导致内存溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;readOnly属性：只读，true/false
&lt;ul&gt;
&lt;li&gt;true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。&lt;/li&gt;
&lt;li&gt;false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-mybatis缓存查询的顺序&#34;&gt;4、MyBatis缓存查询的顺序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用&lt;/li&gt;
&lt;li&gt;如果二级缓存没有命中，再查询一级缓存&lt;/li&gt;
&lt;li&gt;如果一级缓存也没有命中，则查询数据库&lt;/li&gt;
&lt;li&gt;SqlSession关闭之后，一级缓存中的数据会写入二级缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-整合第三方缓存ehcache了解&#34;&gt;5、整合第三方缓存EHCache（了解）&lt;/h2&gt;
&lt;h3 id=&#34;添加依赖&#34;&gt;添加依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- Mybatis EHCache整合包 --&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.mybatis.caches&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;mybatis-ehcache&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.2.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- slf4j日志门面的一个具体实现 --&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;各个jar包的功能&#34;&gt;各个jar包的功能&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;jar包名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mybatis-ehcache&lt;/td&gt;
&lt;td&gt;Mybatis和EHCache的整合包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ehcache&lt;/td&gt;
&lt;td&gt;EHCache核心包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;slf4j-api&lt;/td&gt;
&lt;td&gt;SLF4J日志门面包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;logback-classic&lt;/td&gt;
&lt;td&gt;支持SLF4J门面接口的一个具体实现&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;创建ehcache的配置文件ehcachexml&#34;&gt;创建EHCache的配置文件ehcache.xml&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;名字必须叫&lt;code&gt;ehcache.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot; ?&amp;gt;
&amp;lt;ehcache xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:noNamespaceSchemaLocation=&amp;quot;../config/ehcache.xsd&amp;quot;&amp;gt;
    &amp;lt;!-- 磁盘保存路径 --&amp;gt;
    &amp;lt;diskStore path=&amp;quot;D:\atguigu\ehcache&amp;quot;/&amp;gt;
    &amp;lt;defaultCache
            maxElementsInMemory=&amp;quot;1000&amp;quot;
            maxElementsOnDisk=&amp;quot;10000000&amp;quot;
            eternal=&amp;quot;false&amp;quot;
            overflowToDisk=&amp;quot;true&amp;quot;
            timeToIdleSeconds=&amp;quot;120&amp;quot;
            timeToLiveSeconds=&amp;quot;120&amp;quot;
            diskExpiryThreadIntervalSeconds=&amp;quot;120&amp;quot;
            memoryStoreEvictionPolicy=&amp;quot;LRU&amp;quot;&amp;gt;
    &amp;lt;/defaultCache&amp;gt;
&amp;lt;/ehcache&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设置二级缓存的类型&#34;&gt;设置二级缓存的类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在xxxMapper.xml文件中设置二级缓存类型&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;cache type=&amp;quot;org.mybatis.caches.ehcache.EhcacheCache&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;加入logback日志&#34;&gt;加入logback日志&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件&lt;code&gt;logback.xml&lt;/code&gt;，名字固定，不可改变&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;configuration debug=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;!-- 指定日志输出的位置 --&amp;gt;
    &amp;lt;appender name=&amp;quot;STDOUT&amp;quot;
              class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;!-- 日志输出的格式 --&amp;gt;
            &amp;lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&amp;gt;
            &amp;lt;pattern&amp;gt;[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&amp;gt;
    &amp;lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&amp;gt;
    &amp;lt;root level=&amp;quot;DEBUG&amp;quot;&amp;gt;
        &amp;lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&amp;gt;
        &amp;lt;appender-ref ref=&amp;quot;STDOUT&amp;quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
    &amp;lt;!-- 根据特殊需求指定局部日志级别 --&amp;gt;
    &amp;lt;logger name=&amp;quot;com.atguigu.crowd.mapper&amp;quot; level=&amp;quot;DEBUG&amp;quot;/&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ehcache配置文件说明&#34;&gt;EHCache配置文件说明&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;maxElementsInMemory&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;在内存中缓存的element的最大数目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;maxElementsOnDisk&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;在磁盘上缓存的element的最大数目，若是0表示无穷大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eternal&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;overflowToDisk&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;timeToIdleSeconds&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;timeToLiveSeconds&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;缓存element的有效生命期，默认是0.,也就是element存活时间无穷大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;diskSpoolBufferSizeMB&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;diskPersistent&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;diskExpiryThreadIntervalSeconds&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;memoryStoreEvictionPolicy&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;十-mybatis的逆向工程&#34;&gt;十、MyBatis的逆向工程&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的&lt;/li&gt;
&lt;li&gt;逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：
&lt;ul&gt;
&lt;li&gt;Java实体类&lt;/li&gt;
&lt;li&gt;Mapper接口&lt;/li&gt;
&lt;li&gt;Mapper映射文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-创建逆向工程的步骤&#34;&gt;1、创建逆向工程的步骤&lt;/h2&gt;
&lt;h3 id=&#34;添加依赖和插件&#34;&gt;添加依赖和插件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
	&amp;lt;!-- MyBatis核心依赖包 --&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;3.5.9&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;!-- junit测试 --&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;4.13.2&amp;lt;/version&amp;gt;
		&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;!-- MySQL驱动 --&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;8.0.27&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
	&amp;lt;!-- log4j日志 --&amp;gt;
	&amp;lt;dependency&amp;gt;
		&amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
		&amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
		&amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&amp;lt;!-- 控制Maven在构建过程中相关配置 --&amp;gt;
&amp;lt;build&amp;gt;
	&amp;lt;!-- 构建过程中用到的插件 --&amp;gt;
	&amp;lt;plugins&amp;gt;
		&amp;lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&amp;gt;
		&amp;lt;plugin&amp;gt;
			&amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;1.3.0&amp;lt;/version&amp;gt;
			&amp;lt;!-- 插件的依赖 --&amp;gt;
			&amp;lt;dependencies&amp;gt;
				&amp;lt;!-- 逆向工程的核心依赖 --&amp;gt;
				&amp;lt;dependency&amp;gt;
					&amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
					&amp;lt;artifactId&amp;gt;mybatis-generator-core&amp;lt;/artifactId&amp;gt;
					&amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
				&amp;lt;/dependency&amp;gt;
				&amp;lt;!-- 数据库连接池 --&amp;gt;
				&amp;lt;dependency&amp;gt;
					&amp;lt;groupId&amp;gt;com.mchange&amp;lt;/groupId&amp;gt;
					&amp;lt;artifactId&amp;gt;c3p0&amp;lt;/artifactId&amp;gt;
					&amp;lt;version&amp;gt;0.9.2&amp;lt;/version&amp;gt;
				&amp;lt;/dependency&amp;gt;
				&amp;lt;!-- MySQL驱动 --&amp;gt;
				&amp;lt;dependency&amp;gt;
					&amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
					&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
					&amp;lt;version&amp;gt;8.0.27&amp;lt;/version&amp;gt;
				&amp;lt;/dependency&amp;gt;
			&amp;lt;/dependencies&amp;gt;
		&amp;lt;/plugin&amp;gt;
	&amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建mybatis的核心配置文件&#34;&gt;创建MyBatis的核心配置文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;properties resource=&amp;quot;jdbc.properties&amp;quot;/&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;package name=&amp;quot;&amp;quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;
    &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;package name=&amp;quot;&amp;quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建逆向工程的配置文件&#34;&gt;创建逆向工程的配置文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文件名必须是：&lt;code&gt;generatorConfig.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
        PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot;&amp;gt;
&amp;lt;generatorConfiguration&amp;gt;
    &amp;lt;!--
    targetRuntime: 执行生成的逆向工程的版本
    MyBatis3Simple: 生成基本的CRUD（清新简洁版）
    MyBatis3: 生成带条件的CRUD（奢华尊享版）
    --&amp;gt;
    &amp;lt;context id=&amp;quot;DB2Tables&amp;quot; targetRuntime=&amp;quot;MyBatis3Simple&amp;quot;&amp;gt;
        &amp;lt;!-- 数据库的连接信息 --&amp;gt;
        &amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;
                        connectionURL=&amp;quot;jdbc:mysql://localhost:3306/mybatis&amp;quot;
                        userId=&amp;quot;root&amp;quot;
                        password=&amp;quot;123456&amp;quot;&amp;gt;
        &amp;lt;/jdbcConnection&amp;gt;
        &amp;lt;!-- javaBean的生成策略--&amp;gt;
        &amp;lt;javaModelGenerator targetPackage=&amp;quot;com.atguigu.mybatis.pojo&amp;quot; targetProject=&amp;quot;.\src\main\java&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
            &amp;lt;property name=&amp;quot;trimStrings&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
        &amp;lt;/javaModelGenerator&amp;gt;
        &amp;lt;!-- SQL映射文件的生成策略 --&amp;gt;
        &amp;lt;sqlMapGenerator targetPackage=&amp;quot;com.atguigu.mybatis.mapper&amp;quot;
                         targetProject=&amp;quot;.\src\main\resources&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
        &amp;lt;/sqlMapGenerator&amp;gt;
        &amp;lt;!-- Mapper接口的生成策略 --&amp;gt;
        &amp;lt;javaClientGenerator type=&amp;quot;XMLMAPPER&amp;quot;
                             targetPackage=&amp;quot;com.atguigu.mybatis.mapper&amp;quot; targetProject=&amp;quot;.\src\main\java&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
        &amp;lt;/javaClientGenerator&amp;gt;
        &amp;lt;!-- 逆向分析的表 --&amp;gt;
        &amp;lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&amp;gt;
        &amp;lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&amp;gt;
        &amp;lt;table tableName=&amp;quot;t_emp&amp;quot; domainObjectName=&amp;quot;Emp&amp;quot;/&amp;gt;
        &amp;lt;table tableName=&amp;quot;t_dept&amp;quot; domainObjectName=&amp;quot;Dept&amp;quot;/&amp;gt;
    &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;执行mbg插件的generate目标&#34;&gt;执行MBG插件的generate目标&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713163734.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;如果出现报错：&lt;code&gt;Exception getting JDBC Driver&lt;/code&gt;，可能是pom.xml中，数据库驱动配置错误
&lt;ul&gt;
&lt;li&gt;dependency中的驱动&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713163822.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;mybatis-generator-maven-plugin插件中的驱动&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713163909.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;两者的驱动版本应该相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;执行结果&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713163938.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-qbc&#34;&gt;2、QBC&lt;/h2&gt;
&lt;h3 id=&#34;查询&#34;&gt;查询&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;selectByExample&lt;/code&gt;：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;example.createCriteria().xxx&lt;/code&gt;：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;example.or().xxx&lt;/code&gt;：将之前添加的条件通过or拼接其他条件&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713164045.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test public void testMBG() throws IOException {
	InputStream is = Resources.getResourceAsStream(&amp;quot;mybatis-config.xml&amp;quot;);
	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
	SqlSession sqlSession = sqlSessionFactory.openSession(true);
	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
	EmpExample example = new EmpExample();
	//名字为张三，且年龄大于等于20
	example.createCriteria().andEmpNameEqualTo(&amp;quot;张三&amp;quot;).andAgeGreaterThanOrEqualTo(20);
	//或者did不为空
	example.or().andDidIsNotNull();
	List&amp;lt;Emp&amp;gt; emps = mapper.selectByExample(example);
	emps.forEach(System.out::println);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713164114.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;增改&#34;&gt;增改&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;updateByPrimaryKey&lt;/code&gt;：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mapper.updateByPrimaryKey(new Emp(1,&amp;quot;admin&amp;quot;,22,null,&amp;quot;456@qq.com&amp;quot;,3));&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713164152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;updateByPrimaryKeySelective()&lt;/code&gt;：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mapper.updateByPrimaryKeySelective(new Emp(2,&amp;quot;admin2&amp;quot;,22,null,&amp;quot;456@qq.com&amp;quot;,3));&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713164215.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;十一-分页插件&#34;&gt;十一、分页插件&lt;/h1&gt;
&lt;h2 id=&#34;1-分页插件使用步骤&#34;&gt;1、分页插件使用步骤&lt;/h2&gt;
&lt;h3 id=&#34;添加依赖-2&#34;&gt;添加依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;pagehelper&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;5.2.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置分页插件&#34;&gt;配置分页插件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在MyBatis的核心配置文件（mybatis-config.xml）中配置插件&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713164258.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;plugins&amp;gt;
    &amp;lt;!--设置分页插件--&amp;gt;
    &amp;lt;plugin interceptor=&amp;quot;com.github.pagehelper.PageInterceptor&amp;quot;&amp;gt;
        &amp;lt;!--reasonable：分页合理化参数，默认值为false,直接根据参数进行查询。
          当该参数设置为 true 时，pageNum&amp;lt;=0 时会查询第一页， pageNum&amp;gt;pages（超过总数时），会查询最后一页。--&amp;gt;
        &amp;lt;property name=&amp;quot;reasonable&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;pageSizeZero&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-分页插件的使用&#34;&gt;2、分页插件的使用&lt;/h2&gt;
&lt;h3 id=&#34;开启分页功能&#34;&gt;开启分页功能&lt;/h3&gt;
&lt;p&gt;在查询功能之前使用&lt;code&gt;PageHelper.startPage(int pageNum, int pageSize)&lt;/code&gt;开启分页功能&lt;br&gt;
- pageNum：当前页的页码&lt;br&gt;
- pageSize：每页显示的条数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testPageHelper() throws IOException {
	InputStream is = Resources.getResourceAsStream(&amp;quot;mybatis-config.xml&amp;quot;);
	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
	SqlSession sqlSession = sqlSessionFactory.openSession(true);
	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
	//访问第一页，每页四条数据
	PageHelper.startPage(1,4);
	List&amp;lt;Emp&amp;gt; emps = mapper.selectByExample(null);
	emps.forEach(System.out::println);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220713164319.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;分页相关数据&#34;&gt;分页相关数据&lt;/h3&gt;
&lt;h4 id=&#34;方法一直接输出&#34;&gt;方法一：直接输出&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testPageHelper() throws IOException {
	InputStream is = Resources.getResourceAsStream(&amp;quot;mybatis-config.xml&amp;quot;);
	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
	SqlSession sqlSession = sqlSessionFactory.openSession(true);
	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
	//访问第一页，每页四条数据
	Page&amp;lt;Object&amp;gt; page = PageHelper.startPage(1, 4);
	List&amp;lt;Emp&amp;gt; emps = mapper.selectByExample(null);
	//在查询到List集合后，打印分页数据
	System.out.println(page);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分页相关数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName=&#39;admin&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3}, Emp{eid=2, empName=&#39;admin2&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3}, Emp{eid=3, empName=&#39;王五&#39;, age=12, sex=&#39;女&#39;, email=&#39;123@qq.com&#39;, did=3}, Emp{eid=4, empName=&#39;赵六&#39;, age=32, sex=&#39;男&#39;, email=&#39;123@qq.com&#39;, did=1}]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;方法二使用pageinfo&#34;&gt;方法二：使用PageInfo&lt;/h4&gt;
&lt;p&gt;在查询获取list集合之后，使用&lt;code&gt;PageInfo&amp;lt;T&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(List&amp;lt;T&amp;gt; list, navigatePages)&lt;/code&gt;获取分页相关数据（或 &lt;code&gt;PageInfo&amp;lt;T&amp;gt; pageInfo = PageInfo.of(list, navigatePages)&lt;/code&gt; ）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;list：分页之后的数据&lt;/li&gt;
&lt;li&gt;navigatePages：导航分页的页码数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testPageHelper() throws IOException {
	InputStream is = Resources.getResourceAsStream(&amp;quot;mybatis-config.xml&amp;quot;);
	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
	SqlSession sqlSession = sqlSessionFactory.openSession(true);
	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
	PageHelper.startPage(1, 4);
	List&amp;lt;Emp&amp;gt; emps = mapper.selectByExample(null);
	PageInfo&amp;lt;Emp&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(emps,5);//或PageInfo&amp;lt;Emp&amp;gt; pageInfo = PageInfo.of(emps, 5);
	System.out.println(pageInfo);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分页相关数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PageInfo{
pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, 
list=Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName=&#39;admin&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3}, Emp{eid=2, empName=&#39;admin2&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3}, Emp{eid=3, empName=&#39;王五&#39;, age=12, sex=&#39;女&#39;, email=&#39;123@qq.com&#39;, did=3}, Emp{eid=4, empName=&#39;赵六&#39;, age=32, sex=&#39;男&#39;, email=&#39;123@qq.com&#39;, did=1}], 
prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中list中的数据等同于方法一中直接输出的page数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;常用数据&#34;&gt;常用数据：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;pageNum：当前页的页码&lt;/li&gt;
&lt;li&gt;pageSize：每页显示的条数&lt;/li&gt;
&lt;li&gt;size：当前页显示的真实条数&lt;/li&gt;
&lt;li&gt;total：总记录数&lt;/li&gt;
&lt;li&gt;pages：总页数&lt;/li&gt;
&lt;li&gt;prePage：上一页的页码&lt;/li&gt;
&lt;li&gt;nextPage：下一页的页码&lt;/li&gt;
&lt;li&gt;isFirstPage/isLastPage：是否为第一页/最后一页&lt;/li&gt;
&lt;li&gt;hasPreviousPage/hasNextPage：是否存在上一页/下一页&lt;/li&gt;
&lt;li&gt;navigatePages：导航分页的页码数&lt;/li&gt;
&lt;li&gt;navigatepageNums：导航分页的页码，[1,2,3,4,5]&lt;/li&gt;
&lt;/ul&gt;
">MyBatis笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/docker-bi-ji/"" data-c="
          &lt;h2 id=&#34;安装-docker&#34;&gt;安装 Docker&lt;/h2&gt;
&lt;h3 id=&#34;方式一&#34;&gt;方式一：&lt;/h3&gt;
&lt;p&gt;一般云服务厂商都有提供 Docker 应用系统镜像，直接选择该应用系统镜像即可&lt;/p&gt;
&lt;h3 id=&#34;方式二&#34;&gt;方式二：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 环境安装：
yum -y install gcc-c++

# 第一步：安装必要的一些系统工具
yum install -y yum-utils device-mapper-persistent-data lvm2

# 第二步：添加软件源信息
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
 
# 第三步：更新并安装Docker-CE
yum makecache fast

yum -y install docker-ce

# 第四步：开启Docker服务
service docker start

# 第五步、测试是否安装成功
docker -v

# 可选
# 第六步：配置镜像加速器
# 您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器
# 下面的所有命令可以一起复制粘贴
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&#39;EOF&#39;
{
  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://ldu6wrsf.mirror.aliyuncs.com&amp;quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker ps&lt;/code&gt; 查看当前运行中的容器&lt;br&gt;
&lt;code&gt;docker ps -a&lt;/code&gt; 查看 Docker 所有容器，包括未运行状态的&lt;br&gt;
&lt;code&gt;docker images&lt;/code&gt; 查看镜像列表&lt;br&gt;
&lt;code&gt;docker start 容器id&lt;/code&gt; 启动容器&lt;br&gt;
&lt;code&gt;docker restart 容器id&lt;/code&gt; 重启容器&lt;br&gt;
&lt;code&gt;stop/kill&lt;/code&gt; 停止/强制停止容器&lt;br&gt;
&lt;code&gt;rm&lt;/code&gt; 删除容器&lt;br&gt;
&lt;code&gt;rmi&lt;/code&gt; 删除镜像&lt;br&gt;
&lt;code&gt;rm -f&lt;/code&gt; 强制删除容器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;run 命令参考：&lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/run/&#34;&gt;https://docs.docker.com/engine/reference/commandline/run/&lt;/a&gt; （官方）&lt;/li&gt;
&lt;li&gt;或 &lt;a href=&#34;https://www.runoob.com/docker/docker-run-command.html&#34;&gt;https://www.runoob.com/docker/docker-run-command.html&lt;/a&gt;（中文）&lt;/li&gt;
&lt;li&gt;Docker 所有命令参考：&lt;a href=&#34;https://www.runoob.com/docker/docker-command-manual.html&#34;&gt;https://www.runoob.com/docker/docker-command-manual.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设置-docker-容器自启动&#34;&gt;设置 Docker 容器自启动&lt;/h2&gt;
&lt;p&gt;首先保证 Docker 开机自启动&lt;br&gt;
&lt;code&gt;systemctl enable docker&lt;/code&gt;&lt;br&gt;
设置 Docker 容器自启动有两种方式&lt;br&gt;
方式一：创建容器时追加参数：&lt;code&gt;--restart=always&lt;/code&gt;&lt;br&gt;
方式二：update 已有容器：&lt;code&gt;docker update --restart=always 容器id&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--restart具体参数值详细信息：
       no　　　　　　　 // 默认策略,容器退出时不重启容器；
       on-failure　　  // 在容器非正常退出时（退出状态非0）才重新启动容器；
       on-failure:3    // 在容器非正常退出时重启容器，最多重启3次；
       always　　　　  // 无论退出状态是如何，都重启容器；
       unless-stopped  // 在容器退出时总是重启容器，但是不考虑在 Docker 守护进程启动时就已经停止了的容器。
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;查看 Docker 是否开机自启：systemctl is-enable docker&lt;br&gt;
启动 Docker：systemctl start docker&lt;br&gt;
停止 Docker：systemctl stop docker&lt;br&gt;
重启 Docker：systemctl restart docker 一般宿主机的防火墙状态发生改变后，最好重启一下 Docker&lt;br&gt;
通过运行 hello-world 镜像来验证是否正确安装了 Docker Engine-Community ：docker run hello-world&lt;br&gt;
查看 Docker 版本：docker -v&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;迁移与备份&#34;&gt;迁移与备份&lt;/h2&gt;
&lt;h3 id=&#34;容器保存为镜像&#34;&gt;容器保存为镜像&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker commit 容器id 镜像名称&lt;/code&gt; 例如：docker commit mynginx mynginx_i&lt;/p&gt;
&lt;h3 id=&#34;镜像备份&#34;&gt;镜像备份&lt;/h3&gt;
&lt;p&gt;我们可以通过以下命令将镜像保存为 tar 文件&lt;br&gt;
&lt;code&gt;docker sava -o xxx.tar 镜像名称&lt;/code&gt; 其中xxx 为文件名，-o 表示 output 输出。例如：docker sava -o mynginx.tar mynginx_i&lt;/p&gt;
&lt;h3 id=&#34;镜像迁移与恢复&#34;&gt;镜像迁移与恢复&lt;/h3&gt;
&lt;p&gt;我们可以通过以下命令通过本地 tar 文件导入镜像&lt;br&gt;
&lt;code&gt;docker load -i xxx.tar&lt;/code&gt; 例如：docker load -i mynginx.tar&lt;/p&gt;
&lt;h2 id=&#34;docker-私有仓库待整理&#34;&gt;Docker 私有仓库（待整理）&lt;/h2&gt;
&lt;p&gt;根据 Docker 课程，与云原生课程整理&lt;/p&gt;
&lt;h2 id=&#34;打包-java-应用&#34;&gt;打包 Java 应用&lt;/h2&gt;
&lt;h3 id=&#34;方式一通过-idea-快速构建镜像并运行&#34;&gt;方式一：通过 IDEA 快速构建镜像并运行&lt;/h3&gt;
&lt;h4 id=&#34;1-编写-dockerfile&#34;&gt;① 编写 Dockerfile&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;FROM openjdk:8-jdk-slim

LABEL maintainer=kuangyang

COPY target/*.jar /app.jar
ENTRYPOINT [&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-设置镜像-tag-与运行参数&#34;&gt;② 设置镜像 tag 与运行参数&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20221027153327.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-运行或构建镜像&#34;&gt;③ 运行或构建镜像&lt;/h3&gt;
&lt;p&gt;点击 FROM 右侧 run 按钮，选择&lt;code&gt;运行&lt;/code&gt;或&lt;code&gt;构建镜像&lt;/code&gt;&lt;br&gt;
&lt;code&gt;运行&lt;/code&gt;是指 构建镜像 + 创建容器并运行&lt;br&gt;
&lt;code&gt;构建镜像&lt;/code&gt;是指 仅仅构建镜像&lt;/p&gt;
&lt;h3 id=&#34;方式二通过-docker-环境构建镜像并运行&#34;&gt;方式二：通过 Docker 环境构建镜像并运行&lt;/h3&gt;
&lt;h4 id=&#34;1-编写-dockerfile-2&#34;&gt;① 编写 Dockerfile&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;FROM openjdk:8-jdk-slim

LABEL maintainer=kuangyang

COPY target/*.jar /app.jar
ENTRYPOINT [&amp;quot;java&amp;quot;,&amp;quot;-jar&amp;quot;,&amp;quot;/app.jar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-构建镜像&#34;&gt;② 构建镜像&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 注意最后的空格和点，不能省略
docker build -t java-demo:1.0 .
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-启动容器&#34;&gt;③ 启动容器&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run --name  my-javademo -d -p 8080:8080 java-demo:1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;补充一查看容器运行-logs&#34;&gt;补充一：查看容器运行 logs&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker logs my-javademo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;补充二dockerfile-常用命令&#34;&gt;补充二：Dockerfile 常用命令&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20221027023113.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;docker-compose待学习&#34;&gt;Docker Compose（待学习）&lt;/h2&gt;
&lt;p&gt;https://www.bilibili.com/video/BV1gr4y1U7CY&lt;/p&gt;
&lt;h2 id=&#34;portainer-待学习&#34;&gt;Portainer （待学习）&lt;/h2&gt;
&lt;p&gt;https://www.bilibili.com/video/BV1gr4y1U7CY&lt;/p&gt;
&lt;h2 id=&#34;cig待学习&#34;&gt;CIG（待学习）&lt;/h2&gt;
&lt;p&gt;https://www.bilibili.com/video/BV1gr4y1U7CY&lt;/p&gt;
&lt;h2 id=&#34;安装-mysql-57&#34;&gt;安装 MySQL 5.7&lt;/h2&gt;
&lt;h3 id=&#34;拉取mysql57的镜像&#34;&gt;拉取MySQL5.7的镜像&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo docker pull mysql:5.7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建运行一个实例&#34;&gt;创建运行一个实例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run --name mysql5 -p 3305:3306 -e MYSQL_ROOT_PASSWORD=abc123 -d mysql:5.7 --character_set_server=utf8mb4 --collation_server=utf8mb4_unicode_ci
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数说明&lt;br&gt;
&lt;code&gt;--name mysql5&lt;/code&gt; 设置新容器的名字为 mysql5&lt;br&gt;
&lt;code&gt;-p 3305:3306&lt;/code&gt; 设置端口映射，格式为：主机(宿主)端口:容器端口，这里即，将计算机3305端口映射到容器的3306端口&lt;br&gt;
&lt;code&gt;-e MYSQL\_ROOT\_PASSWORD=abc123&lt;/code&gt; 设置环境变量，将root用户的密码设为abc123&lt;br&gt;
&lt;code&gt;-d &lt;/code&gt; 后台运行容器，并返回容器ID&lt;br&gt;
&lt;code&gt;--character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci&lt;/code&gt; 设置数据库默认的字符集和排序规则&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果出现乱码问题，针对 MySQL 5 可以使用&lt;code&gt;SHOW VARIABLES LIKE &#39;%char%&#39;;&lt;/code&gt;查看&lt;code&gt;character_set_server&lt;/code&gt;的编码&lt;br&gt;
若创建容器时忘记设置编码：&lt;br&gt;
a. 容器删了重建&lt;br&gt;
b. 进入容器，执行&lt;code&gt;echo &amp;quot;character-set-server=utf8&amp;quot; &amp;gt;&amp;gt; /etc/mysql/mysql.conf.d/mysqld.cnf&lt;/code&gt;&lt;br&gt;
若执行&lt;code&gt;echo &amp;quot;character-set-server=utf8&amp;quot; &amp;gt;&amp;gt; /etc/mysql/mysql.conf.d/mysqld.cnf&lt;/code&gt;更改编码时提示找不到文件或目录可以将这句命令复制粘贴到记事本，重新打一下符号，空格等，因为一般是编码问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;安装-mysql-8&#34;&gt;安装 MySQL 8&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 拉取 MySQL8 镜像
docker pull mysql:8.0

# 查看镜像
docker images

# 运行容器
docker run -p 3306:3306 --name mysql8 -e MYSQL_ROOT_PASSWORD=abc123 -d mysql:8.0  --default_authentication_plugin=mysql_native_password
# 其中环境参数是为了修改 MySQL8 的默认认证策略，避免连接时出现
# 2059 - Authentication plugin &#39;caching_ sha2_ password&#39; cannot be loaded:找不到指定的模块。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装-oracle11g&#34;&gt;安装 Oracle11g&lt;/h2&gt;
&lt;h3 id=&#34;拉取镜像&#34;&gt;拉取镜像&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;注意该镜像大约6.85GB&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查看镜像&#34;&gt;查看镜像&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker images
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;启动容器默认方式&#34;&gt;启动容器（默认方式）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run -d -p 1521:1521 --name oracle_11g registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;持久化启动方式如下可选特殊场景un&#34;&gt;持久化启动方式如下：（可选）(特殊场景)（UN）&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run -d -it -p 1521:1521 --name oracle_11g --restart=always --mount source=oracle_vol,target=/home/oracle/app/oracle/oradata registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;一般用默认启动方式就可以了，若是需要将数据保存到本地的采用持久化方式&lt;br&gt;
&lt;code&gt;–mount&lt;/code&gt;表示要将Host上的路径挂载到容器中&lt;br&gt;
&lt;code&gt;source=oracle_vol&lt;/code&gt;为Host的持久化卷，若未提前创建会自动创建，可通过docker volume instpect 【容器名】查看volume的具体位置，target为容器中的路径&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;查看容器&#34;&gt;查看容器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;容器状态up表示在运行状态&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;进入容器&#34;&gt;进入容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker exec -it oracle_11g bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;切换到root账户&#34;&gt;切换到root账户&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;默认进入之后是oracle账户&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;su - root
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;密码&lt;code&gt;helowin&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;编辑环境变量&#34;&gt;编辑环境变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入i开始编辑，在最后一行后添加以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2
export ORACLE_SID=helowin
export PATH=$ORACLE_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加完后 按&lt;code&gt;esc键&lt;/code&gt;一下，输入 &lt;code&gt;:qw&lt;/code&gt; 保存并退出，然后输入以下命令使配置生效：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;source /etc/profile 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：macOS Vim &lt;code&gt;esc键&lt;/code&gt; 可能失效，解决方案：按 &lt;code&gt;ctrl + c&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;创建软连接&#34;&gt;创建软连接&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ln -s $ORACLE_HOME/bin/sqlplus /usr/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;切换回-oracle-用户&#34;&gt;切换回 oracle 用户&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;su - oracle
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;登录sqlplus&#34;&gt;登录sqlplus&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sqlplus /nolog
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;conn /as sysdba
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;修改-sys-system-用户密码&#34;&gt;修改 sys、system 用户密码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;alter user system identified by YOUR_PASSWORD;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;alter user sys identified by YOUR_PASSWORD;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;默认密码是&lt;code&gt;helowin&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;创建用户可选根据需要&#34;&gt;创建用户（可选，根据需要）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;创建一个具有dba权限的用户（sysdba)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;create user YOUR_NAME identified by YOUR_PASSWORD;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;grant connect,resource,dba to YOUR_NAME;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;连接测试&#34;&gt;连接测试&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220725022443.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220725022458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oracle.com/database/sqldeveloper/technologies/download/&#34;&gt;🔗Oracle SQL Developer工具官方下载链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安装-mongodb&#34;&gt;安装 MongoDB&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 1、拉取镜像
docker pull mongo:4.4.8
# 查看拉取的镜像
docker images

# 2、创建和启动容器
# 针对个人电脑
docker run --name my-mongo -d -p 27017:27017 -v /Users/kuangyang/docker-v/mongo/data/db:/data/db -d mongo:4.4.8

# 针对 Linux 服务器
#（1）对data目录授权
chmod 777 data
#（2）创建和启动容器
docker run -d --restart=always -p 27017:27017 --name my-mongo -v /data/db:/data/db -d mongo:4.4.8
 
# 3、进入容器
docker exec -it my-mongo /bin/bash
 
# 4、使用 MongoDB 客户端进行操作
mongo
&amp;gt; show dbs # 查询所有的数据库
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装-redis&#34;&gt;安装 Redis&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 拉取最新 redis 镜像
docker pull redis

# 查看拉取的镜像
docker images

# 创建一个实例
# ① 若不需要设置目录挂载
docker run --name my-redis -d -p 6379:6379 redis

# ② 若不需要设置目录挂载，但需要持久化数据
# 有几种不同的持久性策略可供选择。此选项将每 60 秒保存一次数据库快照（它也会导致更多日志，因此该loglevel选项可能是可取的）。如果启用了持久性，则数据存储在 /data
# 有关 Redis 持久性的更多信息，请参阅http://redis.io/topics/persistence
docker run --name my-redis -d -p 6379:6379 redis redis-server --save 60 1 --loglevel warning

# ③ 若需要设置目录挂载
docker run --name my-redis -d -p 6379:6379 -v /Users/kuangyang/docker-v/redis/redis.conf:/usr/local/etc/redis/redis.conf -v /Users/kuangyang/docker-v/redis/data:/data redis redis-server /usr/local/etc/redis/redis.conf

# 查看运行中的容器
docker ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;redis.conf 参考(6)：&lt;br&gt;
&lt;a href=&#34;https://www.runoob.com/redis/redis-conf.html&#34;&gt;https://www.runoob.com/redis/redis-conf.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装-nacos&#34;&gt;安装 Nacos&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 第一步：拉取镜像
docker pull nacos/nacos-server:v2.1.2-slim
# 第二步：启动
docker run -e MODE=standalone --name my-nacos  -d -p 8848:8848 -e JVM_XMS=512m -e JVM_XMX=512m nacos/nacos-server:v2.1.2-slim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解更多信息：&lt;br&gt;
&lt;a href=&#34;https://hub.docker.com/r/nacos/nacos-server&#34;&gt;https://hub.docker.com/r/nacos/nacos-server&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run -d  \
-e MODE=standalone  \
-e PREFER_HOST_MODE=hostname  \
-e SPRING_DATASOURCE_PLATFORM=mysql  \
-e MYSQL_SERVICE_HOST=192.168.6.103 \
-e MYSQL_SERVICE_PORT=3306  \
-e MYSQL_SERVICE_USER=root  \
-e MYSQL_SERVICE_PASSWORD=root  \
-e MYSQL_SERVICE_DB_NAME=nacos  \
-p 8848:8848  \
--name nacos  \
--restart=always  \
nacos/nacos-server:1.4.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装-sentinel-dashboard&#34;&gt;安装 Sentinel Dashboard&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 第一步：拉取镜像
docker pull bladex/sentinel-dashboard
# 第二步：启动
docker run --name sentinel-dashboard -p 8858:8858 -d bladex/sentinel-dashboard:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装-elasticsearch&#34;&gt;安装 Elasticsearch&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 第一步：拉取镜像
docker pull elasticsearch:7.8.0

# Linux
# 第二步：启动
需要建立：两个文件夹
mkdir -p /mydata/elasticsearch/plugins
mkdir -p /mydata/elasticsearch/data
授予权限 chmod 777 /mydata/elasticsearch/data
docker run -p 9200:9200 -p 9300:9300 --name my-elasticsearch --restart=always \
-e &amp;quot;discovery.type=single-node&amp;quot; \
-e ES_JAVA_OPTS=&amp;quot;-Xms512m -Xmx512m&amp;quot; \
-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \
-d elasticsearch:7.8.0

# Mac
# 第二步：启动
docker run -p 9200:9200 -p 9300:9300 --name my-elasticsearch \
-e &amp;quot;discovery.type=single-node&amp;quot; \
-e ES_JAVA_OPTS=&amp;quot;-Xms512m -Xmx512m&amp;quot; \
-d elasticsearch:7.8.0

# 第三步：安装中文分词器
1.下载elasticsearch-analysis-ik-7.8.0.zip
&amp;lt;https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.8.0&amp;gt;
2.上传解压：unzip elasticsearch-analysis-ik-7.8.0.zip -d ik-analyzer
3.上传到es容器：docker cp ./ik-analyzer my-elasticsearch:/usr/share/elasticsearch/plugins
4.重启es：docker restart my-elasticsearch
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装-kibana&#34;&gt;安装 Kibana&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 第一步：拉取镜像
docker pull kibana:7.8.0
# 第二步：启动
docker run --name kibana -e ELASTICSEARCH_URL=http://elasticsearch:9200 -p 5601:5601 -d --link my-elasticsearch:elasticsearch kibana:7.8.0
进入容器修改：docker exec -it kibana /bin/bash
cd config
vi kibana.yml
最后一行追加：
i18n.locale: zh-CN
docker restart kibana 重启kibana

测试：安装分词词库是否可以使用！
GET /.kibana/_analyze
{
  &amp;quot;text&amp;quot;: &amp;quot;我是中国人&amp;quot;,
  &amp;quot;analyzer&amp;quot;: &amp;quot;ik_max_word&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装-logstash&#34;&gt;安装 Logstash&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 第一步：拉取镜像
docker pull logstash:7.8.0
# 提前准备配置文件  /mydata/logstash/logstash.conf （也可以容器启动后再修改）
# Linux
mkdir -p /mydata/logstash
cd /mydata/logstash
vi logstash.conf
内容：
	input {
	  tcp {
		mode =&amp;gt; &amp;quot;server&amp;quot;
		host =&amp;gt; &amp;quot;0.0.0.0&amp;quot;
		port =&amp;gt; 5044
		codec =&amp;gt; json_lines
	  }
	}
	filter{
	  
	}
	output {
	  elasticsearch {
		hosts =&amp;gt; &amp;quot;es:9200&amp;quot;
		index =&amp;gt; &amp;quot;gmall-%{+YYYY.MM.dd}&amp;quot;
	  }
	}

# 第二步：启动
# ① 若提前准备了配置文件
docker run --name logstash -p 5044:5044 --link my-elasticsearch:es -v /mydata/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf -d logstash:7.8.0
# ② 若提前没有准备配置文件，打算创建容器后再修改（推荐）
docker run --name logstash -p 5044:5044 --link my-elasticsearch:elasticsearch -d logstash:7.8.0
# 修改配置文件
docker exec -it logstash /bin/bash
cd pipeline
vi logstash.conf
全部内容：
	input {
	  tcp {
		mode =&amp;gt; &amp;quot;server&amp;quot;
		host =&amp;gt; &amp;quot;0.0.0.0&amp;quot;
		port =&amp;gt; 5044
		codec =&amp;gt; json_lines
	  }
	}
	filter{
	  
	}
	output {
	  elasticsearch {
		hosts =&amp;gt; &amp;quot;elasticsearch:9200&amp;quot;
		index =&amp;gt; &amp;quot;gmall-%{+YYYY.MM.dd}&amp;quot;
	  }
	}
重启容器
docker restart logstash
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装-zipkin&#34;&gt;安装 Zipkin&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 第一步：拉取镜像
docker pull openzipkin/zipkin
# 第二步：启动
docker run --name zipkin -d -p 9411:9411 openzipkin/zipkin 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装-minio&#34;&gt;安装 MinIO&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 第一步：拉取镜像
docker pull minio/minio
# 第二步：启动
# Linux
docker run \
  -p 9000:9000 \
  -p 9001:9001 \
  --name minio \
  -d --restart=always \
  -e &amp;quot;MINIO_ROOT_USER=admin&amp;quot; \
  -e &amp;quot;MINIO_ROOT_PASSWORD=abc123456&amp;quot; \
  -v /home/data:/data \
  -v /home/config:/root/.minio \
  minio/minio server /data --console-address &amp;quot;:9001&amp;quot;
# Mac
docker run \
  -p 9000:9000 \
  -p 9001:9001 \
  --name minio  -d \
  -e &amp;quot;MINIO_ROOT_USER=admin&amp;quot; \
  -e &amp;quot;MINIO_ROOT_PASSWORD=abc123456&amp;quot; \
  minio/minio server /data --console-address &amp;quot;:9001&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浏览器访问：http://IP:9001&lt;/p&gt;
&lt;h2 id=&#34;安装-nginx&#34;&gt;安装 Nginx&lt;/h2&gt;
&lt;h3 id=&#34;拉取最新版的-nginx-镜像&#34;&gt;拉取最新版的 Nginx 镜像&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker pull nginx:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;code&gt;docker pull nginx&lt;/code&gt;，因为默认就是最新版&lt;/p&gt;
&lt;h3 id=&#34;查看当前所有镜像&#34;&gt;查看当前所有镜像&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker images
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;准备本地映射目录&#34;&gt;准备本地映射目录&lt;/h3&gt;
&lt;p&gt;映射目录为：&lt;code&gt;/Users/kuangyang/docker-nginx&lt;/code&gt;&lt;br&gt;
需要至少将 &lt;code&gt;nginx.conf&lt;/code&gt; 与 &lt;code&gt;default.conf&lt;/code&gt; 准备好&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220922045321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nginx.conf 示例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#user  nobody;
worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
   
    keepalive_timeout  65;

    gzip  on;
	server {
		#监听的端口
        listen       80;
		#监听的域名
        server_name  manage.ego.com;  
		#转发头信息
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		#请求映射规则,/表示映射一切请求路径
        location / {
			#代理转发到
			proxy_pass http://192.168.0.232:9001;
			proxy_connect_timeout 600;
			proxy_read_timeout 600;
        }
    }
	server {
        listen       80;
        server_name  api.ego.com;

        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        location / {
			proxy_pass http://192.168.0.232:10010;
			proxy_connect_timeout 600;
			proxy_read_timeout 600;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;default.conf 示例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
    #                  &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
    #                  &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache&#39;s document root
        # concurs with nginx&#39;s one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运行-nginx-容器&#34;&gt;运行 Nginx  容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run --name nginx -p 80:80 -v /Users/kuangyang/docker-v/docker-nginx/www:/www -v /Users/kuangyang/docker-v/docker-nginx/nginx.conf:/etc/nginx/nginx.conf -v /Users/kuangyang/docker-v/docker-nginx/log:/var/log/nginx -v /Users/kuangyang/docker-v/docker-nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -d nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;br&gt;
&lt;code&gt;-d&lt;/code&gt;：设置容器在在后台一直运行&lt;/p&gt;
&lt;h2 id=&#34;安装-tomcat&#34;&gt;安装 Tomcat&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 拉取最新 tomcat 镜像
docker pull tomcat

# 查看拉取的镜像
docker images

# 创建一个实例
docker run --name=mytomcat -d -p 8080:8080 -v /Users/kuangyang/docker-v/docker-tomcat/webapps:/usr/local/tomcat/webapps tomcat

# 查看运行中的容器
docker ps

# 在 webapps 中创建一个文件夹，再创建一个 html 测试是否完成安装
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装-rabbitmq&#34;&gt;安装 RabbitMQ&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 拉取 RabbitMQ 最新镜像
docker pull rabbitmq

# 运行一个实例
docker run --name rabbitmq -d -p 15672:15672 -p 5672:5672 rabbitmq
# 或：更推荐，在创建容器实例时即指定默认用户名与密码，这样不会创建 guest 账户，并且默认账户拥有所有权限
docker run --name rabbitmq -d -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=abc123 rabbitmq

# 进入容器
docker exec -it 容器id /bin/bash

# 安装 Web 界面插件
rabbitmq-plugins enable rabbitmq_management

安装完成后，使用浏览器访问 http://127.0.0.1:15672，
默认的 guest 账户的用户名和密码都是guest。





# 若通过方式二创建的容器则无须下面的步骤

# 默认的 guest 账户有访问限制，默认只能通过本地网络(如 localhost) 访问，远程网络访问受限。
# 所以在使用时我们一般另外添加用户，例如我们添加一个root用户。
# 添加用户，用户名为root,密码为abc123
rabbitmqctl add_user root abc123

# 赋予 root 用户所有权限
rabbitmqctl set_permissions -p / root &amp;quot;.*&amp;quot; &amp;quot;.*&amp;quot; &amp;quot;.*&amp;quot;

# 赋予 root 用户 administrator 角色
rabbitmqctl set_user_tags root administrator

# 查看所有用户，即可看到 root 用户已经添加成功
rabbitmqctl list_users

接着返回浏览器登录 root 用户测试是否正常     






# 修复没有查看 Channels 的权限：Stats in management UI are disabled on this node
cd /etc/rabbitmq/conf.d/

# 修改 management_agent.disable_metrics_collector = false
echo management_agent.disable_metrics_collector = false &amp;gt; management_agent.disable_metrics_collector.conf

# 退出容器
exit

# 重启 RabbitMQ
docker restart 容器id

重启完成后登录 root 用户，测试是否能查看 Channels





# 若通过方式二创建的容器则无须下面的步骤

# 删除 guest 用户
# 再次进入容器
docker exec -it 容器id /bin/bash

# 执行删除
rabbitmqctl delete_user guest

# 查看所有用户，没有 guest 则删除成功
rabbitmqctl list_users





# 安装延时队列插件 
# 下载
首先前往官网下载 https://www.rabbitmq.com/community-plugins.html
插件：rabbitmq_delayed_message_exchange

# 将下载的插件文件 copy 到 RabbitMQ 的插件文件夹
# 提示：在下载文件所在目录执行这条命令
docker cp 文件名 容器id:/plugins

# 进入容器确认是否 copy 成功
docker exec -it 容器id /bin/bash
ls
cd plugins
ls

# 若看到刚刚复制的文件，则开始执行安装插件
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
# 提示 The following plugins have been configured: 则安装成功

# 重启 RabbitMQ
docker restart 容器id

最后在 web 管理页面，创建交换机时 Type 有 x-delayed-message 即可。

# 注：
通过延时队列插件实现延迟队列靠的是这种延迟交换机，
通过死信队列实现延迟队列靠的是队列，RabbitMQ 在队列只会检查第一个消息是否过期，所以会存在消息不会按时“死亡”问题。
&lt;/code&gt;&lt;/pre&gt;
">Docker笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/mysql-bi-ji/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;视频课程地址：&lt;a href=&#34;https://www.bilibili.com/video/BV1Kb411W75N&#34;&gt;https://www.bilibili.com/video/BV1Kb411W75N&lt;/a&gt;&lt;br&gt;
讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;br&gt;
官网：&lt;a href=&#34;http://www.atguigu.com&#34;&gt;http://www.atguigu.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;初级篇&#34;&gt;初级篇&lt;/h1&gt;
&lt;h2 id=&#34;一-mysql数据库基础篇大纲&#34;&gt;一、MySQL数据库基础篇大纲&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MySQL数据库基础篇分为5个篇章：&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-数据库概述与mysql安装篇&#34;&gt;&lt;strong&gt;1. 数据库概述与MySQL安装篇&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第01章：数据库概述&lt;/li&gt;
&lt;li&gt;第02章：MySQL环境搭建&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-sql之select使用篇&#34;&gt;&lt;strong&gt;2. SQL之SELECT使用篇&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第03章：基本的SELECT语句&lt;/li&gt;
&lt;li&gt;第04章：运算符&lt;/li&gt;
&lt;li&gt;第05章：排序与分页&lt;/li&gt;
&lt;li&gt;第06章：多表查询&lt;/li&gt;
&lt;li&gt;第07章：单行函数&lt;/li&gt;
&lt;li&gt;第08章：聚合函数&lt;/li&gt;
&lt;li&gt;第09章：子查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-sql之ddl-dml-dcl使用篇&#34;&gt;&lt;strong&gt;3. SQL之DDL、DML、DCL使用篇&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第10章：创建和管理表&lt;/li&gt;
&lt;li&gt;第11章：数据处理之增删改&lt;/li&gt;
&lt;li&gt;第12章：MySQL数据类型精讲&lt;/li&gt;
&lt;li&gt;第13章：约束&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-其它数据库对象篇&#34;&gt;&lt;strong&gt;4. 其它数据库对象篇&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第14章：视图&lt;/li&gt;
&lt;li&gt;第15章：存储过程与函数&lt;/li&gt;
&lt;li&gt;第16章：变量、流程控制与游标&lt;/li&gt;
&lt;li&gt;第17章：触发器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-mysql8-新特性篇&#34;&gt;&lt;strong&gt;5. MySQL8 新特性篇&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第18章：MySQL8其它新特性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-mysql高级特性篇大纲&#34;&gt;二、MySQL高级特性篇大纲&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MySQL高级特性分为4个篇章：&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-mysql架构篇&#34;&gt;&lt;strong&gt;1. MySQL架构篇&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第01章：Linux下MySQL的安装与使用&lt;/li&gt;
&lt;li&gt;第02章：MySQL的数据目录&lt;/li&gt;
&lt;li&gt;第03章：用户与权限管理&lt;/li&gt;
&lt;li&gt;第04章：逻辑架构&lt;/li&gt;
&lt;li&gt;第05章：存储引擎&lt;/li&gt;
&lt;li&gt;第06章：InnoDB数据页结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-索引及调优篇&#34;&gt;&lt;strong&gt;2. 索引及调优篇&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第07章：索引&lt;/li&gt;
&lt;li&gt;第08章：性能分析工具的使用&lt;/li&gt;
&lt;li&gt;第09章：索引优化与SQL优化&lt;/li&gt;
&lt;li&gt;第10章：数据库的设计规范&lt;/li&gt;
&lt;li&gt;第11章：数据库其他调优策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-事务篇&#34;&gt;&lt;strong&gt;3. 事务篇&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第12章：事务基础知识&lt;/li&gt;
&lt;li&gt;第13章：MySQL事务日志&lt;/li&gt;
&lt;li&gt;第14章：锁&lt;/li&gt;
&lt;li&gt;第15章：多版本并发控制(MVCC)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-日志与备份篇&#34;&gt;&lt;strong&gt;4. 日志与备份篇&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第16章：其它数据库日志&lt;/li&gt;
&lt;li&gt;第17章：主从复制&lt;/li&gt;
&lt;li&gt;第18章：数据库备份与恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-mysql高手是怎样炼成的&#34;&gt;三、MySQL高手是怎样炼成的&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;针对开发工程师、DBA、运维&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;mysql服务器的安装配置&lt;/li&gt;
&lt;li&gt;SQL编程(自定义函数、存储过程、触发器、定时任务)&lt;/li&gt;
&lt;li&gt;数据库索引建立&lt;/li&gt;
&lt;li&gt;SQL语句优化&lt;/li&gt;
&lt;li&gt;数据库内部结构和原理&lt;/li&gt;
&lt;li&gt;数据库的性能监控分析与系统优化&lt;/li&gt;
&lt;li&gt;各种参数常量设定&lt;/li&gt;
&lt;li&gt;数据库建模优化&lt;/li&gt;
&lt;li&gt;主从复制&lt;/li&gt;
&lt;li&gt;分布式架构搭建、垂直切割和水平切割&lt;/li&gt;
&lt;li&gt;MyCat&lt;/li&gt;
&lt;li&gt;数据迁移&lt;/li&gt;
&lt;li&gt;容灾备份和恢复&lt;/li&gt;
&lt;li&gt;对开源数据库进行二次开发&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据库就像一棵常青的技能树&lt;/strong&gt;，不管是普通开发还是首席架构、CTO 都能够从中汲取足够的技术养料。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通开发&lt;/strong&gt;往往积累单点技术、比如 CRUD、锁类型、索引的数据结构…而对于&lt;strong&gt;技术骨干、架构师&lt;/strong&gt;则往往需要对底层原理吃透，数据库事务 ACID 是如何实现的？何时命中索引、何时不能，为什么？分布式场景下数据库怎么优化才能保持高性能？&lt;/p&gt;
&lt;p&gt;说白了，知道怎么用是一方面，知道为什么则是更为&lt;strong&gt;稀缺的能力&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很多技术专家在总结程序员核心能力的时候都会提到至关重要的一点：&lt;strong&gt;精通数据库。精通意味着：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一形成知识网，更灵活地应对突发问题；&lt;/p&gt;
&lt;p&gt;第二底层原理要懂，懂了才能更自由地应对复杂多变的业务场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;四-本套课程适合人群&#34;&gt;四、本套课程适合人群&lt;/h2&gt;
&lt;p&gt;1、MySQL数据库初学者。建议按照顺序从套课程的“基础篇”开始学习。&lt;/p&gt;
&lt;p&gt;2、从事后台开发(Java、Python、GO、PHP等)、MySQL开发 1~3 年的开发人员和运维人员。建议选择“基础篇”部分内容学习，或者跳过“基础篇”，直接从“高级特性篇”开始学习。&lt;/p&gt;
&lt;p&gt;3、有资历的MySQL DBA。本课程可以作为“案头书”。在解决问题时，如果记不清某些概念或者细节比较模糊，则可以拿来参考。&lt;/p&gt;
&lt;h2 id=&#34;五-希望你能获取的&#34;&gt;五、希望你能获取的&lt;/h2&gt;
&lt;p&gt;先说一个笑话。这个笑话是我从万维钢的专栏里看到的。&lt;/p&gt;
&lt;p&gt;三个逻辑学家走进酒吧，酒保问他们，三位都喝啤酒吗？&lt;br&gt;
第一个逻辑学家说，我不知道。&lt;br&gt;
第二个逻辑学家说，我不知道。&lt;br&gt;
第三个逻辑学家说，是的。&lt;/p&gt;
&lt;p&gt;对于知识，是需要&lt;code&gt;认真&lt;/code&gt;和&lt;code&gt;讲究逻辑&lt;/code&gt;的。希望这份认真、严谨你在课程的每个细节都能体会到。希望通过这套课程的系统性训练，你也能感受到这种思维方式的美，最终也能获得这种思维方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;具备优秀的思维能力&lt;/code&gt;才是在未来可以迁移的能力，如果只是学习一些命令，则很快会过时，&lt;code&gt;思维能力&lt;/code&gt;和&lt;code&gt;学习能力&lt;/code&gt;的提升才是不会变的东西。&lt;/p&gt;
">MySQL笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/mac-zhong-xiu-gai-chong-zhi-mysql-mi-ma/"" data-c="
          &lt;h2 id=&#34;mysql版本&#34;&gt;MySQL版本&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;8.0.22&lt;/mark&gt;&lt;/p&gt;
&lt;h2 id=&#34;第一步&#34;&gt;第一步&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;系统偏好设置&lt;/code&gt;中打开MySQL面板将其关闭&lt;/p&gt;
&lt;h2 id=&#34;第二步&#34;&gt;第二步&lt;/h2&gt;
&lt;p&gt;打开&lt;code&gt;终端&lt;/code&gt;输入如下命令进入MySQL目录&lt;br&gt;
&lt;code&gt;cd /usr/local/mysql/bin/&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;第三步&#34;&gt;第三步&lt;/h2&gt;
&lt;p&gt;继续输入如下命令获得系统管理员权限&lt;br&gt;
&lt;code&gt;sudo su&lt;/code&gt;&lt;br&gt;
&lt;mark&gt;回车后输入锁屏密码以继续&lt;/mark&gt;&lt;/p&gt;
&lt;h2 id=&#34;第四步&#34;&gt;第四步&lt;/h2&gt;
&lt;p&gt;输入以下命令来禁止MySQL验证功能&lt;br&gt;
&lt;code&gt;./mysqld_safe --skip-grant-tables &amp;amp;&lt;/code&gt;&lt;br&gt;
回车后MySQL会自动重启（系统偏好设置中MySQL的状态会变成运行中且不能够手动关闭）&lt;/p&gt;
&lt;h2 id=&#34;第五步&#34;&gt;第五步&lt;/h2&gt;
&lt;p&gt;依次输入如下两个命令&lt;br&gt;
&lt;code&gt;./mysql&lt;/code&gt;&lt;br&gt;
回车后&lt;br&gt;
&lt;code&gt;FLUSH PRIVILEGES;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;第六步&#34;&gt;第六步&lt;/h2&gt;
&lt;p&gt;输入如下命令设置新密码&lt;br&gt;
&lt;code&gt;ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;新的密码&#39;;&lt;/code&gt;&lt;br&gt;
&lt;mark&gt;网上这一步有很多其他命令，但是都会报错，个人猜测可能是版本原因，比如可能是MySQL5才适用？没有具体研究&lt;/mark&gt;&lt;/p&gt;
&lt;h2 id=&#34;第七步&#34;&gt;第七步&lt;/h2&gt;
&lt;p&gt;新建终端窗口执行如下命令重启MySQL&lt;br&gt;
&lt;code&gt;sudo /usr/local/mysql/support-files/mysql.server restart&lt;/code&gt;&lt;br&gt;
此命令含sudo自然也需要输入锁屏密码以继续&lt;/p&gt;
&lt;p&gt;补充其他命令：&lt;br&gt;
启动MySQL服务&lt;br&gt;
&lt;code&gt;sudo /usr/local/MySQL/support-files/mysql.server start&lt;/code&gt;&lt;br&gt;
停止MySQL服务&lt;br&gt;
&lt;code&gt;sudo /usr/local/mysql/support-files/mysql.server restart&lt;/code&gt;&lt;/p&gt;
">Mac中修改/重置MySQL密码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/javase-bi-ji/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;视频课程地址：&lt;a href=&#34;https://www.bilibili.com/video/BV1Kb411W75N&#34;&gt;https://www.bilibili.com/video/BV1Kb411W75N&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;java-se基础编程&#34;&gt;Java SE基础编程&lt;/h1&gt;
&lt;h2 id=&#34;1_java语言概述&#34;&gt;1_Java语言概述&lt;/h2&gt;
&lt;h3 id=&#34;课程整体内容概述&#34;&gt;课程整体内容概述&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220514150336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;java语言概述&#34;&gt;Java语言概述&lt;/h3&gt;
&lt;h4 id=&#34;1-基础知识&#34;&gt;1. 基础知识&lt;/h4&gt;
&lt;p&gt;应用程序 = 算法 + 数据结构&lt;/p&gt;
&lt;h4 id=&#34;2计算机语言的发展迭代史&#34;&gt;2.计算机语言的发展迭代史&lt;/h4&gt;
&lt;p&gt;第一代：机器语言&lt;br&gt;
第二代：汇编语言&lt;br&gt;
第三代：高级语言&lt;br&gt;
  &amp;gt;面向过程：C,Pascal、Fortran&lt;br&gt;
  &amp;gt;面向对象：Java,JS,Python,Scala,...&lt;/p&gt;
&lt;h4 id=&#34;3java语言版本迭代概述&#34;&gt;3.Java语言版本迭代概述&lt;/h4&gt;
&lt;h4 id=&#34;4java语言应用的领域&#34;&gt;4.Java语言应用的领域：&lt;/h4&gt;
&lt;p&gt;  &amp;gt;Java Web开发：后台开发&lt;br&gt;
  &amp;gt;大数据开发：&lt;br&gt;
  &amp;gt;Android应用程序开发：客户端开发&lt;/p&gt;
&lt;h4 id=&#34;5java语言的特点&#34;&gt;5.Java语言的特点&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;面向对象性：&lt;br&gt;
  两个要素：类、对象&lt;br&gt;
  三个特征：封装、继承、多态&lt;br&gt;
健壮性：① 去除了C语言中的指针 ②自动的垃圾回收机制 --&amp;gt;仍然会出现内存溢出、内存泄漏&lt;br&gt;
跨平台型：write once,run anywhere:一次编译，到处运行&lt;br&gt;
  功劳归功于：JVM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220514145944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2_基本语法&#34;&gt;2_基本语法&lt;/h2&gt;
&lt;h2 id=&#34;3_数组&#34;&gt;3_数组&lt;/h2&gt;
&lt;h2 id=&#34;4_面向对象-上&#34;&gt;4_面向对象-上&lt;/h2&gt;
&lt;h2 id=&#34;5_面向对象-中&#34;&gt;5_面向对象-中&lt;/h2&gt;
&lt;h2 id=&#34;6_面向对象-下&#34;&gt;6_面向对象-下&lt;/h2&gt;
&lt;h1 id=&#34;java-se高级编程&#34;&gt;Java SE高级编程&lt;/h1&gt;
&lt;h2 id=&#34;8_多线程&#34;&gt;8_多线程&lt;/h2&gt;
&lt;h2 id=&#34;9_java常用类&#34;&gt;9_Java常用类&lt;/h2&gt;
&lt;h2 id=&#34;10_枚举类和注解&#34;&gt;10_枚举类和注解&lt;/h2&gt;
&lt;h2 id=&#34;11_java集合&#34;&gt;11_Java集合&lt;/h2&gt;
&lt;h2 id=&#34;12_范型&#34;&gt;12_范型&lt;/h2&gt;
&lt;h2 id=&#34;13_io流&#34;&gt;13_IO流&lt;/h2&gt;
&lt;h2 id=&#34;14_网络编程&#34;&gt;14_网络编程&lt;/h2&gt;
&lt;h2 id=&#34;15_java反射机制&#34;&gt;15_Java反射机制&lt;/h2&gt;
&lt;h2 id=&#34;16_java8的其它新特性&#34;&gt;16_Java8的其它新特性&lt;/h2&gt;
&lt;h2 id=&#34;17_java91011新特性&#34;&gt;17_Java9&amp;amp;10&amp;amp;11新特性&lt;/h2&gt;
&lt;h1 id=&#34;ide的使用&#34;&gt;IDE的使用&lt;/h1&gt;
&lt;h1 id=&#34;项目&#34;&gt;项目&lt;/h1&gt;
">JavaSE笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/idea-chang-yong-ming-ling/"" data-c="
          &lt;p&gt;快速生成变量名：&lt;code&gt;Command + Option + V&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;快速把代码“包”起来：&lt;code&gt;Command + Option + T&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看类的继承结构与关系图: &lt;code&gt;Command + Option + U&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;转换大小写：&lt;code&gt;Shift + Option + U&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在当前类中查找方法： &lt;code&gt;Command + F12&lt;/code&gt;&lt;br&gt;
查看当前类的结构 ：&lt;code&gt;Command + 7&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;显示构造器/方法的参数信息：&lt;code&gt;Command + P&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;快速移动代码： &lt;code&gt;Command + Shift + ↑/↓&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;直接跳到下一行：&lt;code&gt;Shift + Enter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;直接跳到上一行：&lt;code&gt;Command + Option + Enter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;快速移动光标到行首/行尾： &lt;code&gt;Command + ←/→&lt;/code&gt;&lt;/p&gt;
">IDEA常用命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/java-ji-chu-suan-fa-xue-xi/"" data-c="
          &lt;h2 id=&#34;杨辉三角&#34;&gt;杨辉三角&lt;/h2&gt;
">Java基础算法学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/spring-xue-xi/"" data-c="
          &lt;h1 id=&#34;spring框架&#34;&gt;Spring框架&lt;/h1&gt;
&lt;p&gt;Spring框架是一个开源的JavaEE的应用程序&lt;/p&gt;
&lt;p&gt;主要核心是IOC（控制反转/依赖注入）和AOP（面向切面编程）两大技术。&lt;/p&gt;
&lt;p&gt;Spring IOC（控制反转/依赖注入）&lt;/p&gt;
&lt;p&gt;Spring AOP（面向切面编程）&lt;/p&gt;
&lt;p&gt;Spring JDBC+事务&lt;/p&gt;
&lt;h2 id=&#34;spring作用&#34;&gt;Spring作用&lt;/h2&gt;
&lt;p&gt;Dao层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JDBC操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应的框架：Mybatis&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Service层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring框架不是针对Service层的业务逻辑，所以Service目前没有适合的框架&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Controller层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Servlet（接收请求 响应数据 地址配置 页面转发）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应的框架：Spring MVC&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring是基于分布式的应用程序&lt;br&gt;
是基于轻量级的框架&lt;br&gt;
- 配置管理&lt;br&gt;
- Bean对象的实例化 - IOC&lt;/p&gt;
&lt;p&gt;集成第三方的框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Mybatis、Hibernate框架（持久层框架）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring MVC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring Security&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Quartz时钟框架（定时任务处理）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自带服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Mail邮件发送&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定时任务处理 - 定时调度 （定时短信、定时任务）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息处理（异步处理）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;spring模块划分&#34;&gt;Spring模块划分&lt;/h1&gt;
&lt;p&gt;Spring IOC模块：Bean对象的实例化（Bean的创建）&lt;/p&gt;
&lt;p&gt;Spring AOP模块：动态代理 面向切面编程&lt;/p&gt;
&lt;p&gt;Spring JDBC+事务模块&lt;/p&gt;
&lt;p&gt;Spring Web模块&lt;/p&gt;
">Spring学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/uni-app-shi-cao-da-quan/"" data-c="
          &lt;h2 id=&#34;登录时判定用户登录状态若已登录则跳过登录页&#34;&gt;登录时判定用户登录状态，若已登录则跳过登录页&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;核心思路：
1.在应用生命周期onLaunch判断用户登录信息是否存在
2.若存在用户登录信息，则跳转到首页，关闭应用启动页
    若不存在用户登录信息，则进入到登录页，关闭应用启动页
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现文件2-1&lt;code&gt;App.vue&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;onLaunch: function() {
			console.log(&#39;App Launch&#39;)
			// #ifdef APP-PLUS  
				var userIdStr = uni.getStorageSync(&#39;userIdStr&#39;);
				if(!userIdStr){
					//不存在用户信息
					//则关闭启动页，直接进到登录页
					console.log(&#39;不存在用户信息&#39;)
					plus.navigator.closeSplashscreen();
				}else{
					//存在用户信息
					//则转入主页，且页面跳转完成后再关闭启动页
					console.log(&#39;存在用户信息&#39;)
					uni.reLaunch({
						url:&#39;./pages/index/index&#39;,
						success:()=&amp;gt;{
							//页面跳转完成后再关闭启动页
							plus.navigator.closeSplashscreen();
						}
					})
				    
				}
				// #endif
		}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现文件2-2&lt;code&gt;manifest.json&lt;/code&gt;&lt;br&gt;
这里主要是将&lt;code&gt;splashscreen&lt;/code&gt;的&lt;code&gt;alwaysShowBeforeRender&lt;/code&gt;与 &lt;code&gt;autoclose&lt;/code&gt;设为&lt;mark&gt;false&lt;/mark&gt;，默认均为&lt;mark&gt;true&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;app-plus&amp;quot; : {
        &amp;quot;usingComponents&amp;quot; : true,
        &amp;quot;nvueStyleCompiler&amp;quot; : &amp;quot;uni-app&amp;quot;,
        &amp;quot;compilerVersion&amp;quot; : 3,
        &amp;quot;splashscreen&amp;quot; : {
            &amp;quot;alwaysShowBeforeRender&amp;quot; : false,
            &amp;quot;waiting&amp;quot; : true,
            &amp;quot;autoclose&amp;quot; : false,
            &amp;quot;delay&amp;quot; : 0
        },
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;拨打电话&#34;&gt;拨打电话&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//拨打电话
	call(phoneNum){
		uni.makePhoneCall({
		 	// 手机号 
             phoneNumber: phoneNum, 
			// 成功回调
			success: (res) =&amp;gt; {
			console.log(&#39;调用成功!&#39;)	
			},
			// 失败回调
			fail: (res) =&amp;gt; {
				console.log(&#39;调用失败!&#39;)
			}})
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;禁止页面滑动&#34;&gt;禁止页面滑动&lt;/h2&gt;
&lt;h3 id=&#34;局部配置&#34;&gt;局部配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;path&amp;quot;: &amp;quot;pages/user/login&amp;quot;,
&amp;quot;style&amp;quot;: {
		&amp;quot;app-plus&amp;quot;: {  
			  &amp;quot;titleNView&amp;quot;: false,
			  &amp;quot;bounce&amp;quot;: &amp;quot;none&amp;quot;//禁止滚动
		},
		&amp;quot;navigationBarTextStyle&amp;quot;: &amp;quot;white&amp;quot;	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;全局配置&#34;&gt;全局配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;globalStyle&amp;quot;: {
	&amp;quot;app-plus&amp;quot;: {
		&amp;quot;bounce&amp;quot;: &amp;quot;none&amp;quot;//禁止滚动
	 }
 },
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;uni-app发送request请求后端接受不到参数&#34;&gt;uni-app发送request请求后端接受不到参数&lt;/h2&gt;
&lt;p&gt;解决方法如下：&lt;br&gt;
在请求头header中添加：&lt;br&gt;
&lt;mark&gt;&#39;Content-type&#39;:&#39;application/x-www-form-urlencoded&#39;&lt;/mark&gt;&lt;br&gt;
或&lt;br&gt;
&lt;mark&gt;&#39;content-type&#39;: &#39;application/x-www-form-urlencoded;charset=utf-8&#39;&lt;/mark&gt;&lt;/p&gt;
">uni-app实操大全</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/mac-ke-qing-li-de-mu-lu/"" data-c="
          &lt;h2 id=&#34;xcode&#34;&gt;Xcode&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;DerivedData&lt;br&gt;
&lt;code&gt;~/Library/Developer/Xcode/DerivedData&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;项目 build 或 debug 的中间产物，有时候项目出问题的时候，重置这些文件会有帮助。&lt;br&gt;
如果删除，构建项目时会重建这些文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Archives&lt;br&gt;
&lt;code&gt;~/Library/Developer/Xcode/Archives&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;归档项目的存储位置&lt;br&gt;
&lt;mark&gt;警告：如果需要调试上架的应用，不能删！&lt;/mark&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;iOS DeviceSupport&lt;br&gt;
&lt;code&gt;~/Library/Developer/Xcode/iOS DeviceSupport&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;设备版本支持文件，连上设备时自动创建，通常旧版本没必要保留。我们每次连上新设备开始调试时显示『Processing symbol files』就是在向该文件夹写入文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;CoreSimulator/Devices&lt;br&gt;
&lt;code&gt;~/Library/Developer/CoreSimulator/Devices&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;该目录是模拟器用户数据的一部分，可以删除整个Devicesr目录。当下一次模拟器运行时，Xcode会重新创建新的实例。如果你可以承受丢失你的应用程序的任何以前的模拟器数据，这是获得空间的简单方法。&lt;br&gt;
5. XCPGDevices&lt;br&gt;
&lt;code&gt;~/Library/Developer/XCPGDevices/&lt;/code&gt;&lt;br&gt;
playground 的项目缓存 ，删除后可重新生成，可以全部删除。再次运行程序会缓存。&lt;/p&gt;
&lt;/blockquote&gt;
">Mac可清理的目录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/zai-uni-app-zhong-shi-yong-axios/"" data-c="
          &lt;h2 id=&#34;安装axios&#34;&gt;安装axios&lt;/h2&gt;
&lt;p&gt;首先在项目文件夹打开终端&lt;br&gt;
运行&lt;mark&gt;npm install axios&lt;/mark&gt;&lt;br&gt;
安装完成后在&lt;code&gt;node_modules&lt;/code&gt;文件夹下会有名为&lt;code&gt;axios&lt;/code&gt;和&lt;code&gt;follow-redirects&lt;/code&gt;的目录&lt;/p&gt;
&lt;h2 id=&#34;配置axios&#34;&gt;配置axios&lt;/h2&gt;
&lt;h3 id=&#34;封装axios&#34;&gt;封装axios&lt;/h3&gt;
&lt;p&gt;创建&lt;code&gt;utils/request/request.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import Vue from &#39;vue&#39;
import axios from &#39;axios&#39;

// create an axios instance
const service = axios.create({
	baseURL: &#39;http://localhost:9898&#39;, // url = base url + request url
	//withCredentials: true, // send cookies when cross-domain requests 注意：withCredentials和后端配置的cross跨域不可同时使用
	timeout: 1000, // request timeout
	crossDomain: true
})

// request拦截器,在请求之前做一些处理
service.interceptors.request.use(
    config =&amp;gt; {
        // if (store.state.token) {
        //     // 给请求头添加user-token
        //     config.headers[&amp;quot;user-token&amp;quot;] = store.state.token;
        // }
        console.log(&#39;请求拦截成功&#39;)
        return config;
    },
    error =&amp;gt; {
        console.log(error); // for debug
        return Promise.reject(error);
    }
); 

//配置成功后的拦截器
service.interceptors.response.use(res =&amp;gt; {
    if (res.data.status== 200) {
        return res.data
    } else {
        return Promise.reject(res.data.msg);
    }
}, error =&amp;gt; {
	if (error.response.status) {
		switch (error.response.status) {
			case 401:
				break;
			default:
				break;
		}
	}
    return Promise.reject(error)
})


// 在main.js中放入这段自定义适配器的代码，就可以实现uniapp的app和小程序开发中能使用axios进行跨域网络请求，并支持携带cookie
axios.defaults.adapter = function(config) { 
    return new Promise((resolve, reject) =&amp;gt; {
        console.log(config)
        var settle = require(&#39;axios/lib/core/settle&#39;);
        var buildURL = require(&#39;axios/lib/helpers/buildURL&#39;);
        uni.request({
            method: config.method.toUpperCase(),
            url: config.baseURL + buildURL(config.url, config.params, config.paramsSerializer),
            header: config.headers,
            data: config.data,
            dataType: config.dataType,
            responseType: config.responseType,
            sslVerify: config.sslVerify,
            complete: function complete(response) {
                console.log(&amp;quot;执行完成：&amp;quot;,response)
                response = {
                    data: response.data,
                    status: response.statusCode,
                    errMsg: response.errMsg,
                    header: response.header,
                    config: config
                };

                settle(resolve, reject, response);
            }
        })
    })
}

export default service
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;注意配置其中的 &lt;code&gt;baseURL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其中有些参数要根据实际项目参数名设置&lt;/li&gt;
&lt;li&gt;含跨域网络请求问题解决方案&lt;/li&gt;
&lt;li&gt;withCredentials允许获取cookie 和后端配置的跨域不可同时使用，会报错&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;配置全局axios&#34;&gt;配置全局axios&lt;/h3&gt;
&lt;p&gt;在项目根目录的&lt;code&gt;main.js&lt;/code&gt;中头部配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 引入封装后的axios
import axios from &#39;./utils/request/request.js&#39;
/**
 * 给Vue函数添加一个原型属性$axios 指向Axios
 * 这样做的好处是在vue实例或组件中不用再去重复引用Axios 直接用this.$axios就能执行axios 方法了
 * 在.vue中使用，this.$axios.get
 * @param {Object} config
 */
Vue.prototype.$axios = axios
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用axios&#34;&gt;使用axios&lt;/h2&gt;
&lt;p&gt;在配置了全局的axios后就可以在项目的任意位置使用axios&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;login() {
				var that = this;
				if (!that.username) {
					uni.showToast({
						title: &#39;请输入您的用户名&#39;,
						icon: &#39;none&#39;
					});
					return;
				}
				// if (!/^[1][3,4,5,7,8,9][0-9]{9}$/.test(that.username)) {
				// 	uni.showToast({ title: &#39;请输入正确手机号&#39;, icon: &#39;none&#39; });
				// 	return;
				// }
				if (!that.password) {
					uni.showToast({
						title: &#39;请输入您的密码&#39;,
						icon: &#39;none&#39;
					});
					return;
				}
				this.$axios({
					method:&#39;POST&#39;,
					url:&#39;/crm/user/login&#39;,
					params:{
						&#39;userName&#39;:that.username,
						&#39;userPwd&#39;:that.password
					}
				}).then(res=&amp;gt;{
					//登录成功
					uni.setStorageSync(&#39;trueName&#39;, res.result.trueName);
					uni.setStorageSync(&#39;userIdStr&#39;, res.result.userIdStr);
					uni.setStorageSync(&#39;userName&#39;, res.result.userName);
					//关闭当前页面并转到主页面
					uni.redirectTo({
					    url: &#39;../index/index&#39;
					});
					console.log(res.result)
				}).catch(err=&amp;gt;{
					console.log(err);
					if(err.msg == &#39;用户密码不正确&#39;){
						uni.showToast({
							title: &#39;用户密码不正确&#39;,
							icon: &#39;none&#39;
						});
					}else if(err.msg == &#39;用户名不存在&#39;){
						uni.showToast({
							title: &#39;用户名不存在&#39;,
							icon: &#39;none&#39;
						});
					}else{
						uni.showToast({
							title: &#39;系统异常，请重试&#39;,
							icon: &#39;none&#39;
						});
					}
				})
			}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://blog.csdn.net/mrs_chens/article/details/108417977&#34;&gt;https://blog.csdn.net/mrs_chens/article/details/108417977&lt;/a&gt;&lt;/p&gt;
">在uni-app中使用axios</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/xiang-mu-shi-jian-zhi-crm-xi-tong/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;圈内存在这么一句话：“世上本来没有CRM，大家的生意越来越难做了，才有了CRM。&amp;quot;在同质化竞争时代，顾客资产尤为重要，新时代在呼唤 CRM。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;crm-系统概念&#34;&gt;CRM 系统概念&lt;/h1&gt;
&lt;h2 id=&#34;crm-基本概念&#34;&gt;CRM 基本概念&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210907072024.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;CRM系统即客户关系管理系统，顾名思义就是管理公司与客户之间的关系。是一种以&amp;quot;客户关系一对一理论&amp;quot;为 基础，旨在改善企业与客户之间关系的新型管理机制。客户关系管理的定义是：企业为提高核心竞争力，利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互, 从而提升其管理方式，向客户提供创新式的个性化的客户交互和服务的过程。其最终目标是吸引新客户、保留老客户以及将已有客户转为忠实客户，增加公司市场份额。&lt;/p&gt;
&lt;p&gt;CRM的实施目标就是通过全面提升企业业务流程的管理来降低企业成本, 通过提供更快速和周到的优质服务来吸引和保持更多的客户。作为一种新型管理机制, CRM 极大地改善了企业与客户之间的关系，应用于企业的市场营销、销售、服务与技术支持等与客户相关的领域。&lt;/p&gt;
&lt;h2 id=&#34;crm-分类&#34;&gt;CRM 分类&lt;/h2&gt;
&lt;p&gt;根据客户的类型不同, CRM 可以分为 B to B CRM 及 B to C CRM 。B to B CRM 中管理的客户是企业客户，而 B to C CRM 管理的客户则是个人客户。提供企业产品销售和服务的企业需要的 B to B 的 CRM, 也就是市面上大部分 CRM 的内容。而提供个人及家庭消费的企业需要的是 B to C 的 CRM。&lt;/p&gt;
&lt;p&gt;根据 CRM 管理侧重点不同又分为操作性和分析型 CRM 。 大部分 CRM 为操作型 CRM, 支持 CRM 的日常作业流程的每个环节, 而分析型 CRM 则偏重于数据分析。&lt;/p&gt;
&lt;h1 id=&#34;crm-系统模块划分&#34;&gt;CRM 系统模块划分&lt;/h1&gt;
&lt;h2 id=&#34;crm系统模块图&#34;&gt;CRM系统模块图&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210906113313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;模块功能描述&#34;&gt;模块功能描述&lt;/h2&gt;
&lt;h3 id=&#34;基础模块&#34;&gt;基础模块&lt;/h3&gt;
&lt;p&gt;包含系统基本的用户登录，退出，记住我，密码修改等基本操作。&lt;/p&gt;
&lt;h3 id=&#34;营销管理&#34;&gt;营销管理&lt;/h3&gt;
&lt;p&gt;营销机会管理:企业客户的质询需求所建立的信息录入功能，方便销售人员进行后续的客户需求跟踪。&lt;/p&gt;
&lt;p&gt;营销开发计划：开发计划是根据营销机会而来，对于企业质询的客户，会有相应的销售人员对于该客户进行具体的沟通交流，此时对于整个CRM 系统而言，通过营销开发计划来进行相应的信息管理，提高客户的购买企业产品的可能性。&lt;/p&gt;
&lt;h3 id=&#34;客户管理&#34;&gt;客户管理&lt;/h3&gt;
&lt;p&gt;客户信息管理：CRM 系统中完整记录客户信息来源的数据、企业与客户交往、客户订单查询等信息录入功能，方便企业与客户进行相应的信息交流与后续合作。&lt;/p&gt;
&lt;p&gt;客户流失管理：CRM 通过一定规则机制所定义的流失客户（无效客户），通过该规则可以有效管理客户信息资源，提高营销开发效率。&lt;/p&gt;
&lt;h3 id=&#34;服务管理&#34;&gt;服务管理&lt;/h3&gt;
&lt;p&gt;服务管理是针对客户而开发的功能，针对客户要求，CRM 提供客户相应的信息质询，反馈与投诉功能，提高企业对于客户的服务质量。&lt;/p&gt;
&lt;h3 id=&#34;数据报表&#34;&gt;数据报表&lt;/h3&gt;
&lt;p&gt;CRM 提供的数据报表功能能够帮助企业了解客户整体分布，了解客户开发结果整体信息，从而帮助企业整体调整客户开发计划，提高企业的在市场中的竞争力度。&lt;/p&gt;
&lt;h3 id=&#34;系统管理&#34;&gt;系统管理&lt;/h3&gt;
&lt;p&gt;系统管理包含常量字典维护工作,以及权限管理模块，CRM 权限管理是基于角色的一种权限控制，基于RBAC实现基于角色的权限控制,通过不同角色的用户登录该系统后展示系统不同的操作功能，从而达到对不同角色完成不同操作功能。&lt;/p&gt;
&lt;h1 id=&#34;crm-系统数据库设计&#34;&gt;CRM 系统数据库设计&lt;/h1&gt;
&lt;p&gt;CRM系统根据产品的原型搞以及UI组的设计稿, 接下来就要设计数据库, 一般在大公司通常会有专门的DBA, 这时我们可以不要考虑数据库表设计, 但是也要能够读懂或者了解DBA的设计思路方便在程序开发阶段不会出现问题, 一般关系型数据库表设计满足三范式的设计即可, 表名设计做到见名知意最好。&lt;/p&gt;
&lt;h2 id=&#34;e-r图表简介&#34;&gt;E-R图表简介&lt;/h2&gt;
&lt;h3 id=&#34;营销管理模块&#34;&gt;营销管理模块&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210907072727.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;客户管理模块&#34;&gt;客户管理模块&lt;/h3&gt;
&lt;h4 id=&#34;客户信息管理&#34;&gt;客户信息管理&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210907073010.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;客户流失管理&#34;&gt;客户流失管理&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210907073105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;服务管理-2&#34;&gt;服务管理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210907073148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;系统管理-2&#34;&gt;系统管理&lt;/h3&gt;
&lt;h4 id=&#34;权限模块-e-r-模型&#34;&gt;权限模块 E-R 模型&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210907073307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;字典日记管理&#34;&gt;字典&amp;amp;日记管理&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210907073413.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;表结构详情&#34;&gt;表结构详情&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;t_sale_chance&lt;/th&gt;
&lt;th&gt;营销机会表&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id主键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;chance_source&lt;/td&gt;
&lt;td&gt;varchar(300)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;机会来源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;customer_name&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;cgjl&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;成功几率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;overview&lt;/td&gt;
&lt;td&gt;varchar(300)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;概要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;link_man&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;联系人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;link_phone&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;手机号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;description&lt;/td&gt;
&lt;td&gt;varchar(1000)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_man&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;assign_man&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;分配人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;assign_time&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;分配时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;分配状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;dev_result&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;开发结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;int(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;有效状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_cus_dev_plan&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;客户开发计划表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;sale_chance_id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;营销机会id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;plan_item&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;计划内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;plan_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;计划日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;exe_affect&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;执行效果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;int(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;有效状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_customer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;客户信息表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id主键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;khno&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户编号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户姓名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;area&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户所属地区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;cus_manager&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户经理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;level&lt;/td&gt;
&lt;td&gt;varchar(30)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户级别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;myd&lt;/td&gt;
&lt;td&gt;varchar(30)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户满意度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;xyd&lt;/td&gt;
&lt;td&gt;varchar(30)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户信用度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;address&lt;/td&gt;
&lt;td&gt;varchar(500)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;post_code&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;邮编&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;phone&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;联系电话&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;fax&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;传真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;web_site&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;网址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;yyzzzch&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;营业执照注册号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;fr&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;法人代表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;zczj&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;注册资金&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;nyye&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;年营业额&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;khyh&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;开户银行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;khzh&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;开户账号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;dsdjh&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;地税登记号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;gsdjh&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;国税登记号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;流失状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;int(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;有效状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_customer_contact&lt;/td&gt;
&lt;td&gt;客户交往记录表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id主键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;cus_id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;contact_time&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;交往时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;address&lt;/td&gt;
&lt;td&gt;varchar(500)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;交往地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;overview&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;概要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;int(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;有效状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_customer_linkman&lt;/td&gt;
&lt;td&gt;客户联系人表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id主键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;cus_id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;link_name&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;联系人姓名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;sex&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;性别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;zhiwei&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;职位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;office_phone&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;办公电话&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;phone&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;手机号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;int(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;有效状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ceate_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_customer_loss&lt;/td&gt;
&lt;td&gt;客户流失表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id主键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;cus_no&lt;/td&gt;
&lt;td&gt;varchar(40)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户编号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;cus_name&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户姓名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;cus_manager&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户经理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;last_order_time&lt;/td&gt;
&lt;td&gt;date&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;最后下单时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;confirm_loss_time&lt;/td&gt;
&lt;td&gt;date&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;确认流失时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;流失状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;loss_reason&lt;/td&gt;
&lt;td&gt;varchar(1000)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;流失原因&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;tinyint(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;有效状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_customer_order&lt;/td&gt;
&lt;td&gt;客户订单&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id主键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;cus_id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;order_no&lt;/td&gt;
&lt;td&gt;varchar(40)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;订单编号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;order_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;下单时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;address&lt;/td&gt;
&lt;td&gt;varchar(200)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;int(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;有效状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_order_details&lt;/td&gt;
&lt;td&gt;订单详情表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id主键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;order_id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;订单id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;goods_name&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;商品名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;goods_num&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;商品数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;unit&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;商品单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;price&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;单价&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;sum&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;总金额&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;int(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;有效状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_customer_reprieve&lt;/td&gt;
&lt;td&gt;客户流失暂缓表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id主键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;loss_id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;流失id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;measure&lt;/td&gt;
&lt;td&gt;varchar(500)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;措施&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;tinyint(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;有效状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_customer_serve&lt;/td&gt;
&lt;td&gt;客户服务&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id主键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;serve_type&lt;/td&gt;
&lt;td&gt;varchar(30)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;服务类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;overview&lt;/td&gt;
&lt;td&gt;varchar(500)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;概要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;customer&lt;/td&gt;
&lt;td&gt;varchar(30)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;客户&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;服务状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;service_request&lt;/td&gt;
&lt;td&gt;varchar(500)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;服务请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_people&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;服务创建人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;assigner&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;服务分配人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;assign_time&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;分配时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;service_proce&lt;/td&gt;
&lt;td&gt;varchar(500)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;服务处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;service_proce_people&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;服务处理人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;service_proce_time&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;服务处理时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;service_proce_result&lt;/td&gt;
&lt;td&gt;varchar(500)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;处理结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;myd&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;满意度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;int(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;是否有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_datadic&lt;/td&gt;
&lt;td&gt;字典表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;id主键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;data_dic_name&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;字典名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;data_dic_value&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;字典值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;tinyint(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;是否有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_user&lt;/td&gt;
&lt;td&gt;用户表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;user_name&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;user_pwd&lt;/td&gt;
&lt;td&gt;varchar(100)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;用户密码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;true_name&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;真实姓名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;email&lt;/td&gt;
&lt;td&gt;varchar(30)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;邮箱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;phone&lt;/td&gt;
&lt;td&gt;varchar(20)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;电话&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;int(4)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;有效状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t_role&lt;/td&gt;
&lt;td&gt;角色表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;字段类型&lt;/td&gt;
&lt;td&gt;字段限制&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;自增&lt;/td&gt;
&lt;td&gt;字段描述&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;role_name&lt;/td&gt;
&lt;td&gt;varchar(255)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;角色名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;role_remarker&lt;/td&gt;
&lt;td&gt;varchar(255)&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;角色备注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;create_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;可空&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update_date&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;is_valid&lt;/td&gt;
&lt;td&gt;int(11)&lt;/td&gt;
&lt;td&gt;非空&lt;/td&gt;
&lt;td&gt;是否有效&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;项目环境搭建与测试&#34;&gt;项目环境搭建与测试&lt;/h1&gt;
&lt;h2 id=&#34;项目技术栈&#34;&gt;项目技术栈&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210906221307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;环境搭建与测试&#34;&gt;环境搭建与测试&lt;/h2&gt;
&lt;h3 id=&#34;在-idea-中新建-springboot-项目-crm&#34;&gt;在 IDEA 中新建 SpringBoot 项目 - CRM&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210906221844.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;在pomxml引入坐标插件&#34;&gt;在pom.xml引入坐标&amp;amp;插件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;properties&amp;gt;

​    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;

​    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;

​    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;

&amp;lt;/properties&amp;gt;



&amp;lt;parent&amp;gt;

​    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;

​    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;

​    &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt;

  &amp;lt;/parent&amp;gt;


  &amp;lt;dependencies&amp;gt;


​    &amp;lt;dependency&amp;gt;

​      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;

​      &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;

​    &amp;lt;/dependency&amp;gt;

​    &amp;lt;dependency&amp;gt;

​      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;

​      &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;

​    &amp;lt;/dependency&amp;gt;

​    &amp;lt;dependency&amp;gt;

​      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;

​      &amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt;

​    &amp;lt;/dependency&amp;gt;

​      &amp;lt;dependency&amp;gt;

​          &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;

​          &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;

​          &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;

​      &amp;lt;/dependency&amp;gt;



​    &amp;lt;!--

​      mybatis 集成

​    --&amp;gt;

​    &amp;lt;dependency&amp;gt;

​      &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;

​      &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;

​      &amp;lt;version&amp;gt;2.1.1&amp;lt;/version&amp;gt;

​    &amp;lt;/dependency&amp;gt;

​    &amp;lt;!-- 分页插件 --&amp;gt;

​    &amp;lt;dependency&amp;gt;

​      &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;

​      &amp;lt;artifactId&amp;gt;pagehelper-spring-boot-starter&amp;lt;/artifactId&amp;gt;

​      &amp;lt;version&amp;gt;1.2.13&amp;lt;/version&amp;gt;

​    &amp;lt;/dependency&amp;gt;



​    &amp;lt;!--mysql 驱动--&amp;gt;

​    &amp;lt;dependency&amp;gt;

​      &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;

​      &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;

​      &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;

​    &amp;lt;/dependency&amp;gt;


    
​    &amp;lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&amp;gt;

​    &amp;lt;dependency&amp;gt;

​      &amp;lt;groupId&amp;gt;com.mchange&amp;lt;/groupId&amp;gt;

​      &amp;lt;artifactId&amp;gt;c3p0&amp;lt;/artifactId&amp;gt;

​      &amp;lt;version&amp;gt;0.9.5.5&amp;lt;/version&amp;gt;

​    &amp;lt;/dependency&amp;gt;

​    &amp;lt;dependency&amp;gt;

​      &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;

​      &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;

​      &amp;lt;version&amp;gt;3.5&amp;lt;/version&amp;gt;

​    &amp;lt;/dependency&amp;gt;

​    &amp;lt;dependency&amp;gt;

​      &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;

​      &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;

​      &amp;lt;version&amp;gt;1.2.47&amp;lt;/version&amp;gt;

​    &amp;lt;/dependency&amp;gt;



    
​    &amp;lt;!-- DevTools 的坐标 热部署 --&amp;gt;

​    &amp;lt;dependency&amp;gt;

​      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;

​      &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;

​      &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;

​    &amp;lt;/dependency&amp;gt;

  &amp;lt;/dependencies&amp;gt;



  &amp;lt;build&amp;gt;

​    &amp;lt;plugins&amp;gt;

​      &amp;lt;plugin&amp;gt;

​        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;

​        &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;

​        &amp;lt;version&amp;gt;2.3.2&amp;lt;/version&amp;gt;

​        &amp;lt;configuration&amp;gt;

​          &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;

​          &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;

​          &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;

​        &amp;lt;/configuration&amp;gt;

​      &amp;lt;/plugin&amp;gt;

​        &amp;lt;plugin&amp;gt;

​            &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;

​            &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;

​            &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;

​            &amp;lt;configuration&amp;gt;

​            &amp;lt;configurationFile&amp;gt;src/main/resources/generatorConfig.xml&amp;lt;/configurationFile&amp;gt;

​                &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;

​                &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;

​            &amp;lt;/configuration&amp;gt;

​        &amp;lt;/plugin&amp;gt;  

​      &amp;lt;plugin&amp;gt;

​        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;

​        &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;

​        &amp;lt;configuration&amp;gt;

​          &amp;lt;!-- 如果没有该配置，热部署的devtools不生效 --&amp;gt;

​          &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt;

​        &amp;lt;/configuration&amp;gt;

​      &amp;lt;/plugin&amp;gt;

​    &amp;lt;/plugins&amp;gt;

  &amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加配置文件applicationyml&#34;&gt;添加配置文件application.yml&lt;/h3&gt;
&lt;p&gt;src/main/resources 目录下新建application.yml配置文件,内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;\## 端口号  上下文路径

server:

  port: 9898

  servlet:

​    context-path: /crm



\## 数据源配置

spring:

  datasource:

​    type: com.mchange.v2.c3p0.ComboPooledDataSource

​    driver-class-name: com.mysql.cj.jdbc.Driver

​    url: jdbc:mysql://127.0.0.1:3306/crm?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=GMT%2B8

​    username: root

​    password: root



  \## freemarker

  freemarker:

​    suffix: .ftl

​    content-type: text/html

​    charset: UTF-8

​    template-loader-path: classpath:/views/



  \## 启用热部署

  devtools:

​    restart:

​      enabled: true

​      additional-paths: src/main/java



\## mybatis 配置

mybatis:

  mapper-locations: classpath:/mappers/*.xml

  type-aliases-package: com.xxxx.crm.vo;com.xxxx.crm.query;com.xxxx.crm.dto

  configuration:

​    map-underscore-to-camel-case: true



\## pageHelper 分页

pagehelper:

  helper-dialect: mysql

  

\## 设置 dao 日志打印级别

logging:

  level:

​    com:

​      xxxx:

​        crm:

​          dao: debug
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加视图转发源代码&#34;&gt;添加视图转发源代码&lt;/h3&gt;
&lt;p&gt;新建com.xxxx.crm.controller包,添加系统登录,主页面转发代码(这里继承BaseController，具体文件见相关目录)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.xxxx.crm.controller;

import com.xxxx.crm.base.BaseController;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class IndexController extends BaseController {

    /**
     * 系统登录页
     * @return
     */
    @RequestMapping(&amp;quot;index&amp;quot;)
    public String index(){
        return &amp;quot;index&amp;quot;;
    }

    
    // 系统界面欢迎页
    @RequestMapping(&amp;quot;welcome&amp;quot;)
    public String welcome(){
        return &amp;quot;welcome&amp;quot;;
    }

    /**
     * 后端管理主页面
     * @return
     */
    @RequestMapping(&amp;quot;main&amp;quot;)
    public String main(){
        return &amp;quot;main&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;静态资源文件目录添加&#34;&gt;静态资源文件目录添加&lt;/h3&gt;
&lt;p&gt;在src/main/resources目录下新建public 目录存放系统相关静态资源文件,copy静态文件内容到public 目录。&lt;/p&gt;
&lt;h3 id=&#34;添加系统登录主页面视图模板页&#34;&gt;添加系统登录,主页面视图模板页&lt;/h3&gt;
&lt;p&gt;在src/main/resources 目录下新建views目录,添加index.ftl,main.ftl 等文件(具体视图文件详见相关目录)&lt;/p&gt;
&lt;h3 id=&#34;添加springboot应用启动类starter&#34;&gt;添加SpringBoot应用启动类Starter&lt;/h3&gt;
&lt;p&gt;在com.xxxx.crm 包下新建Starter.java ,添加启动项目相关代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.xxxx.crm;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Starter {

    public static void main(String[] args) {
        SpringApplication.run(Starter.class);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;项目目录结构&#34;&gt;项目目录结构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210908092348.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;浏览器访问登录页-主页面&#34;&gt;浏览器访问登录页、主页面&lt;/h3&gt;
&lt;p&gt;Chrome浏览器访问登录页地址:http://localhost:9898/crm/index&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210908092733.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Chrome浏览器访问登录页地址:http://localhost:9898/crm/main&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20210908092830.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;用户登录功能实现&#34;&gt;用户登录功能实现&lt;/h1&gt;
&lt;h2 id=&#34;用户登录功能核心思路&#34;&gt;用户登录功能核心思路&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# 用户登录
## 后端实现
### 整体思路：
1. 参数判断 
   - 用户姓名 非空判断
   - 用户密码 非空判断
2. 通过用户名查询用户记录，返回用户对象
3. 判断用户对象是否为空
4. 如果用户对象不为空，则将前台传递的用户密码与数据库中的密码作比较
5. 判断密码是否正确
6. 如果密码正确，则登录成功，返回结果

**Controller层（控制层：接受请求，响应结果）**
1. 通过形参接收客户端传递的参数
2. 调用业务逻辑层的登录方法，得到登录结果
3. 响应数据给客户端

**Service层（业务逻辑层：非空判断、条件判断等业务逻辑处理）**
1. 参数判断，判断用户名、密码是否非空
   - 如果参数为空，抛出异常（异常被控制层捕获并处理）
2. 调用数据访问层，通过用户名查询用户记录，返回用户对象
3. 判断用户对象是否为空
   - 如果对象为空，抛出异常（异常被控制层捕获并处理）
   - 否则继续
4. 判断用户密码是否正确，比较客户端传递的用户密码与数据库中查询的用户对象中的密码
   - 如果密码不相等，抛出异常（异常被控制层捕获并处理）
   - 如果密码相等，登录成功，返回结果

**Dao层（数据访问层：数据库中增删改查操作）**

通过用户名查询用户记录，返回用户对象
&lt;/code&gt;&lt;/pre&gt;
">软件项目实践之CRM系统</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/git-chang-yong-ming-ling/"" data-c="
          &lt;h2 id=&#34;git文件库创建与文件提交&#34;&gt;Git文件库创建与文件提交&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;  初始git 本地仓库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git add 文件/目录&lt;/code&gt;  添加文件/目录到暂存区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git reset HEAD 文件/目录&lt;/code&gt; 撤销暂存区的文件/目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git status&lt;/code&gt; 查看工作区文件状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git commit -m &amp;quot;注释说明&amp;quot;&lt;/code&gt; 提交文件到git版本库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git ls-files&lt;/code&gt; 查看库文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;git-时光穿梭文件版本切换&#34;&gt;Git 时光穿梭（文件版本切换）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git log&lt;/code&gt; 查看提交历史&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log --pretty=oneline&lt;/code&gt; 以单行显示提交历史&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;回退版本&#34;&gt;回退版本&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git reset --head HEAD^&lt;/code&gt;回退上一版本，两个尖括号就是回退两个版本，以此类推&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git reset --haed 版本号(一般前四位即可，能够唯一区分即可)&lt;/code&gt; 回退到指定版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git reflog&lt;/code&gt; 查看所有操作历史，一般可用于误关闭窗口，不知道之前最新的版本号了，重新回到某文件未来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件删除&#34;&gt;文件删除&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;删除工作区文件，在工作区直接执行删除即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git checkout -- 文件名&lt;/code&gt;  工作区文件误删恢复，执行后从版本库中检出恢复&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git rm 文件名&lt;/code&gt;  从库中彻底删除文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件差异比较&#34;&gt;文件差异比较&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;git diff HEAD -- 文件名&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;git-远程仓库创建与本地git库文件推送&#34;&gt;Git 远程仓库创建与本地Git库文件推送&lt;/h2&gt;
&lt;p&gt;远程库：GitHub/Gitee&lt;/p&gt;
&lt;p&gt;下载远程项目 &lt;code&gt;git clone url&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;推送本地库到远程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地库文件准备 &lt;code&gt;(git init，git add xxx,git commit -m &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远程库GitHub&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建GitHub账号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建远程仓库xxx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成ssh密钥 &lt;code&gt;ssh -keygen -t rsa -C &amp;quot;Github账户邮箱&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传密钥 &lt;code&gt;GitHub网站Settings--&amp;gt;SSH and GPG keys--&amp;gt;New SSH key--&amp;gt;上传public key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;校验ssh密钥 &lt;code&gt;ssh -T git@github.com&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行推送（创建的新仓库页面会有执行提示）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绑定远程地址&lt;code&gt;git remote add origin git@github.com:用户名/仓库名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建分支 &lt;code&gt;git branch -M main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行推送 &lt;code&gt;git push -u origin main&lt;/code&gt;或&lt;code&gt;git push&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Git常用命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/zai-mac-an-zhuang-redis/"" data-c="
          &lt;h4 id=&#34;前期准备&#34;&gt;前期准备&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://redis.io/&#34;&gt;Redis官网&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/qishibo/AnotherRedisDesktopManager&#34;&gt;Redis图形管理工具&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;安装readis&#34;&gt;安装Readis&lt;/h3&gt;
&lt;p&gt;安装命令如下，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意在编译的时候可能出错，小错误可以不用管。如果影响到安装，可尝试先用命令清理了再编译一下：&lt;mark&gt;sudo make distclean &amp;amp;&amp;amp; sudo make &amp;amp;&amp;amp; sudo make test&lt;/mark&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 解压
tar -zxvf redis-6.0.6.tar.gz
# 拷贝的local目录下
sudo cp -rf redis-6.0.6 /usr/local/
# 进入相应目录下
cd /usr/local/redis-6.0.6
# 编译 - 时间有点长，可能要等几分钟
sudo make test
# 安装
sudo make install
# 建立相应目录
sudo mkdir bin etc db
# 拷贝启动文件
sudo cp src/mkreleasehdr.sh src/redis-benchmark src/redis-check-rdb src/redis-cli src/redis-server bin/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后执行服务启动命令&lt;mark&gt;redis-server&lt;/mark&gt;&lt;br&gt;
启动后，看到命令行出现 Redis 的图案即安装成功。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;默认配置&#34;&gt;默认配置&lt;/h3&gt;
&lt;p&gt;Readis默认配置&lt;code&gt;redis.conf&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli
127.0.0.1:6379&amp;gt; keys *
(empty list or set)
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; exit
&lt;/code&gt;&lt;/pre&gt;
">在Mac中安装Redis</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/jie-jue-mac-zhong-mysql-wu-fa-qi-dong-wu-fa-chuang-jian-shu-ju-ku/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;在Mac无法启动MySQL/创建数据库，一般是某种情况下导致&lt;code&gt;/usr/local/MySQL/data&lt;/code&gt;的文件权限发生了改变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;所以解决办法就是将其文件权限修改为“mysql“，在终端执行下列命令：&lt;br&gt;
&lt;mark&gt;sudo chown -R mysql /usr/local/mysql/data&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
">解决Mac中MySQL无法启动/无法创建数据库</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/guan-yu-vue-xiang-mu-de-yi-xie-keng/"" data-c="
          &lt;h2 id=&#34;环境配置&#34;&gt;环境配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安装环境或脚手架时使用&lt;code&gt;管理员身份&lt;/code&gt;，Mac切换命令为&lt;mark&gt;sudo su -&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;创建项目&#34;&gt;创建项目&lt;/h2&gt;
&lt;h4 id=&#34;创建vue-webpack项目&#34;&gt;创建Vue-webpack项目&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;进入相应的目录&lt;br&gt;
&lt;mark&gt;vue init webpack projectName&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;创建项目时&lt;code&gt;添加路由&lt;/code&gt;，&lt;code&gt;自动添加npm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建项目后首先要使用&lt;mark&gt;sudo chmod -R 777 项目文件夹&lt;/mark&gt;修改文件权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;创建vue项目&#34;&gt;创建Vue项目&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;进入相应的目录&lt;br&gt;
&lt;mark&gt;vue create projectName&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装新依赖前一定要&lt;code&gt;先备份&lt;/code&gt;项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装依赖尽量使用 &lt;code&gt;vue ui &lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装依赖报错&lt;code&gt;不要尝试修复&lt;/code&gt;，更不要强制修复，一般这只会导致项目彻底出错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;code&gt;vuex&lt;/code&gt;命令为&lt;mark&gt;npm install --save vuex;&lt;/mark&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;不要轻易尝试使用sass&lt;/code&gt;，安装依赖即易出错且不可修复，且最新版&lt;code&gt;Node Sass&lt;/code&gt;与&lt;code&gt;sass-loader&lt;/code&gt;往往不兼容，非要安装可尝试锁定版本，sass-loader的7.3.1和Node Sass的4.14.1这两个版本一起安装&lt;code&gt;可能&lt;/code&gt;不存在问题。&lt;br&gt;
⚠️&lt;code&gt;注意：未测试&lt;/code&gt;&lt;br&gt;
&lt;mark&gt;npm install sass-loader@7.3.1 --save-dev&lt;/mark&gt;&lt;br&gt;
&lt;mark&gt;npm install node-sass@4.14.1&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;或&lt;mark&gt;npm install sass-loader@7.3.1 node-sass@4.14.1 --save-de&lt;/mark&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;运行依赖&#34;&gt;运行依赖&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;element-ui&lt;/li&gt;
&lt;li&gt;axios&lt;/li&gt;
&lt;li&gt;vuex&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;开发依赖&#34;&gt;开发依赖&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;关于npm的一些常用命令&#34;&gt;关于npm的一些常用命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;清除缓存 &lt;mark&gt;npm cache clean --force&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;更新npm &lt;mark&gt;npm install -g npm&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;查看版本号(也用于测试是否安装成功) &lt;mark&gt;npm -v&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
">关于Vue项目的一些坑</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/zai-mac-zhong-an-zhuang-maven-bing-pei-zhi-hao-eclipse-he-idea/"" data-c="
          &lt;h2 id=&#34;下载maven&#34;&gt;下载Maven&lt;/h2&gt;
&lt;p&gt;Maven官方下载链接:&lt;a href=&#34;https://maven.apache.org/download.cgi&#34;&gt;https://maven.apache.org/download.cgi&lt;/a&gt;&lt;br&gt;
Mac需要下载&lt;code&gt;apache-maven-X.X.X-bin.tar.gz&lt;/code&gt;&lt;br&gt;
目前我这里下载的最新版是&lt;code&gt;3.6.3&lt;/code&gt;,接下来的演示都以&lt;code&gt;3.6.3&lt;/code&gt;为例&lt;/p&gt;
&lt;h2 id=&#34;安装maven&#34;&gt;安装Maven&lt;/h2&gt;
&lt;h3 id=&#34;1解压maven包&#34;&gt;1.解压Maven包&lt;/h3&gt;
&lt;p&gt;将下载好的包解压到某一目录,&lt;mark&gt;记住该目录路径&lt;/mark&gt;&lt;br&gt;
我这里放在了/Users/kuangyang/Maven/apache-maven-3.6.3&lt;/p&gt;
&lt;h3 id=&#34;2配置maven-classpath&#34;&gt;2.配置Maven classpath&lt;/h3&gt;
&lt;p&gt;打开&lt;code&gt;终端&lt;/code&gt;,输入如下命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; vi ~/.bash_profile 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加如下的 Maven 配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Maven
export M2_HOME=/Users/kuangyang/Maven/apache-maven-3.6.3
export PATH=$PATH:$M2_HOME/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后保存并退出vi编辑器:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按&lt;code&gt;Esc&lt;/code&gt;键&lt;/li&gt;
&lt;li&gt;键入类型&lt;code&gt;:wq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;Enter&lt;/code&gt;键&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行如下命令使配置的环境变量生效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source ~/.bash_profile 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试maven是否安装成功&#34;&gt;测试Maven是否安装成功&lt;/h2&gt;
&lt;p&gt;执行下面命令执行测试:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn -version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若弹出&#39;无法验证开发者&#39;报错&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/11.20.56.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
解决方法1: 开启&lt;code&gt;任何来源&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在终端中执行&lt;code&gt;sudo spctl --master-disable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入密码，再按回车键即可.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方法2: 前往 &lt;code&gt;系统偏好设置&lt;/code&gt; -&amp;gt; &lt;code&gt;安全与隐私&lt;/code&gt; -&amp;gt; &lt;code&gt;通用&lt;/code&gt;选项卡&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/11.33.08.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;仍然允许&lt;/code&gt;, 返回终端再次执行&lt;code&gt;mvn -version&lt;/code&gt;然后选择&lt;code&gt;打开&lt;/code&gt;即可.&lt;/p&gt;
&lt;p&gt;安装成功时,输出日记如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)
Maven home: /Users/kuangyang/Maven/apache-maven-3.6.3
Java version: 15.0.2, vendor: Oracle Corporation, runtime: /Library/Java/             JavaVirtualMachines/jdk-15.0.2.jdk/Contents/Home
Default locale: zh_CN_#Hans, platform encoding: UTF-8
OS name: &amp;quot;mac os x&amp;quot;, version: &amp;quot;10.16&amp;quot;, arch: &amp;quot;x86_64&amp;quot;, family: &amp;quot;mac&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;为maven新建一个本地repository&#34;&gt;为Maven新建一个本地Repository&lt;/h2&gt;
&lt;p&gt;为了方便项目的管理,我们自己建一个本地Repository&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建一个文件夹作为New Repository&lt;/li&gt;
&lt;li&gt;前往 &lt;code&gt;Maven解压目录&lt;/code&gt; -&amp;gt; &lt;code&gt;conf&lt;/code&gt; -&amp;gt; &lt;code&gt;settings.xml&lt;/code&gt;&lt;br&gt;
在settings.xml文件的&lt;code&gt;&amp;lt;settings&amp;gt;&lt;/code&gt;后面加入&lt;pre&gt;&lt;code&gt;&amp;lt;localRepository&amp;gt;/刚刚创建文件夹的路径&amp;lt;/localRepository&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;eclipse配置maven环境&#34;&gt;Eclipse配置Maven环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;打开&lt;code&gt;Eclipse&lt;/code&gt;-&amp;gt;&lt;code&gt;Preferences&lt;/code&gt; -&amp;gt; &lt;code&gt;maven&lt;/code&gt; -&amp;gt; &lt;code&gt;installation&lt;/code&gt; -&amp;gt;&lt;code&gt;Add&lt;/code&gt;-&amp;gt;&lt;code&gt;Directory&lt;/code&gt;-&amp;gt;&lt;code&gt;选择Maven的解压目录&lt;/code&gt;-&amp;gt;&lt;code&gt;Finish&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;勾选Maven3.6.3&lt;/code&gt;，然后点击&lt;code&gt;apply&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/4.50.37.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;进入&lt;code&gt;User Settings&lt;/code&gt;-&amp;gt;&lt;code&gt;Browse&lt;/code&gt;-&amp;gt;&lt;code&gt;conf&lt;/code&gt; -&amp;gt; &lt;code&gt;选中settings.xml&lt;/code&gt;-&amp;gt; &lt;code&gt;Open&lt;/code&gt;-&amp;gt; &lt;code&gt;Update Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Apply and Close&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/5.02.40.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在idea中配置maven环境&#34;&gt;在IDEA中配置Maven环境&lt;/h2&gt;
&lt;p&gt;打开&lt;code&gt;IDEA&lt;/code&gt;-&amp;gt;&lt;code&gt;Preferences&lt;/code&gt; -&amp;gt; &lt;code&gt;构建、执行、部署&lt;/code&gt; -&amp;gt; &lt;code&gt;构建工具&lt;/code&gt; -&amp;gt;&lt;code&gt;Maven&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Maven主路径&lt;/code&gt;选择为 &lt;code&gt;Maven解压目录&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;用户设置文件&lt;/code&gt;选择为 &lt;code&gt;Maven解压目录&lt;/code&gt; -&amp;gt; &lt;code&gt;conf&lt;/code&gt; -&amp;gt; &lt;code&gt;settings.xml&lt;/code&gt; (注意要将&lt;code&gt;覆盖&lt;/code&gt;选中才能更改路径)&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/1031.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来打开&lt;code&gt;Maven&lt;/code&gt;下的&lt;code&gt;运行程序&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;JRE&lt;/code&gt;改为自己安装的JDK版本&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/10.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到这里,就完成了IDEA的配置,接下来尝试在IDEA中新建一个Maven项目&lt;/p&gt;
&lt;h2 id=&#34;在idea中新建maven项目&#34;&gt;在IDEA中新建Maven项目&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;IDEA&lt;/code&gt;-&amp;gt;&lt;code&gt;新建项目&lt;/code&gt; -&amp;gt; 选择&lt;code&gt;Maven&lt;/code&gt; -&amp;gt; 选中&lt;code&gt;从原型创建&lt;/code&gt; -&amp;gt;&lt;code&gt;maven-archetype-webapp&lt;/code&gt;-&amp;gt;&lt;code&gt;下一步&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/11.26.17.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
接下来在此面板中，是一些信息的填写。其中值得关注的设置点是&lt;code&gt;名称&lt;/code&gt;以及&lt;code&gt;GroupId&lt;/code&gt;.&lt;br&gt;
GroupId就像是应用程序的身份证.&lt;br&gt;
填写完成后点击&lt;code&gt;下一步&lt;/code&gt;-&amp;gt; &lt;code&gt;完成&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/11.38.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/11.44.4.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
项目创建完成后运行目录 &lt;code&gt;src&lt;/code&gt;-&amp;gt;&lt;code&gt;main&lt;/code&gt; -&amp;gt; &lt;code&gt;webapp&lt;/code&gt; 下的 &lt;code&gt;index.jsp&lt;/code&gt;即可看到熟悉的&lt;code&gt;Hello World!&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/12.06.42.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">在Mac中安装Maven并配置好Eclipse和IDEA</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/dui-er-jin-zhi-de-xin-li-jie/"" data-c="
          &lt;p&gt;二进制&lt;/p&gt;
&lt;p&gt;留坑。&lt;/p&gt;
">对二进制的新理解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/shi-yong-jsdelivr-de-cdn-pei-he-picgo-da-jian-yi-ge-github-tu-chuang/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;图床千千万，自建一个才放心。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个图床的核心需求不外乎是安全稳定+长期可靠+访问快速+能白嫖就白嫖。&lt;/p&gt;
&lt;p&gt;那么我选择了使用&lt;code&gt;GitHub&lt;/code&gt;作为图床，但是GitHub在国内直连速度不尽人意，所以我搭配使用了&lt;code&gt;jsDelivr&lt;/code&gt;的CDN，jsDelivr的CDN加速服务器遍布全球，包括中国。同理也可使用jsDeliver的CDN免费加速GitHub仓库的其他内容，比如本博客😊，但是注意不要拿来捣腾视频图床，否则可能会被jsDeliver拉黑，&lt;/p&gt;
&lt;p&gt;同时使用开源工具&lt;a href=&#34;https://github.com/Molunerfinn/PicGo&#34;&gt;PicGo&lt;/a&gt;作为图床的综合管理工具。&lt;/p&gt;
&lt;h2 id=&#34;首先在github创建一个图床仓库&#34;&gt;首先在GitHub创建一个图床仓库&lt;/h2&gt;
&lt;p&gt;1.在自己的&lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt;创建一个新的&lt;code&gt;repository&lt;/code&gt;&lt;br&gt;
2.为new repository起一个自己喜欢的&lt;code&gt;name&lt;/code&gt;&lt;br&gt;
3.注意new repository的权限必须设为&lt;code&gt;public&lt;/code&gt;&lt;br&gt;
4.接着点击&lt;code&gt;Create repository&lt;/code&gt;即可&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/1.39.02.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/1.47.09.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;接着在github创建一个具有所有repo权限的token已有请忽略&#34;&gt;接着在GitHub创建一个具有所有repo权限的token（已有请忽略）&lt;/h2&gt;
&lt;p&gt;请前往&lt;a href=&#34;https://github.com/settings/tokens&#34;&gt;https://github.com/settings/tokens&lt;/a&gt;创建token&lt;/p&gt;
&lt;h2 id=&#34;开始使用picgo使用管理图床&#34;&gt;开始使用Picgo使用管理图床&lt;/h2&gt;
&lt;p&gt;首先我们需要进入&lt;code&gt;图床设置&lt;/code&gt;进行基础配置&lt;br&gt;
注意&lt;code&gt;仓库名&lt;/code&gt;填写&lt;code&gt;用户名/图床仓库名&lt;/code&gt;&lt;br&gt;
为了jsDeliver加速，&lt;code&gt;自定义域名&lt;/code&gt;内填入&lt;code&gt;https://cdn.jsdelivr.net/gh/用户名/图床仓库名&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/1.23.04.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;配置完成后我们就可以进入&lt;code&gt;上传区&lt;/code&gt;开始上传图片，上传图片时除了将图片拖拽到&lt;code&gt;程序窗口虚线区域&lt;/code&gt;开始上传，也可以直接将图片拖拽到&lt;code&gt;状态栏程序小图标&lt;/code&gt;直至显示加号后松手也可完成图片上传。&lt;/p&gt;
&lt;p&gt;图片上传完成后PicGo会&lt;code&gt;自动&lt;/code&gt;根据窗口底部&lt;code&gt;链接格式&lt;/code&gt;将图片对应的链接格式复制到粘贴板。&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;上传区&lt;/code&gt;下方的&lt;code&gt;相册&lt;/code&gt;即可管理相册。&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/1.20.41.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们就可以使用GitHub图床了，同时使用了jsDeliver的CDN加速。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;202169更新&#34;&gt;2021.6.9更新&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;目前遇到一个问题：jsDelivr的CDN仓库免费加速配额只有50MB，&lt;code&gt;仓库大小超过50MB&lt;/code&gt;将出现错误提示。
&lt;ul&gt;
&lt;li&gt;解决办法也很简单，在GitHub中将对应的仓库大小控制在50MB内即可恢复，后续使用图床另建新的仓库即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">使用jsDelivr的CDN配合PicGo搭建一个GitHub图床</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/markdown-yu-yan/"" data-c="
          &lt;p&gt;目录：使用&lt;code&gt;@[TOC]&lt;/code&gt;就可以生成目录&lt;br&gt;
&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%87%E9%A2%98&#34;&gt;标题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BC%BA%E8%B0%83%E8%AF%AD%E6%B3%95&#34;&gt;强调语法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A6%96%E8%A1%8C%E7%BC%A9%E8%BF%9B&#34;&gt;首行缩进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%9C%E4%BD%93&#34;&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B2%97%E4%BD%93&#34;&gt;&lt;strong&gt;粗体&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%A0%E9%99%A4%E7%BA%BF&#34;&gt;删除线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%87%E6%9C%AC%E9%AB%98%E4%BA%AE&#34;&gt;文本高亮&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8A%E6%A0%87&#34;&gt;上标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8B%E6%A0%87&#34;&gt;下标&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%A3%E7%A0%81code&#34;&gt;代码Code&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%95%E8%A1%8C%E4%BB%A3%E7%A0%81&#34;&gt;单行代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%9A%E8%A1%8C%E4%BB%A3%E7%A0%81&#34;&gt;多行代码&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E5%BC%8F%E4%B8%80&#34;&gt;方式一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E5%BC%8F%E4%BA%8C&#34;&gt;方式二&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%97%E8%A1%A8&#34;&gt;列表&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8&#34;&gt;无序列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8&#34;&gt;有序列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#to-do%E5%88%97%E8%A1%A8&#34;&gt;To-Do列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A8%E6%A0%BC&#34;&gt;表格&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E5%89%B2%E7%BA%BF&#34;&gt;分割线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%87%E6%9C%AC%E5%BC%95%E7%94%A8&#34;&gt;文本引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%84%9A%E6%B3%A8&#34;&gt;脚注&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87&#34;&gt;插入图片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80&#34;&gt;链接地址&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%99%AE%E9%80%9A%E9%93%BE%E6%8E%A5&#34;&gt;普通链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%AB%98%E7%BA%A7%E9%93%BE%E6%8E%A5&#34;&gt;高级链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h2 id=&#34;标题&#34;&gt;标题&lt;/h2&gt;
&lt;p&gt;在Markdown中定义标题在前加&lt;code&gt;#&lt;/code&gt;号即可。&lt;br&gt;
以此类推，总共六级标题。&lt;br&gt;
在&lt;code&gt;#&lt;/code&gt;号后建议加一个&lt;code&gt;空格&lt;/code&gt;，这是标准的Markdown语法。&lt;br&gt;
&lt;code&gt;# 标题H1&lt;/code&gt;&lt;br&gt;
&lt;code&gt;## 标题H3&lt;/code&gt;&lt;br&gt;
&lt;code&gt;#### 标题H4&lt;/code&gt;&lt;br&gt;
&lt;code&gt;##### 标题H5&lt;/code&gt;&lt;br&gt;
&lt;code&gt;###### 标题H6&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;强调语法&#34;&gt;强调语法&lt;/h1&gt;
&lt;h2 id=&#34;首行缩进&#34;&gt;首行缩进&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一个汉字占两个空格大小，所以使用四个空格就可以达到首行缩进两个汉字的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;emsp;&lt;/code&gt;或&lt;code&gt;&amp;amp;#8195;&lt;/code&gt;代表2个空格大小，所以加上2个个该标记即可。&lt;br&gt;
&lt;code&gt;&amp;amp;ensp;&lt;/code&gt;或&lt;code&gt;&amp;amp;#8194;&lt;/code&gt;代表1个空格大小，所以加上4个该标记即可。&lt;br&gt;
&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;或&lt;code&gt;&amp;amp;#160;&lt;/code&gt;代表1个不换行空格，所以加上4个个该标记即可。&lt;br&gt;
&lt;mark&gt;注意要带上分号&lt;/mark&gt;&lt;br&gt;
示例：&lt;br&gt;
  首行缩进两字符。&lt;/p&gt;
&lt;h2 id=&#34;斜体&#34;&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;斜体的语法是用&lt;code&gt;*&lt;/code&gt;或&lt;code&gt;_&lt;/code&gt;包裹&lt;br&gt;
快捷键为&lt;code&gt;Command+I&lt;/code&gt;&lt;br&gt;
&lt;code&gt;*这是斜体*&lt;/code&gt;&lt;br&gt;
&lt;code&gt;_这也是斜体_&lt;/code&gt;&lt;br&gt;
示例：&lt;br&gt;
&lt;em&gt;这也是斜体&lt;/em&gt;&lt;br&gt;
&lt;em&gt;这是斜体&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;粗体&#34;&gt;&lt;strong&gt;粗体&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;粗体的语法是用&lt;code&gt;**&lt;/code&gt;包裹&lt;br&gt;
快捷键为&lt;code&gt;Command+B&lt;/code&gt;&lt;br&gt;
&lt;code&gt;**这是粗体**&lt;/code&gt;&lt;br&gt;
示例：&lt;br&gt;
&lt;strong&gt;这是粗体&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;删除线&#34;&gt;删除线&lt;/h2&gt;
&lt;p&gt;删除线的语法是用&lt;code&gt;~~&lt;/code&gt;包裹&lt;br&gt;
&lt;code&gt;~~这是删除线~~&lt;/code&gt;&lt;br&gt;
示例：&lt;br&gt;
&lt;s&gt;这是删除线&lt;/s&gt;&lt;/p&gt;
&lt;h2 id=&#34;文本高亮&#34;&gt;文本高亮&lt;/h2&gt;
&lt;p&gt;文本高亮用&lt;code&gt;==&lt;/code&gt;包裹&lt;br&gt;
&lt;code&gt;==高亮文本==&lt;/code&gt;&lt;br&gt;
示例：&lt;br&gt;
&lt;mark&gt;高亮文本&lt;/mark&gt;&lt;/p&gt;
&lt;h2 id=&#34;上标&#34;&gt;上标&lt;/h2&gt;
&lt;p&gt;上标用&lt;code&gt;^&lt;/code&gt;包裹&lt;br&gt;
&lt;code&gt;2^10^&lt;/code&gt;&lt;br&gt;
示例：&lt;br&gt;
2&lt;sup&gt;10&lt;/sup&gt;&lt;/p&gt;
&lt;h2 id=&#34;下标&#34;&gt;下标&lt;/h2&gt;
&lt;p&gt;下标用&lt;code&gt;~&lt;/code&gt;包裹&lt;br&gt;
&lt;code&gt;X~1~&lt;/code&gt;&lt;br&gt;
示例：&lt;br&gt;
X&lt;sub&gt;1&lt;/sub&gt;&lt;/p&gt;
&lt;h1 id=&#34;代码code&#34;&gt;代码Code&lt;/h1&gt;
&lt;h2 id=&#34;单行代码&#34;&gt;单行代码&lt;/h2&gt;
&lt;p&gt;行内代码的语法是用&lt;code&gt;反引号（Esc键）&lt;/code&gt;包裹。&lt;br&gt;
当然单行代码也可用来标记&lt;code&gt;文件名&lt;/code&gt;、&lt;code&gt;关键字&lt;/code&gt;等。&lt;br&gt;
示例：&lt;br&gt;
&lt;code&gt;这是单行代码&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;多行代码&#34;&gt;多行代码&lt;/h2&gt;
&lt;h3 id=&#34;方式一&#34;&gt;方式一&lt;/h3&gt;
&lt;p&gt;用&lt;code&gt;三个反引号（Esc键）&lt;/code&gt;包裹。&lt;br&gt;
示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in range(10, 51):
    if 1 &amp;lt;= i % 10 &amp;lt;= 5:
    print(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方式二&#34;&gt;方式二&lt;/h3&gt;
&lt;p&gt;缩进 4 个空格或是 1 个制表符；&lt;br&gt;
&lt;code&gt;注意此种方式代码块上方要留一空行&lt;/code&gt;&lt;br&gt;
示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in range(10, 51):
    if 1 &amp;lt;= i % 10 &amp;lt;= 5:
    print(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;列表&#34;&gt;列表&lt;/h1&gt;
&lt;h2 id=&#34;无序列表&#34;&gt;无序列表&lt;/h2&gt;
&lt;p&gt;无序列表以&lt;code&gt;+``-``*&lt;/code&gt;任意开头即可&lt;br&gt;
类似于标题，注意要&lt;code&gt;+``-``*&lt;/code&gt;后面要加一个&lt;code&gt;空格&lt;/code&gt;&lt;br&gt;
示例：&lt;br&gt;
&lt;code&gt;+ 列表一&lt;/code&gt;&lt;br&gt;
&lt;code&gt;- 列表二&lt;/code&gt;&lt;br&gt;
&lt;code&gt;* 列表三&lt;/code&gt;&lt;br&gt;
显示效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表一&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;列表二&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;列表三&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并且可任意嵌套。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ 一级嵌套
- 一级嵌套
* 一级嵌套
    - 二级嵌套
    * 二级嵌套
    + 二级嵌套
        + 三级嵌套
        + 三级嵌套
        + 三级嵌套
            - 四级嵌套
            + 四级嵌套
            * 四级嵌套
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一级嵌套&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;一级嵌套&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;一级嵌套
&lt;ul&gt;
&lt;li&gt;二级嵌套&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;二级嵌套&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;二级嵌套
&lt;ul&gt;
&lt;li&gt;三级嵌套&lt;/li&gt;
&lt;li&gt;三级嵌套&lt;/li&gt;
&lt;li&gt;三级嵌套&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;有序列表&#34;&gt;有序列表&lt;/h2&gt;
&lt;p&gt;有序列表直接以阿拉伯数学排序即可。&lt;br&gt;
注意在&lt;code&gt;有序列表符号&lt;/code&gt;后面建议也加一个&lt;code&gt;空格&lt;/code&gt;&lt;br&gt;
示例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列表一&lt;/li&gt;
&lt;li&gt;列表二&lt;/li&gt;
&lt;li&gt;列表三&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;to-do列表&#34;&gt;To-Do列表&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;- [ ] Text&lt;/code&gt;表示未完成&lt;br&gt;
&lt;code&gt;- [x] Text&lt;/code&gt;表示已完成&lt;br&gt;
示例：&lt;/p&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-721418&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-721418&#34;&gt; 未完成&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-180484&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-180484&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;
&lt;p&gt;在Markdown中制作表格使用&lt;code&gt;|&lt;/code&gt;来分隔不同的单元格，使用&lt;code&gt;-&lt;/code&gt;(一个，两个，三个...都可以)来分隔表头和其他行&lt;br&gt;
语法格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| 表头 | 表头 |
| --- | --- |
| 单元格 | 单元格 |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例显示效果为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表头&lt;/th&gt;
&lt;th&gt;表头&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们也可以设置表格的对齐方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;:&lt;code&gt;---&lt;/code&gt;设置内容和标题左对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:---:&lt;/code&gt;设置内容和标题居中对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;---:&lt;/code&gt;设置内容和标题右对齐&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    | 左对齐 | 居中对齐 | 右对齐 |
    | :--- | :---: | ---: |
    | 单元格 | 单元格 | 单元格 |
    | 单元格 | 单元格 | 单元格 |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例显示效果为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;左对齐&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;居中对齐&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;右对齐&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;分割线&#34;&gt;分割线&lt;/h1&gt;
&lt;p&gt;连续三个星号&lt;code&gt;***&lt;/code&gt;或者连续三个横杠&lt;code&gt;---&lt;/code&gt;即可。&lt;br&gt;
推荐使用连续的三个星号。&lt;/p&gt;
&lt;h1 id=&#34;文本引用&#34;&gt;文本引用&lt;/h1&gt;
&lt;p&gt;文本引用在对应的段落文本前加一个&lt;code&gt;&amp;gt;&lt;/code&gt;符号即可。&lt;br&gt;
示例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文本引用在对应的段落文本前加一个&lt;code&gt;&amp;gt;&lt;/code&gt;符号即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;脚注&#34;&gt;脚注&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;这里有一个脚注[^1]，还有一个脚注[^2]&lt;/code&gt;&lt;br&gt;
脚注注释用&lt;code&gt;[^1]:注释内容&lt;/code&gt;&lt;br&gt;
示例:&lt;br&gt;
这里有一个脚注&lt;sup class=&#34;footnote-ref&#34;&gt;&lt;a href=&#34;#fn1&#34; id=&#34;fnref1&#34;&gt;[1]&lt;/a&gt;&lt;/sup&gt;，还有一个脚注&lt;sup class=&#34;footnote-ref&#34;&gt;&lt;a href=&#34;#fn2&#34; id=&#34;fnref2&#34;&gt;[2]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h1 id=&#34;插入图片&#34;&gt;插入图片&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;![描述](图片链接)&lt;/code&gt;&lt;br&gt;
示例：&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN/img/ios-14-2-3840x2160-artwork-day-4k-23208.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;链接地址&#34;&gt;链接地址&lt;/h1&gt;
&lt;h2 id=&#34;普通链接&#34;&gt;普通链接&lt;/h2&gt;
&lt;p&gt;使用文本指向链接：&lt;br&gt;
&lt;code&gt;[Google](https://www.google.com/)是一个搜索引擎&lt;/code&gt;&lt;br&gt;
直接显示链接地址：&lt;br&gt;
&lt;code&gt;Google的地址是：&amp;lt;https://www.google.com/&amp;gt;&lt;/code&gt;&lt;br&gt;
示例：&lt;br&gt;
&lt;a href=&#34;https://www.google.com/&#34;&gt;Google&lt;/a&gt;是一个搜索引擎&lt;/p&gt;
&lt;p&gt;Google的地址是：&lt;a href=&#34;https://www.google.com/&#34;&gt;https://www.google.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;高级链接&#34;&gt;高级链接&lt;/h2&gt;
&lt;p&gt;类似脚注，我们可以通过变量来设置一个链接，变量赋值在文档末尾进行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这个链接用`1`作为网址变量[Google][1]
这个链接用`Apple`作为网址变量[Apple官网][Apple]

[1]:https://www.google.com/
[Apple]:https://www.apple.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;br&gt;
这个链接用&lt;code&gt;1&lt;/code&gt;作为网址变量&lt;a href=&#34;https://www.google.com/&#34;&gt;Google&lt;/a&gt;&lt;br&gt;
这个链接用&lt;code&gt;Apple&lt;/code&gt;作为网址变量&lt;a href=&#34;https://www.apple.com/&#34;&gt;Apple官网&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&#34;footnotes-sep&#34;&gt;
&lt;section class=&#34;footnotes&#34;&gt;
&lt;ol class=&#34;footnotes-list&#34;&gt;
&lt;li id=&#34;fn1&#34; class=&#34;footnote-item&#34;&gt;&lt;p&gt;注释示例 &lt;a href=&#34;#fnref1&#34; class=&#34;footnote-backref&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn2&#34; class=&#34;footnote-item&#34;&gt;&lt;p&gt;注释示例 &lt;a href=&#34;#fnref2&#34; class=&#34;footnote-backref&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
">Markdown语言</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://kuangyang828.github.io/about/"" data-c="
          &lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;我的个人博客，主要记录我的学习点滴。&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;Email：&lt;a href=&#34;mailto:kuangyangedu@qq.com&#34;&gt;mailto:kuangyangedu@qq.com&lt;/a&gt;&lt;/p&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






</html>