<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kuangyang828.github.io</id>
    <title>kuangyang&apos;s Blog</title>
    <updated>2023-01-03T15:11:59.657Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kuangyang828.github.io"/>
    <link rel="self" href="https://kuangyang828.github.io/atom.xml"/>
    <subtitle>记录我的学习点滴。</subtitle>
    <logo>https://kuangyang828.github.io/images/avatar.png</logo>
    <icon>https://kuangyang828.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, kuangyang&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Zookeeper 笔记]]></title>
        <id>https://kuangyang828.github.io/zookeeper-bi-ji/</id>
        <link href="https://kuangyang828.github.io/zookeeper-bi-ji/">
        </link>
        <updated>2022-09-14T07:22:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.bilibili.com/video/BV1to4y1C7gw">视频地址 🔗bilibili</a></p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220914153034.png" alt="" loading="lazy"></figure>
<h1 id="zookeeper-入门">Zookeeper 入门</h1>
<h2 id="概述">概述</h2>
<p>Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。<br>
（Zookeeper 是一个为其他分布式框架提供服务的分布式框架）</p>
<h2 id="工作机制">工作机制</h2>
<p>Zookeeper从设计模式角度来理解：是一个基于<code>观察者模式</code>设计的分布式服务管理框架，它<code>负责存储和管理大家都关心的数据</code>，然后<code>接受观察者的注册</code>，<code>一旦</code>这些<code>数据</code>的状态发生<code>变化</code>，Zookeeper就将<code>负责通知已经在Zookeeper上注册的那些观察者</code>做出相应的反应。<br>
<br><br>
<code>Zookeeper=文件系统+通知机制</code></p>
<h2 id="特点">特点</h2>
<p><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220914155529.png" alt="" loading="lazy"><br>
1）	Zookeeper：一个领导者（Leader），多个跟随者（Follower）组成的集群。<br>
2）	集群中只要有<code>半数</code>以上节点存活，Zookeeper集群就能正常服务。所以 Zookeeper 适合安装<code>奇数</code>台服务器。<br>
3）	全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。<br>
4）	更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。<br>
5）	数据更新原子性，一次数据更新要么成功，要么失败。</p>
<h2 id="数据结构">数据结构</h2>
<p>ZooKeeper 数据模型的结构与 <code>Unix 文件系统很类似</code>，<code>整体</code>上可以看作是一棵<code>树</code>，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 <code>1MB</code> 的数据，每个 ZNode 都可以<code>通过其路径唯一标识</code>。<br>
<img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220914160014.png" alt="" loading="lazy"></p>
<h2 id="应用场景">应用场景</h2>
<p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p>
<h1 id="面试重点">面试重点</h1>
<h2 id="选举机制">选举机制</h2>
<p>半数机制，超过半数的投票通过，即通过。<br>
（1）第一次启动选举规则：<br>
投票过半数时，服务器 id 大的胜出。<br>
即每台机器会先投给自己，不行再投给 id 大的，依此类推，直到某台机器获得超过半数的票，它就成为Leader。所以一般是排在中间服务器当 Leader。<br>
<img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220914161440.png" alt="" loading="lazy"></p>
<p>（2）第二次启动选举规则：<br>
①	EPOCH 大的直接胜出<br>
②	EPOCH 相同，事务 id 大的胜出<br>
③	事务 id 相同，服务器 id 大的胜出</p>
<h2 id="监听器客户端原理">监听器（客户端）原理</h2>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220914162750.png" alt="" loading="lazy"></figure>
<h2 id="生产集群安装多少zk合适">生产集群安装多少zk合适？</h2>
<p>安装奇数台。<br>
<code>生产经验：</code></p>
<ul>
<li>10 台服务器：3 台 zk；</li>
<li>20 台服务器：5 台 zk；</li>
<li>100 台服务器：11 台 zk；</li>
<li>200 台服务器：11 台 zk</li>
</ul>
<p><code>服务器台数多：好处，提高可靠性；坏处：提高通信延时</code></p>
<h2 id="常用命令">常用命令</h2>
<p>ls、get、create、delete</p>
<h1 id="随堂笔记">随堂笔记</h1>
<p><a href="https://github.com/kuangyang828/share_doc/blob/master/Zookeeper%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0.pdf">https://github.com/kuangyang828/share_doc/blob/master/Zookeeper随堂笔记.pdf</a></p>
<h1 id="课件">课件</h1>
<p><a href="https://github.com/kuangyang828/share_doc/blob/master/08_%E5%B0%9A%E7%A1%85%E8%B0%B7%E6%8A%80%E6%9C%AF%E4%B9%8BZookeeperV3.3.pdf">https://github.com/kuangyang828/share_doc/blob/master/08_尚硅谷技术之ZookeeperV3.3.pdf</a></p>
<h1 id="源码分析">源码分析</h1>
<p><a href="https://github.com/kuangyang828/share_doc/blob/master/08_%E5%B0%9A%E7%A1%85%E8%B0%B7%E6%8A%80%E6%9C%AF%E4%B9%8BZookeeper%EF%BC%88%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%89V3.3.pdf">https://github.com/kuangyang828/share_doc/blob/master/08_尚硅谷技术之Zookeeper（源码解析）V3.3.pdf</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter 笔记]]></title>
        <id>https://kuangyang828.github.io/flutter-bi-ji/</id>
        <link href="https://kuangyang828.github.io/flutter-bi-ji/">
        </link>
        <updated>2022-09-02T01:45:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="环境搭建">环境搭建</h1>
<h2 id="安装-flutter-sdk">安装 Flutter SDK</h2>
<h2 id="运行-flutter-doctor-命令">运行 flutter doctor 命令</h2>
<p>https://flutter.cn/docs/get-started/install/macos#update-your-path</p>
<h3 id="配置环境变量">配置环境变量</h3>
<p>https://flutter.cn/docs/get-started/install/macos#update-your-path</p>
<h2 id="配置-ios-环境">配置 iOS 环境</h2>
<h2 id="配置-android-环境">配置 Android 环境</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot 应用篇笔记]]></title>
        <id>https://kuangyang828.github.io/springboot-ying-yong-pian-bi-ji/</id>
        <link href="https://kuangyang828.github.io/springboot-ying-yong-pian-bi-ji/">
        </link>
        <updated>2022-08-29T16:12:39.000Z</updated>
        <content type="html"><![CDATA[<p>https://youtube.com/playlist?list=PLD3Xyx6ef38xcNhCaCV_fUqB9vjTDA7hX</p>
<h1 id="文件上传与下载">文件上传与下载</h1>
<h2 id="文件上传">文件上传</h2>
<ul>
<li>Spring Boot 实现文件上传与下载功能本质还是依靠 Spring MVC</li>
<li>需要注意的是，获取存放上传与下载文件的目录的方式不同</li>
</ul>
<pre><code class="language-java">@RequestMapping(&quot;/uploadDocument&quot;)
public Result uploadDocument(MultipartFile uploadFile) throws IOException {
    // 获取上传的文件的文件名
    String fileName = uploadFile.getOriginalFilename();
    // 处理文件重名问题
    String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));
    String prefixName = fileName.substring(0, fileName.lastIndexOf(&quot;.&quot;));
    fileName = prefixName + &quot;-&quot; + UUID.randomUUID() + suffixName;
    // 获取服务器中 Document 目录的路径
    File documentPath = new File(ResourceUtils.getURL(&quot;classpath:static/uploadPath/document&quot;).getPath());
    if (!documentPath.exists()) {
        documentPath.mkdir();
    }
    String finalPath = documentPath + File.separator + fileName;
    // 实现上传功能
    uploadFile.transferTo(new File(finalPath));
    return Result.OK(&quot;/uploadPath/document/&quot; + fileName);
}
</code></pre>
<h2 id="文件下载">文件下载</h2>
<pre><code class="language-java">@GetMapping(&quot;/downloadDocument/{fileName}&quot;)
public ResponseEntity&lt;byte[]&gt; downloadDocument(@PathVariable(&quot;fileName&quot;) String fileName) throws IOException {
    // 获取服务器中文件的真实路径
    String realPath = ResourceUtils.getURL(&quot;classpath:static/uploadPath/document/&quot;).getPath() + fileName;
    // 创建输入流
    //InputStream is = new FileInputStream(realPath);
    InputStream is = Files.newInputStream(Paths.get(realPath));
    // 创建字节数组
    byte[] bytes = new byte[is.available()];
    // 将流读到字节数组中
    is.read(bytes);
    // 创建HttpHeaders对象设置响应头信息
    MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();
    // 对文件名重新编码，防止中文乱码
    fileName = new String(fileName.getBytes(StandardCharsets.UTF_8), StandardCharsets.ISO_8859_1);
    // 设置要下载方式以及下载文件的名字
    headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + fileName);
    // 设置响应状态码
    HttpStatus statusCode = HttpStatus.OK;
    // 创建ResponseEntity对象
    ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode);
    // 关闭输入流
    is.close();
    return responseEntity;
}
</code></pre>
<h1 id="5-整合第三方技术">5-整合第三方技术</h1>
<h2 id="5-2-定时任务">5-2 定时任务</h2>
<p>定时任务是企业级开发中必不可少的组成部分，诸如长周期业务数据的计算，例如年度报表，诸如系统脏数据的处理，再比如系统性能监控报告，还有抢购类活动的商品上架，这些都离不开定时任务。本节将介绍两种不同的定时任务技术。</p>
<h3 id="quartz">Quartz</h3>
<p>Quartz技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂。springboot对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。在</p>
<p>学习springboot整合Quartz前先普及几个Quartz的概念。</p>
<ul>
<li>工作（Job）：用于定义具体执行的工作</li>
<li>工作明细（JobDetail）：用于描述定时工作相关的信息</li>
<li>触发器（Trigger）：描述了工作明细与调度器的对应关系</li>
<li>调度器（Scheduler）：用于描述触发工作的执行规则，通常使用cron表达式定义规则</li>
</ul>
<p><strong>步骤①</strong>：导入springboot整合Quartz的starte</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>步骤②</strong>：定义任务Bean，按照Quartz的开发规范制作，需要继承QuartzJobBean</p>
<ul>
<li>注意，任务Bean<mark>不需要</mark>标注为组件交给Spring容器管理。</li>
</ul>
<pre><code class="language-java">public class MyQuartz extends QuartzJobBean {
    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        System.out.println(&quot;quartz task run...&quot;);
    }
}
</code></pre>
<p><strong>步骤③</strong>：创建Quartz配置类，定义工作明细（JobDetail）与触发器的（Trigger）bean</p>
<pre><code class="language-java">@Configuration
public class QuartzConfig {
  
  	/**
     * 工作明细
     * @return
     */
    @Bean
    public JobDetail printJobDetail(){
        //绑定具体的工作
        return JobBuilder.newJob(MyQuartz.class).storeDurably().build();
    }
  
  	/**
     * 触发器
     * @return
     */
    @Bean
    public Trigger printJobTrigger(){
        ScheduleBuilder schedBuilder = CronScheduleBuilder.cronSchedule(&quot;0/5 * * * * ?&quot;);
        //绑定对应的工作明细与执行时间（调度器）
        return  TriggerBuilder.newTrigger().forJob(printJobDetail()).withSchedule(schedBuilder).build();
    }
}
</code></pre>
<ul>
<li><mark>工作明细</mark>中要设置对应的具体<mark>工作</mark>，</li>
<li>使用newJob()操作传入对应的工作任务类型即可。</li>
<li><mark>触发器</mark>需要绑定<mark>任务</mark>，使用forJob()操作传入绑定的工作明细对象，</li>
<li>此处可以为工作明细设置名称，然后使用名称绑定，</li>
<li>也可以直接调用对应方法绑定；</li>
<li>触发器中最核心的规则是<mark>执行时间</mark>，此处使用调度器定义执行时间，</li>
<li>执行时间描述方式使用的是cron表达式。有关cron表达式的规则，各位小伙伴可以去参看相关课程学习，略微复杂，而且格式不能乱设置，不是写个格式就能用的，写不好就会出现冲突问题。</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>springboot整合Quartz就是将Quartz对应的两个核心对象交给spring容器管理，包含两个对象，JobDetail和Trigger对象</li>
<li>JobDetail对象描述的是工作的执行信息，需要绑定一个QuartzJobBean类型的对象</li>
<li>Trigger对象定义了一个触发器，需要为其指定绑定的JobDetail是哪个，同时要设置执行周期调度器</li>
</ol>
<h3 id="spring-task">Spring Task</h3>
<p>上面的操作看上去不多，但是Quartz将其中的对象划分粒度过细，导致开发的时候有点繁琐，Spring针对上述规则进行了简化，开发了自己的任务管理组件——Task，</p>
<p>Spring根据定时任务的特征，将定时任务的开发简化到了极致。怎么说呢？要做定时任务总要告诉容器有这功能吧，然后定时执行什么任务直接告诉对应的bean什么时间执行就行了，就这么简单，一起来看怎么做</p>
<p><strong>步骤①</strong>：开启定时任务功能，使用注解 @EnableScheduling</p>
<pre><code class="language-java">@SpringBootApplication
//开启定时任务功能
@EnableScheduling
public class Springboot22TaskApplication {
    public static void main(String[] args) {
        SpringApplication.run(Springboot22TaskApplication.class, args);
    }
}
</code></pre>
<p><strong>步骤②</strong>：定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式</p>
<pre><code class="language-java">@Component
public class MyTask {
    @Scheduled(cron = &quot;0/1 * * * * ?&quot;)
    public void print(){
        System.out.println(Thread.currentThread().getName()+&quot; :spring task run...&quot;);
    }
}
</code></pre>
<p>完事，这就完成了定时任务的配置。总体感觉其实什么东西都没少，只不过没有将所有的信息都抽取成bean，而是直接使用注解绑定定时执行任务的事情而已。</p>
<ul>
<li>如果想对定时任务进行相关配置，可以通过配置文件进行</li>
</ul>
<pre><code class="language-yaml">spring:
  task:
   	scheduling:
      pool:
       	size: 1							# 任务调度线程池大小 默认 1
      thread-name-prefix: spring_task_      	# 调度线程名称前缀 默认 scheduling-      
        shutdown:
          await-termination: false		# 线程池关闭时等待所有任务完成
          await-termination-period: 10s	# 调度线程关闭前最大等待时间，确保最后一定关闭
</code></pre>
<p><strong>总结</strong></p>
<ol>
<li>
<p>Spring Task需要使用注解 @EnableScheduling 开启定时任务功能</p>
</li>
<li>
<p>为定时执行的的任务设置执行周期，描述方式cron表达式</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用文件和代码模版]]></title>
        <id>https://kuangyang828.github.io/chang-yong-wen-jian-he-dai-ma-mo-ban/</id>
        <link href="https://kuangyang828.github.io/chang-yong-wen-jian-he-dai-ma-mo-ban/">
        </link>
        <updated>2022-08-22T08:47:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="java">Java</h1>
<h2 id="java-2">Java</h2>
<h3 id="result">Result</h3>
<ul>
<li>Result.java</li>
</ul>
<pre><code class="language-Java">public class Result&lt;T&gt; implements Serializable {
    
    public Result() {
    }

    public Result(boolean success, String message, Integer code, T result, long timestamp) {
        this.success = success;
        this.message = message;
        this.code = code;
        this.result = result;
        this.timestamp = timestamp;
    }

    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public T getResult() {
        return result;
    }

    public void setResult(T result) {
        this.result = result;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }

    private static final long serialVersionUID = 1L;

    /**
     * 成功标志
     */
    private boolean success = true;

    /**
     * 返回处理消息
     */
    private String message = &quot;操作成功！&quot;;

    /**
     * 返回状态码
     */
    private Integer code = 0;

    /**
     * 返回数据对象
     */
    private T result;

    /**
     * 时间戳
     */
    private long timestamp = System.currentTimeMillis();

    public static &lt;T&gt; Result&lt;T&gt; OK() {
        Result&lt;T&gt; rs = new Result&lt;T&gt;();
        rs.setSuccess(true);
        rs.setCode(200);
        rs.setMessage(&quot;操作成功！&quot;);
        return rs;
    }

    public static &lt;T&gt; Result&lt;T&gt; OK(T data) {
        Result&lt;T&gt; rs = new Result&lt;T&gt;();
        rs.setSuccess(true);
        rs.setCode(200);
        rs.setResult(data);
        return rs;
    }

    public static &lt;T&gt; Result&lt;T&gt; OK(String msg) {
        Result&lt;T&gt; rs = new Result&lt;T&gt;();
        rs.setSuccess(true);
        rs.setCode(200);
        rs.setMessage(msg);
        return rs;
    }

    public static &lt;T&gt; Result&lt;T&gt; OK(String msg, T data) {
        Result&lt;T&gt; rs = new Result&lt;T&gt;();
        rs.setSuccess(true);
        rs.setCode(200);
        rs.setMessage(msg);
        rs.setResult(data);
        return rs;
    }

    public static Result&lt;Object&gt; error(String msg) {
        return error(500, msg);
    }

    public static Result&lt;Object&gt; error(int code, String msg) {
        Result&lt;Object&gt; rs = new Result&lt;Object&gt;();
        rs.setCode(code);
        rs.setMessage(msg);
        rs.setSuccess(false);
        return rs;
    }
}
</code></pre>
<h3 id="stringutils">StringUtils</h3>
<p>StringUtils.java</p>
<pre><code class="language-java">/**
 * 字符串工具类
 */
public class StringUtils {
    /**
     * 空字符串
     */
    private static final String NULLSTR = &quot;&quot;;

    /**
     * 下划线
     */
    private static final char SEPARATOR = '_';

    /**
     * 确保获取的参数不为空值
     *
     * @param value defaultValue 要判断的value
     * @return value 返回值
     */
    public static &lt;T&gt; T nvl(T value, T defaultValue) {
        return value != null ? value : defaultValue;
    }

    /**
     * 判断一个字符串是否为空串
     *
     * @param str String
     * @return true：为空 false：非空
     */
    public static boolean isEmpty(String str) {
        return null == str || NULLSTR.equals(str.trim());
    }

    /**
     * 判断一个字符串是否为非空串
     *
     * @param str String
     * @return true：非空串 false：空串
     */
    public static boolean isNotEmpty(String str) {
        return !isEmpty(str);
    }


    /**
     * 去空格
     */
    public static String trim(String str) {
        return (str == null ? &quot;&quot; : str.trim());
    }

    /**
     * 是否为http(s)://开头
     *
     * @param link 链接
     * @return 结果
     */
    public static boolean ishttp(String link) {
        return link.equalsIgnoreCase(&quot;http&quot;) || link.equalsIgnoreCase(&quot;https&quot;);
    }

    /**
     * 驼峰转下划线命名方式。
     * 不区分大驼峰或小驼峰
     * 例如：
     * ① HelloWorld -&gt; hello_world
     * ② helloWorld -&gt; hello_world
     *
     * @param str 转换前的驼峰方式命名的字符串
     * @return 转换后的下划线命名的字符串
     */
    public static String toUnderScoreCase(String str) {
        if (str == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        // 前置字符是否大写
        boolean preCharIsUpperCase = true;
        // 当前字符是否大写
        boolean curreCharIsUpperCase = true;
        // 下一字符是否大写
        boolean nexteCharIsUpperCase = true;
        for (int i = 0; i &lt; str.length(); i++) {
            char c = str.charAt(i);
            if (i &gt; 0) {
                preCharIsUpperCase = Character.isUpperCase(str.charAt(i - 1));
            } else {
                preCharIsUpperCase = false;
            }

            curreCharIsUpperCase = Character.isUpperCase(c);

            if (i &lt; (str.length() - 1)) {
                nexteCharIsUpperCase = Character.isUpperCase(str.charAt(i + 1));
            }

            if (preCharIsUpperCase &amp;&amp; curreCharIsUpperCase &amp;&amp; !nexteCharIsUpperCase) {
                sb.append(SEPARATOR);
            } else if ((i != 0 &amp;&amp; !preCharIsUpperCase) &amp;&amp; curreCharIsUpperCase) {
                sb.append(SEPARATOR);
            }
            sb.append(Character.toLowerCase(c));
        }

        return sb.toString();
    }

    /**
     * 是否包含字符串
     *
     * @param str  验证字符串
     * @param strs 字符串组
     * @return 包含返回true
     */
    public static boolean inStringIgnoreCase(String str, String... strs) {
        if (str != null &amp;&amp; strs != null) {
            for (String s : strs) {
                if (str.equalsIgnoreCase(trim(s))) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 下划线方式命名的字符串或小驼峰，转换为大驼峰式。
     * 如果转换前的下划线大写方式命名的字符串为空，则返回空字符串。
     * 例如：
     * ① HELLO_WORLD -&gt; HelloWorld
     * ② hello_world -&gt; HelloWorld
     * ③ helloWorld -&gt; HelloWorld
     *
     * @param name 转换前的下划线大写方式命名的字符串
     * @return 转换后的驼峰式命名的字符串
     */
    public static String toBigCamelCase(String name) {
        StringBuilder result = new StringBuilder();
        // 快速检查
        if (name == null || name.isEmpty()) {
            // 没必要转换
            return &quot;&quot;;
        } else if (!name.contains(&quot;_&quot;)) {
            // 不含下划线，仅将首字母大写
            return name.substring(0, 1).toUpperCase() + name.substring(1);
        }
        // 用下划线将原始字符串分割
        String[] camels = name.split(&quot;_&quot;);
        for (String camel : camels) {
            // 跳过原始字符串中开头、结尾的下换线或双重下划线
            if (camel.isEmpty()) {
                continue;
            }
            // 首字母大写
            result.append(camel.substring(0, 1).toUpperCase());
            result.append(camel.substring(1).toLowerCase());
        }
        return result.toString();
    }

    /**
     * 下划线方式命名的字符串转小驼峰式。
     * 例如：
     * ① USER_NAME-&gt;userName
     * ② user_name-&gt;userName
     *
     * @param s 转换前的下划线小写方式命名的字符串
     * @return 转换后的驼峰式命名的字符串
     */
    public static String toSmallCamelCase(String s) {
        if (s == null) {
            return null;
        }
        s = s.toLowerCase();
        StringBuilder sb = new StringBuilder(s.length());
        boolean upperCase = false;
        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (c == SEPARATOR) {
                upperCase = true;
            } else if (upperCase) {
                sb.append(Character.toUpperCase(c));
                upperCase = false;
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

}
</code></pre>
<h3 id="uuid">UUID</h3>
<ul>
<li>UUID.java</li>
</ul>
<pre><code class="language-java">/**
 * 提供通用唯一识别码（universally unique identifier）（UUID）实现
 */
public final class UUID implements java.io.Serializable, Comparable&lt;UUID&gt;
{
    private static final long serialVersionUID = -1185015143654744140L;

    /**
     * SecureRandom 的单例
     *
     */
    private static class Holder
    {
        static final SecureRandom numberGenerator = getSecureRandom();
    }

    /** 此UUID的最高64有效位 */
    private final long mostSigBits;

    /** 此UUID的最低64有效位 */
    private final long leastSigBits;

    /**
     * 私有构造
     * 
     * @param data 数据
     */
    private UUID(byte[] data)
    {
        long msb = 0;
        long lsb = 0;
        assert data.length == 16 : &quot;data must be 16 bytes in length&quot;;
        for (int i = 0; i &lt; 8; i++)
        {
            msb = (msb &lt;&lt; 8) | (data[i] &amp; 0xff);
        }
        for (int i = 8; i &lt; 16; i++)
        {
            lsb = (lsb &lt;&lt; 8) | (data[i] &amp; 0xff);
        }
        this.mostSigBits = msb;
        this.leastSigBits = lsb;
    }

    /**
     * 使用指定的数据构造新的 UUID。
     *
     * @param mostSigBits 用于 {@code UUID} 的最高有效 64 位
     * @param leastSigBits 用于 {@code UUID} 的最低有效 64 位
     */
    public UUID(long mostSigBits, long leastSigBits)
    {
        this.mostSigBits = mostSigBits;
        this.leastSigBits = leastSigBits;
    }

    /**
     * 获取类型 4（伪随机生成的）UUID 的静态工厂。 使用加密的本地线程伪随机数生成器生成该 UUID。
     * 
     * @return 随机生成的 {@code UUID}
     */
    public static UUID fastUUID()
    {
        return randomUUID(false);
    }

    /**
     * 获取类型 4（伪随机生成的）UUID 的静态工厂。 使用加密的强伪随机数生成器生成该 UUID。
     * 
     * @return 随机生成的 {@code UUID}
     */
    public static UUID randomUUID()
    {
        return randomUUID(true);
    }

    /**
     * 获取类型 4（伪随机生成的）UUID 的静态工厂。 使用加密的强伪随机数生成器生成该 UUID。
     * 
     * @param isSecure 是否使用{@link SecureRandom}如果是可以获得更安全的随机码，否则可以得到更好的性能
     * @return 随机生成的 {@code UUID}
     */
    public static UUID randomUUID(boolean isSecure)
    {
        final Random ng = isSecure ? Holder.numberGenerator : getRandom();

        byte[] randomBytes = new byte[16];
        ng.nextBytes(randomBytes);
        randomBytes[6] &amp;= 0x0f; /* clear version */
        randomBytes[6] |= 0x40; /* set to version 4 */
        randomBytes[8] &amp;= 0x3f; /* clear variant */
        randomBytes[8] |= 0x80; /* set to IETF variant */
        return new UUID(randomBytes);
    }

    /**
     * 根据指定的字节数组获取类型 3（基于名称的）UUID 的静态工厂。
     *
     * @param name 用于构造 UUID 的字节数组。
     *
     * @return 根据指定数组生成的 {@code UUID}
     */
    public static UUID nameUUIDFromBytes(byte[] name)
    {
        MessageDigest md;
        try
        {
            md = MessageDigest.getInstance(&quot;MD5&quot;);
        }
        catch (NoSuchAlgorithmException nsae)
        {
            throw new InternalError(&quot;MD5 not supported&quot;);
        }
        byte[] md5Bytes = md.digest(name);
        md5Bytes[6] &amp;= 0x0f; /* clear version */
        md5Bytes[6] |= 0x30; /* set to version 3 */
        md5Bytes[8] &amp;= 0x3f; /* clear variant */
        md5Bytes[8] |= 0x80; /* set to IETF variant */
        return new UUID(md5Bytes);
    }

    /**
     * 根据 {@link #toString()} 方法中描述的字符串标准表示形式创建{@code UUID}。
     *
     * @param name 指定 {@code UUID} 字符串
     * @return 具有指定值的 {@code UUID}
     * @throws IllegalArgumentException 如果 name 与 {@link #toString} 中描述的字符串表示形式不符抛出此异常
     *
     */
    public static UUID fromString(String name)
    {
        String[] components = name.split(&quot;-&quot;);
        if (components.length != 5)
        {
            throw new IllegalArgumentException(&quot;Invalid UUID string: &quot; + name);
        }
        for (int i = 0; i &lt; 5; i++)
        {
            components[i] = &quot;0x&quot; + components[i];
        }

        long mostSigBits = Long.decode(components[0]).longValue();
        mostSigBits &lt;&lt;= 16;
        mostSigBits |= Long.decode(components[1]).longValue();
        mostSigBits &lt;&lt;= 16;
        mostSigBits |= Long.decode(components[2]).longValue();

        long leastSigBits = Long.decode(components[3]).longValue();
        leastSigBits &lt;&lt;= 48;
        leastSigBits |= Long.decode(components[4]).longValue();

        return new UUID(mostSigBits, leastSigBits);
    }

    /**
     * 返回此 UUID 的 128 位值中的最低有效 64 位。
     *
     * @return 此 UUID 的 128 位值中的最低有效 64 位。
     */
    public long getLeastSignificantBits()
    {
        return leastSigBits;
    }

    /**
     * 返回此 UUID 的 128 位值中的最高有效 64 位。
     *
     * @return 此 UUID 的 128 位值中最高有效 64 位。
     */
    public long getMostSignificantBits()
    {
        return mostSigBits;
    }

    /**
     * 与此 {@code UUID} 相关联的版本号. 版本号描述此 {@code UUID} 是如何生成的。
     * &lt;p&gt;
     * 版本号具有以下含意:
     * &lt;ul&gt;
     * &lt;li&gt;1 基于时间的 UUID
     * &lt;li&gt;2 DCE 安全 UUID
     * &lt;li&gt;3 基于名称的 UUID
     * &lt;li&gt;4 随机生成的 UUID
     * &lt;/ul&gt;
     *
     * @return 此 {@code UUID} 的版本号
     */
    public int version()
    {
        // Version is bits masked by 0x000000000000F000 in MS long
        return (int) ((mostSigBits &gt;&gt; 12) &amp; 0x0f);
    }

    /**
     * 与此 {@code UUID} 相关联的变体号。变体号描述 {@code UUID} 的布局。
     * &lt;p&gt;
     * 变体号具有以下含意：
     * &lt;ul&gt;
     * &lt;li&gt;0 为 NCS 向后兼容保留
     * &lt;li&gt;2 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;IETF&amp;nbsp;RFC&amp;nbsp;4122&lt;/a&gt;(Leach-Salz), 用于此类
     * &lt;li&gt;6 保留，微软向后兼容
     * &lt;li&gt;7 保留供以后定义使用
     * &lt;/ul&gt;
     *
     * @return 此 {@code UUID} 相关联的变体号
     */
    public int variant()
    {
        // This field is composed of a varying number of bits.
        // 0 - - Reserved for NCS backward compatibility
        // 1 0 - The IETF aka Leach-Salz variant (used by this class)
        // 1 1 0 Reserved, Microsoft backward compatibility
        // 1 1 1 Reserved for future definition.
        return (int) ((leastSigBits &gt;&gt;&gt; (64 - (leastSigBits &gt;&gt;&gt; 62))) &amp; (leastSigBits &gt;&gt; 63));
    }

    /**
     * 与此 UUID 相关联的时间戳值。
     *
     * &lt;p&gt;
     * 60 位的时间戳值根据此 {@code UUID} 的 time_low、time_mid 和 time_hi 字段构造。&lt;br&gt;
     * 所得到的时间戳以 100 毫微秒为单位，从 UTC（通用协调时间） 1582 年 10 月 15 日零时开始。
     *
     * &lt;p&gt;
     * 时间戳值仅在在基于时间的 UUID（其 version 类型为 1）中才有意义。&lt;br&gt;
     * 如果此 {@code UUID} 不是基于时间的 UUID，则此方法抛出 UnsupportedOperationException。
     *
     * @throws UnsupportedOperationException 如果此 {@code UUID} 不是 version 为 1 的 UUID。
     */
    public long timestamp() throws UnsupportedOperationException
    {
        checkTimeBase();
        return (mostSigBits &amp; 0x0FFFL) &lt;&lt; 48//
                | ((mostSigBits &gt;&gt; 16) &amp; 0x0FFFFL) &lt;&lt; 32//
                | mostSigBits &gt;&gt;&gt; 32;
    }

    /**
     * 与此 UUID 相关联的时钟序列值。
     *
     * &lt;p&gt;
     * 14 位的时钟序列值根据此 UUID 的 clock_seq 字段构造。clock_seq 字段用于保证在基于时间的 UUID 中的时间唯一性。
     * &lt;p&gt;
     * {@code clockSequence} 值仅在基于时间的 UUID（其 version 类型为 1）中才有意义。 如果此 UUID 不是基于时间的 UUID，则此方法抛出
     * UnsupportedOperationException。
     *
     * @return 此 {@code UUID} 的时钟序列
     *
     * @throws UnsupportedOperationException 如果此 UUID 的 version 不为 1
     */
    public int clockSequence() throws UnsupportedOperationException
    {
        checkTimeBase();
        return (int) ((leastSigBits &amp; 0x3FFF000000000000L) &gt;&gt;&gt; 48);
    }

    /**
     * 与此 UUID 相关的节点值。
     *
     * &lt;p&gt;
     * 48 位的节点值根据此 UUID 的 node 字段构造。此字段旨在用于保存机器的 IEEE 802 地址，该地址用于生成此 UUID 以保证空间唯一性。
     * &lt;p&gt;
     * 节点值仅在基于时间的 UUID（其 version 类型为 1）中才有意义。&lt;br&gt;
     * 如果此 UUID 不是基于时间的 UUID，则此方法抛出 UnsupportedOperationException。
     *
     * @return 此 {@code UUID} 的节点值
     *
     * @throws UnsupportedOperationException 如果此 UUID 的 version 不为 1
     */
    public long node() throws UnsupportedOperationException
    {
        checkTimeBase();
        return leastSigBits &amp; 0x0000FFFFFFFFFFFFL;
    }

    /**
     * 返回此{@code UUID} 的字符串表现形式。
     *
     * &lt;p&gt;
     * UUID 的字符串表示形式由此 BNF 描述：
     * 
     * &lt;pre&gt;
     * {@code
     * UUID                   = &lt;time_low&gt;-&lt;time_mid&gt;-&lt;time_high_and_version&gt;-&lt;variant_and_sequence&gt;-&lt;node&gt;
     * time_low               = 4*&lt;hexOctet&gt;
     * time_mid               = 2*&lt;hexOctet&gt;
     * time_high_and_version  = 2*&lt;hexOctet&gt;
     * variant_and_sequence   = 2*&lt;hexOctet&gt;
     * node                   = 6*&lt;hexOctet&gt;
     * hexOctet               = &lt;hexDigit&gt;&lt;hexDigit&gt;
     * hexDigit               = [0-9a-fA-F]
     * }
     * &lt;/pre&gt;
     * 
     * &lt;/blockquote&gt;
     *
     * @return 此{@code UUID} 的字符串表现形式
     * @see #toString(boolean)
     */
    @Override
    public String toString()
    {
        return toString(false);
    }

    /**
     * 返回此{@code UUID} 的字符串表现形式。
     *
     * &lt;p&gt;
     * UUID 的字符串表示形式由此 BNF 描述：
     * 
     * &lt;pre&gt;
     * {@code
     * UUID                   = &lt;time_low&gt;-&lt;time_mid&gt;-&lt;time_high_and_version&gt;-&lt;variant_and_sequence&gt;-&lt;node&gt;
     * time_low               = 4*&lt;hexOctet&gt;
     * time_mid               = 2*&lt;hexOctet&gt;
     * time_high_and_version  = 2*&lt;hexOctet&gt;
     * variant_and_sequence   = 2*&lt;hexOctet&gt;
     * node                   = 6*&lt;hexOctet&gt;
     * hexOctet               = &lt;hexDigit&gt;&lt;hexDigit&gt;
     * hexDigit               = [0-9a-fA-F]
     * }
     * &lt;/pre&gt;
     * 
     * &lt;/blockquote&gt;
     *
     * @param isSimple 是否简单模式，简单模式为不带'-'的UUID字符串
     * @return 此{@code UUID} 的字符串表现形式
     */
    public String toString(boolean isSimple)
    {
        final StringBuilder builder = new StringBuilder(isSimple ? 32 : 36);
        // time_low
        builder.append(digits(mostSigBits &gt;&gt; 32, 8));
        if (!isSimple)
        {
            builder.append('-');
        }
        // time_mid
        builder.append(digits(mostSigBits &gt;&gt; 16, 4));
        if (!isSimple)
        {
            builder.append('-');
        }
        // time_high_and_version
        builder.append(digits(mostSigBits, 4));
        if (!isSimple)
        {
            builder.append('-');
        }
        // variant_and_sequence
        builder.append(digits(leastSigBits &gt;&gt; 48, 4));
        if (!isSimple)
        {
            builder.append('-');
        }
        // node
        builder.append(digits(leastSigBits, 12));

        return builder.toString();
    }

    /**
     * 返回此 UUID 的哈希码。
     *
     * @return UUID 的哈希码值。
     */
    @Override
    public int hashCode()
    {
        long hilo = mostSigBits ^ leastSigBits;
        return ((int) (hilo &gt;&gt; 32)) ^ (int) hilo;
    }

    /**
     * 将此对象与指定对象比较。
     * &lt;p&gt;
     * 当且仅当参数不为 {@code null}、而是一个 UUID 对象、具有与此 UUID 相同的 varriant、包含相同的值（每一位均相同）时，结果才为 {@code true}。
     *
     * @param obj 要与之比较的对象
     *
     * @return 如果对象相同，则返回 {@code true}；否则返回 {@code false}
     */
    @Override
    public boolean equals(Object obj)
    {
        if ((null == obj) || (obj.getClass() != UUID.class))
        {
            return false;
        }
        UUID id = (UUID) obj;
        return (mostSigBits == id.mostSigBits &amp;&amp; leastSigBits == id.leastSigBits);
    }

    // Comparison Operations

    /**
     * 将此 UUID 与指定的 UUID 比较。
     *
     * &lt;p&gt;
     * 如果两个 UUID 不同，且第一个 UUID 的最高有效字段大于第二个 UUID 的对应字段，则第一个 UUID 大于第二个 UUID。
     *
     * @param val 与此 UUID 比较的 UUID
     *
     * @return 在此 UUID 小于、等于或大于 val 时，分别返回 -1、0 或 1。
     *
     */
    @Override
    public int compareTo(UUID val)
    {
        // The ordering is intentionally set up so that the UUIDs
        // can simply be numerically compared as two numbers
        return (this.mostSigBits &lt; val.mostSigBits ? -1 : //
                (this.mostSigBits &gt; val.mostSigBits ? 1 : //
                        (this.leastSigBits &lt; val.leastSigBits ? -1 : //
                                (this.leastSigBits &gt; val.leastSigBits ? 1 : //
                                        0))));
    }

    // -------------------------------------------------------------------------------------------------------------------
    // Private method start
    /**
     * 返回指定数字对应的hex值
     * 
     * @param val 值
     * @param digits 位
     * @return 值
     */
    private static String digits(long val, int digits)
    {
        long hi = 1L &lt;&lt; (digits * 4);
        return Long.toHexString(hi | (val &amp; (hi - 1))).substring(1);
    }

    /**
     * 检查是否为time-based版本UUID
     */
    private void checkTimeBase()
    {
        if (version() != 1)
        {
            throw new UnsupportedOperationException(&quot;Not a time-based UUID&quot;);
        }
    }

    /**
     * 获取{@link SecureRandom}，类提供加密的强随机数生成器 (RNG)
     * 
     * @return {@link SecureRandom}
     */
    public static SecureRandom getSecureRandom()
    {
        try
        {
            return SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
        }
        catch (NoSuchAlgorithmException e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * 获取随机数生成器对象&lt;br&gt;
     * ThreadLocalRandom是JDK 7之后提供并发产生随机数，能够解决多个线程发生的竞争争夺。
     * 
     * @return {@link ThreadLocalRandom}
     */
    public static ThreadLocalRandom getRandom()
    {
        return ThreadLocalRandom.current();
    }
}
</code></pre>
<h3 id="validatecodeutils">ValidateCodeUtils</h3>
<ul>
<li>ValidateCodeUtils.java</li>
</ul>
<pre><code class="language-java">/**
 * 随机生成验证码工具类
 */
public class ValidateCodeUtils {

    /**
     * 随机生成验证码
     *
     * @param length 长度为4位或者6位
     * @return
     */
    public static String generateValidateCode(int length) {
        Integer code = null;
        if (length == 4) {
            // 生成随机数，最大为9999
            code = new Random().nextInt(9999);
            if (code &lt; 1000) {
                // 保证随机数为4位数字
                code = code + 1000;
            }
        } else if (length == 6) {
            // 生成随机数，最大为999999
            code = new Random().nextInt(999999);
            if (code &lt; 100000) {
                // 保证随机数为6位数字
                code = code + 100000;
            }
        } else {
            throw new RuntimeException(&quot;只能生成4位或6位数字验证码&quot;);
        }
        return String.valueOf(code);
    }

    /**
     * 随机生成指定长度字符串验证码 带字母
     *
     * @param length 长度
     * @return
     */
    public static String generateValidateCodeString(int length) {
        Random rdm = new Random();
        String hash1 = Integer.toHexString(rdm.nextInt());
        String capstr = hash1.substring(0, length);
        return capstr;
    }
}
</code></pre>
<h3 id="beanutils">BeanUtils</h3>
<ul>
<li>BeanUtils.java</li>
</ul>
<pre><code class="language-java">public class BeanUtils {

    /**
     * 检查JavaBean所有属性字段是否非空
     *
     * @param object
     * @return true：所有属性是空  false：所有属性非空
     */
    public static boolean checkAllFilesIsNull(Object object) {
        if (null == object) {
            return true;
        }
        //通过反射获取对象所有属性字段
        Field[] fields = object.getClass().getDeclaredFields();
        for (Field field : fields) {
            //设置字段可访问
            field.setAccessible(true);
            //判断字段是否非空
            try {
                Object fieldValue = field.get(object);
                if (null != fieldValue &amp;&amp; !&quot;&quot;.equals(fieldValue.toString())) {
                    return false;
                }
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            }
        }
        return true;
    }
}
</code></pre>
<h3 id="base64utils">Base64Utils</h3>
<ul>
<li>Base64Utils.java</li>
</ul>
<pre><code class="language-java">/**
 * Base64工具类
 */
public final class Base64Utils
{
    static private final int     BASELENGTH           = 128;
    static private final int     LOOKUPLENGTH         = 64;
    static private final int     TWENTYFOURBITGROUP   = 24;
    static private final int     EIGHTBIT             = 8;
    static private final int     SIXTEENBIT           = 16;
    static private final int     FOURBYTE             = 4;
    static private final int     SIGN                 = -128;
    static private final char    PAD                  = '=';
    static final private byte[]  base64Alphabet       = new byte[BASELENGTH];
    static final private char[]  lookUpBase64Alphabet = new char[LOOKUPLENGTH];

    static
    {
        for (int i = 0; i &lt; BASELENGTH; ++i)
        {
            base64Alphabet[i] = -1;
        }
        for (int i = 'Z'; i &gt;= 'A'; i--)
        {
            base64Alphabet[i] = (byte) (i - 'A');
        }
        for (int i = 'z'; i &gt;= 'a'; i--)
        {
            base64Alphabet[i] = (byte) (i - 'a' + 26);
        }

        for (int i = '9'; i &gt;= '0'; i--)
        {
            base64Alphabet[i] = (byte) (i - '0' + 52);
        }

        base64Alphabet['+'] = 62;
        base64Alphabet['/'] = 63;

        for (int i = 0; i &lt;= 25; i++)
        {
            lookUpBase64Alphabet[i] = (char) ('A' + i);
        }

        for (int i = 26, j = 0; i &lt;= 51; i++, j++)
        {
            lookUpBase64Alphabet[i] = (char) ('a' + j);
        }

        for (int i = 52, j = 0; i &lt;= 61; i++, j++)
        {
            lookUpBase64Alphabet[i] = (char) ('0' + j);
        }
        lookUpBase64Alphabet[62] = (char) '+';
        lookUpBase64Alphabet[63] = (char) '/';
    }

    private static boolean isWhiteSpace(char octect)
    {
        return (octect == 0x20 || octect == 0xd || octect == 0xa || octect == 0x9);
    }

    private static boolean isPad(char octect)
    {
        return (octect == PAD);
    }

    private static boolean isData(char octect)
    {
        return (octect &lt; BASELENGTH &amp;&amp; base64Alphabet[octect] != -1);
    }

    /**
     * Encodes hex octects into Base64
     *
     * @param binaryData Array containing binaryData
     * @return Encoded Base64 array
     */
    public static String encode(byte[] binaryData)
    {
        if (binaryData == null)
        {
            return null;
        }

        int lengthDataBits = binaryData.length * EIGHTBIT;
        if (lengthDataBits == 0)
        {
            return &quot;&quot;;
        }

        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;
        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;
        int numberQuartet = fewerThan24bits != 0 ? numberTriplets + 1 : numberTriplets;
        char encodedData[] = null;

        encodedData = new char[numberQuartet * 4];

        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;

        int encodedIndex = 0;
        int dataIndex = 0;

        for (int i = 0; i &lt; numberTriplets; i++)
        {
            b1 = binaryData[dataIndex++];
            b2 = binaryData[dataIndex++];
            b3 = binaryData[dataIndex++];

            l = (byte) (b2 &amp; 0x0f);
            k = (byte) (b1 &amp; 0x03);

            byte val1 = ((b1 &amp; SIGN) == 0) ? (byte) (b1 &gt;&gt; 2) : (byte) ((b1) &gt;&gt; 2 ^ 0xc0);
            byte val2 = ((b2 &amp; SIGN) == 0) ? (byte) (b2 &gt;&gt; 4) : (byte) ((b2) &gt;&gt; 4 ^ 0xf0);
            byte val3 = ((b3 &amp; SIGN) == 0) ? (byte) (b3 &gt;&gt; 6) : (byte) ((b3) &gt;&gt; 6 ^ 0xfc);

            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k &lt;&lt; 4)];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[(l &lt;&lt; 2) | val3];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[b3 &amp; 0x3f];
        }

        // form integral number of 6-bit groups
        if (fewerThan24bits == EIGHTBIT)
        {
            b1 = binaryData[dataIndex];
            k = (byte) (b1 &amp; 0x03);
            byte val1 = ((b1 &amp; SIGN) == 0) ? (byte) (b1 &gt;&gt; 2) : (byte) ((b1) &gt;&gt; 2 ^ 0xc0);
            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[k &lt;&lt; 4];
            encodedData[encodedIndex++] = PAD;
            encodedData[encodedIndex++] = PAD;
        }
        else if (fewerThan24bits == SIXTEENBIT)
        {
            b1 = binaryData[dataIndex];
            b2 = binaryData[dataIndex + 1];
            l = (byte) (b2 &amp; 0x0f);
            k = (byte) (b1 &amp; 0x03);

            byte val1 = ((b1 &amp; SIGN) == 0) ? (byte) (b1 &gt;&gt; 2) : (byte) ((b1) &gt;&gt; 2 ^ 0xc0);
            byte val2 = ((b2 &amp; SIGN) == 0) ? (byte) (b2 &gt;&gt; 4) : (byte) ((b2) &gt;&gt; 4 ^ 0xf0);

            encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | (k &lt;&lt; 4)];
            encodedData[encodedIndex++] = lookUpBase64Alphabet[l &lt;&lt; 2];
            encodedData[encodedIndex++] = PAD;
        }
        return new String(encodedData);
    }

    /**
     * Decodes Base64 data into octects
     *
     * @param encoded string containing Base64 data
     * @return Array containind decoded data.
     */
    public static byte[] decode(String encoded)
    {
        if (encoded == null)
        {
            return null;
        }

        char[] base64Data = encoded.toCharArray();
        // remove white spaces
        int len = removeWhiteSpace(base64Data);

        if (len % FOURBYTE != 0)
        {
            return null;// should be divisible by four
        }

        int numberQuadruple = (len / FOURBYTE);

        if (numberQuadruple == 0)
        {
            return new byte[0];
        }

        byte decodedData[] = null;
        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;
        char d1 = 0, d2 = 0, d3 = 0, d4 = 0;

        int i = 0;
        int encodedIndex = 0;
        int dataIndex = 0;
        decodedData = new byte[(numberQuadruple) * 3];

        for (; i &lt; numberQuadruple - 1; i++)
        {

            if (!isData((d1 = base64Data[dataIndex++])) || !isData((d2 = base64Data[dataIndex++]))
                    || !isData((d3 = base64Data[dataIndex++])) || !isData((d4 = base64Data[dataIndex++])))
            {
                return null;
            } // if found &quot;no data&quot; just return null

            b1 = base64Alphabet[d1];
            b2 = base64Alphabet[d2];
            b3 = base64Alphabet[d3];
            b4 = base64Alphabet[d4];

            decodedData[encodedIndex++] = (byte) (b1 &lt;&lt; 2 | b2 &gt;&gt; 4);
            decodedData[encodedIndex++] = (byte) (((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf));
            decodedData[encodedIndex++] = (byte) (b3 &lt;&lt; 6 | b4);
        }

        if (!isData((d1 = base64Data[dataIndex++])) || !isData((d2 = base64Data[dataIndex++])))
        {
            return null;// if found &quot;no data&quot; just return null
        }

        b1 = base64Alphabet[d1];
        b2 = base64Alphabet[d2];

        d3 = base64Data[dataIndex++];
        d4 = base64Data[dataIndex++];
        if (!isData((d3)) || !isData((d4)))
        {// Check if they are PAD characters
            if (isPad(d3) &amp;&amp; isPad(d4))
            {
                if ((b2 &amp; 0xf) != 0)// last 4 bits should be zero
                {
                    return null;
                }
                byte[] tmp = new byte[i * 3 + 1];
                System.arraycopy(decodedData, 0, tmp, 0, i * 3);
                tmp[encodedIndex] = (byte) (b1 &lt;&lt; 2 | b2 &gt;&gt; 4);
                return tmp;
            }
            else if (!isPad(d3) &amp;&amp; isPad(d4))
            {
                b3 = base64Alphabet[d3];
                if ((b3 &amp; 0x3) != 0)// last 2 bits should be zero
                {
                    return null;
                }
                byte[] tmp = new byte[i * 3 + 2];
                System.arraycopy(decodedData, 0, tmp, 0, i * 3);
                tmp[encodedIndex++] = (byte) (b1 &lt;&lt; 2 | b2 &gt;&gt; 4);
                tmp[encodedIndex] = (byte) (((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf));
                return tmp;
            }
            else
            {
                return null;
            }
        }
        else
        { // No PAD e.g 3cQl
            b3 = base64Alphabet[d3];
            b4 = base64Alphabet[d4];
            decodedData[encodedIndex++] = (byte) (b1 &lt;&lt; 2 | b2 &gt;&gt; 4);
            decodedData[encodedIndex++] = (byte) (((b2 &amp; 0xf) &lt;&lt; 4) | ((b3 &gt;&gt; 2) &amp; 0xf));
            decodedData[encodedIndex++] = (byte) (b3 &lt;&lt; 6 | b4);

        }
        return decodedData;
    }

    /**
     * remove WhiteSpace from MIME containing encoded Base64 data.
     *
     * @param data the byte array of base64 data (with WS)
     * @return the new length
     */
    private static int removeWhiteSpace(char[] data)
    {
        if (data == null)
        {
            return 0;
        }

        // count characters that's not whitespace
        int newSize = 0;
        int len = data.length;
        for (int i = 0; i &lt; len; i++)
        {
            if (!isWhiteSpace(data[i]))
            {
                data[newSize++] = data[i];
            }
        }
        return newSize;
    }
}
</code></pre>
<h3 id="md5utils">Md5Utils</h3>
<ul>
<li>Md5Utils.java</li>
</ul>
<pre><code class="language-java">/**
 * Md5加密方法
 */
public class Md5Utils
{
    private static final Logger log = LoggerFactory.getLogger(Md5Utils.class);

    private static byte[] md5(String s)
    {
        MessageDigest algorithm;
        try
        {
            algorithm = MessageDigest.getInstance(&quot;MD5&quot;);
            algorithm.reset();
            algorithm.update(s.getBytes(&quot;UTF-8&quot;));
            byte[] messageDigest = algorithm.digest();
            return messageDigest;
        }
        catch (Exception e)
        {
            log.error(&quot;MD5 Error...&quot;, e);
        }
        return null;
    }

    private static final String toHex(byte hash[])
    {
        if (hash == null)
        {
            return null;
        }
        StringBuffer buf = new StringBuffer(hash.length * 2);
        int i;

        for (i = 0; i &lt; hash.length; i++)
        {
            if ((hash[i] &amp; 0xff) &lt; 0x10)
            {
                buf.append(&quot;0&quot;);
            }
            buf.append(Long.toString(hash[i] &amp; 0xff, 16));
        }
        return buf.toString();
    }

    public static String hash(String s)
    {
        try
        {
            return new String(toHex(md5(s)).getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8);
        }
        catch (Exception e)
        {
            log.error(&quot;not supported charset...{}&quot;, e);
            return s;
        }
    }
}
</code></pre>
<h3 id="doublearithutils">DoubleArithUtils</h3>
<ul>
<li>DoubleArithUtils.java</li>
</ul>
<pre><code class="language-java">/**
 * 精确的浮点数运算
 */
public class DoubleArithUtils {

    /**
     * 默认除法运算精度
     */
    private static final int DEF_DIV_SCALE = 10;

    /**
     * 这个类不能实例化
     */
    private DoubleArithUtils() {
    }

    /**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.add(b2).doubleValue();
    }

    /**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double sub(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.subtract(b2).doubleValue();
    }

    /**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double mul(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.multiply(b2).doubleValue();
    }

    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double div(double v1, double v2) {
        return div(v1, v2, DEF_DIV_SCALE);
    }

    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double div(double v1, double v2, int scale) {
        if (scale &lt; 0) {
            throw new IllegalArgumentException(
                    &quot;The scale must be a positive integer or zero&quot;);
        }
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        if (b1.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO.doubleValue();
        }
        return b1.divide(b2, scale, RoundingMode.HALF_UP).doubleValue();
    }

    /**
     * 提供精确的小数位四舍五入处理。
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double v, int scale) {
        if (scale &lt; 0) {
            throw new IllegalArgumentException(
                    &quot;The scale must be a positive integer or zero&quot;);
        }
        BigDecimal b = new BigDecimal(Double.toString(v));
        BigDecimal one = BigDecimal.ONE;
        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();
    }

}
</code></pre>
<h3 id="dateutils">DateUtils</h3>
<ul>
<li>DateUtils.java</li>
</ul>
<pre><code class="language-java">/**
 * 时间工具类
 */
public class DateUtils {

    /**
     * 获取服务器启动时间
     */
    public static Date getServerStartDate() {
        long time = ManagementFactory.getRuntimeMXBean().getStartTime();
        return new Date(time);
    }

    /**
     * 计算相差天数
     */
    public static int differentDaysByMillisecond(Date date1, Date date2) {
        return Math.abs((int) ((date2.getTime() - date1.getTime()) / (1000 * 3600 * 24)));
    }

    /**
     * 计算两个时间差
     */
    public static String getDatePoor(Date endDate, Date nowDate) {
        long nd = 1000 * 24 * 60 * 60;
        long nh = 1000 * 60 * 60;
        long nm = 1000 * 60;
        // long ns = 1000;
        // 获得两个时间的毫秒时间差异
        long diff = endDate.getTime() - nowDate.getTime();
        // 计算差多少天
        long day = diff / nd;
        // 计算差多少小时
        long hour = diff % nd / nh;
        // 计算差多少分钟
        long min = diff % nd % nh / nm;
        // 计算差多少秒//输出结果
        // long sec = diff % nd % nh % nm / ns;
        return day + &quot;天&quot; + hour + &quot;小时&quot; + min + &quot;分钟&quot;;
    }

}
</code></pre>
<h3 id="webutils">WebUtils</h3>
<ul>
<li>WebUtils.java</li>
</ul>
<pre><code class="language-java">public class WebUtils {
    /**
     * 将字符串渲染到客户端
     *
     * @param response HttpServletResponse
     * @param string   待渲染的字符串
     * @return null
     */
    public static String renderString(HttpServletResponse response, String string) {
        try {
            response.setStatus(200);
            response.setContentType(&quot;application/json&quot;);
            response.setCharacterEncoding(&quot;utf-8&quot;);
            response.getWriter().print(string);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>
<h3 id="jdbc">jdbc</h3>
<ul>
<li>jdbc.properties</li>
</ul>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/mydb?characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false
# jdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
jdbc.username=root
jdbc.password=
</code></pre>
<h3 id="druid">druid</h3>
<ul>
<li>druid.properties</li>
</ul>
<pre><code class="language-properties">pool.init=1
pool.minIdle=3
pool.maxActive=20
pool.maxWait=60000
</code></pre>
<h2 id="cloud">Cloud</h2>
<h3 id="aliyunsmsutilis">AliyunSMSUtilis</h3>
<ul>
<li>AliyunSMSUtilis.java</li>
</ul>
<pre><code class="language-xml">&lt;!--阿里云短信--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
    &lt;artifactId&gt;dysmsapi20170525&lt;/artifactId&gt;
    &lt;version&gt;2.0.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">public class AliyunSMSUtilis {

    /**
     * 使用AK&amp;SK初始化账号Client
     *
     * @param accessKeyId
     * @param accessKeySecret
     * @return Client
     * @throws Exception
     */
    public static com.aliyun.dysmsapi20170525.Client createClient(String accessKeyId, String accessKeySecret) throws Exception {
        Config config = new Config()
                // 您的 AccessKey ID
                .setAccessKeyId(String.valueOf(XXXConstant.ALIYUN_ACCESS_KEY_ID))
                // 您的 AccessKey Secret
                .setAccessKeySecret(String.valueOf(XXXConstant.ALIYUN_ACCESS_KEY_SECRET));
        // 访问的域名
        config.endpoint = XXXConstant.ALIYUN_SMS_ENDPOINT;
        return new com.aliyun.dysmsapi20170525.Client(config);
    }

    public static void sendSMS(String phoneNumber, JsonObject validateCode) throws Exception {
        // 1.发送短信
        com.aliyun.dysmsapi20170525.Client client = AliyunSMSUtilis.createClient(&quot;accessKeyId&quot;, &quot;accessKeySecret&quot;);
        SendSmsRequest sendSmsRequest = new SendSmsRequest()
                .setSignName(&quot;XXXConstant.ALIYUN_SMS_SIGNNAME&quot;)//阿里云短信测试
                .setTemplateCode(&quot;XXXConstant.ALIYUN_SMS_TEMPLATECODE&quot;)//SMS_154950909
                .setPhoneNumbers(phoneNumber)
                .setTemplateParam(validateCode.toString());// {&quot;code&quot;:&quot;xxxx&quot;}
        RuntimeOptions runtime = new RuntimeOptions();
        try {
            // 复制代码运行请自行打印 API 的返回值
            SendSmsResponse sendSmsResponse = client.sendSmsWithOptions(sendSmsRequest, runtime);
            System.out.println(&quot;****************&quot;);
            System.out.println(&quot;sendSmsResponse.body.message=&quot; + sendSmsResponse.body.message);
            System.out.println(&quot;sendSmsResponse.body.code=&quot; + sendSmsResponse.body.code);
            System.out.println(&quot;****************&quot;);
            String code = sendSmsResponse.body.code;
            if (!com.aliyun.teautil.Common.equalString(code, &quot;OK&quot;)) {
                String message = &quot;49-SMS-错误信息: &quot; + sendSmsResponse.body.message + &quot;&quot;;
                throw new RuntimeException(message);
            }
        } catch (TeaException error) {
            // 如有需要，请打印 error
            com.aliyun.teautil.Common.assertAsString(error.message);
            String message = &quot;55-SMS-TeaException&quot; + error.message;
            throw new RuntimeException(message);
        } catch (Exception _error) {
            TeaException error = new TeaException(_error.getMessage(), _error);
            // 如有需要，请打印 error
            com.aliyun.teautil.Common.assertAsString(error.message);
            String message = &quot;61-SMS-Exception&quot; + error.message;
            throw new RuntimeException(message);
        }
    }
}
</code></pre>
<h3 id="qiniuossutils">QiniuOSSUtils</h3>
<ul>
<li>QiniuOSSUtils.java</li>
</ul>
<pre><code class="language-xml">&lt;!--七牛云--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.qiniu&lt;/groupId&gt;
    &lt;artifactId&gt;qiniu-java-sdk&lt;/artifactId&gt;
    &lt;version&gt;[7.7.0, 7.10.99]&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">public class QiniuOSSUtils {

    public static String uploadFile(InputStream fileInputStream, String fileName) {
        //构造一个带指定 Region 对象的配置类
        Configuration cfg = new Configuration(Region.region0());
        //创建上传对象
        UploadManager uploadManager = new UploadManager(cfg);
        //...生成上传凭证，然后准备上传
        String accessKey = String.valueOf(XXXConstant.QINIU_ACCESS_KEY);
        String secretKey = String.valueOf(XXXConstant.QINIU_SECRET_KEY);
        String bucket = XXXConstant.QINIU_BUCKET;

        //默认不指定key的情况下，以文件内容的hash值作为文件名
        String key = fileName;

        Auth auth = Auth.create(accessKey, secretKey);
        String upToken = auth.uploadToken(bucket);

        try {
            Response response = uploadManager.put(fileInputStream, key, upToken, null, null);
            //解析上传成功的结果
            DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);
            System.out.println(&quot;39 - 七牛云上传成功 - putRet.key=&quot; + putRet.key);
            System.out.println(&quot;40 - 七牛云上传成功 - putRet.hash=&quot; + putRet.hash);
            return &quot;http://&quot;+XXXConstant.QINIU_DOMAIN+&quot;/&quot; + putRet.key;
        } catch (QiniuException ex) {
            Response r = ex.response;
            System.err.println(&quot;44 - 七牛云上传失败 - response=&quot; + r.toString());
            try {
                System.err.println(&quot;46 - 七牛云上传失败 - response.bodyString=&quot; + r.bodyString());
            } catch (QiniuException ex2) {
                //ignore
                System.err.println(&quot;49 - 七牛云上传失败 - response.ex2=&quot; + ex2.toString());
            }
        }

        return null;
    }

    public static boolean deleteFile(String fileName) {
        //构造一个带指定 Region 对象的配置类
        Configuration cfg = new Configuration(Region.region0());

        String accessKey = String.valueOf(XXXConstant.QINIU_ACCESS_KEY);
        String secretKey = String.valueOf(XXXConstant.QINIU_SECRET_KEY);
        String bucket = XXXConstant.QINIU_BUCKET;
        String key = fileName;

        Auth auth = Auth.create(accessKey, secretKey);
        BucketManager bucketManager = new BucketManager(auth, cfg);
        try {
            bucketManager.delete(bucket, key);
            return true;
        } catch (QiniuException ex) {
            //如果遇到异常，说明删除失败
            System.err.println(ex.code());
            System.err.println(ex.response.toString());
        }
        return false;
    }

}
</code></pre>
<h2 id="ssm">SSM</h2>
<h3 id="web">web</h3>
<ul>
<li>web.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--配置springMVC的编码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!-- 配置SpringMVC的前端控制器 --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;WEB-INF/dispatcher-config.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;!-- 配置Spring的监听器 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- 设置Spring的配置文件的位置和名称 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring/*.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- druid监控配置--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;!-- 允许清空统计数据 --&gt;
            &lt;param-name&gt;resetEnable&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!--配置访问监控页面登录的用户名和密码（可选），实际开发中都会配置--&gt;
        &lt;init-param&gt;
            &lt;!-- 用户名 --&gt;
            &lt;param-name&gt;loginUsername&lt;/param-name&gt;
            &lt;param-value&gt;druid&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;!-- 密码 --&gt;
            &lt;param-name&gt;loginPassword&lt;/param-name&gt;
            &lt;param-value&gt;druid&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;
        &lt;!-- 访问监控页面的映射请求，实际访问一般都在浏览器输入http://xxx/druid/index --&gt;
        &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<h3 id="log4j-config">log4j-config</h3>
<ul>
<li>log4j.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;
&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;
    &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;
        &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt;
        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
         &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \n&quot; /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;logger name=&quot;java.sql&quot;&gt;
        &lt;level value=&quot;debug&quot; /&gt;
    &lt;/logger&gt;
    &lt;logger name=&quot;org.apache.ibatis&quot;&gt;
        &lt;level value=&quot;info&quot; /&gt;
    &lt;/logger&gt;
    &lt;root&gt;
        &lt;level value=&quot;debug&quot; /&gt;
        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
</code></pre>
<h3 id="dispatcher-config">dispatcher-config</h3>
<ul>
<li>dispatcher-config.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!--扫描控制层组件--&gt;
    &lt;context:component-scan base-package=&quot;com.xxx.controller&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!-- 开启MVC的注解驱动 --&gt;
    &lt;mvc:annotation-driven/&gt;

    &lt;!-- 处理CORS --&gt;
    &lt;mvc:cors&gt;
        &lt;mvc:mapping path=&quot;/api/**&quot; allowed-origin-patterns=&quot;http://localhost:*&quot; allowed-methods=&quot;GET,POST&quot; max-age=&quot;3600&quot;/&gt;
    &lt;/mvc:cors&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="applicationcontext">applicationContext</h3>
<ul>
<li>applicationContext.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:content=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--扫描服务层组件--&gt;
    &lt;content:component-scan base-package=&quot;com.xxx.service.impl&quot;&gt;&lt;/content:component-scan&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="applicationcontext-dao">applicationContext-dao</h3>
<ul>
<li>applicationContext-dao.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:content=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 引入jdbc.properties和druid.properties --&gt;
    &lt;content:property-placeholder location=&quot;classpath:props/jdbc.properties,classpath:props/druid.properties&quot;&gt;&lt;/content:property-placeholder&gt;

    &lt;!-- 配置Druid数据源 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;
        &lt;!--数据源控制属性--&gt;
        &lt;!-- 配置初始化大小、最小、最大 --&gt;
        &lt;property name=&quot;initialSize&quot; value=&quot;${pool.init}&quot;/&gt;
        &lt;property name=&quot;minIdle&quot; value=&quot;${pool.minIdle}&quot;/&gt;
        &lt;property name=&quot;maxActive&quot; value=&quot;${pool.maxActive}&quot;/&gt;
        &lt;!-- 配置获取连接等待超时的时间 --&gt;
        &lt;property name=&quot;maxWait&quot; value=&quot;${pool.maxWait}&quot;/&gt;
        &lt;!-- 配置监控统计拦截的filters --&gt;
        &lt;property name=&quot;filters&quot; value=&quot;stat&quot;/&gt;
        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;
        &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;2000&quot;/&gt;
        &lt;!--其他配置--&gt;
        &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot;/&gt;
        &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt;
        &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot;/&gt;
        &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot;/&gt;
        &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;
        &lt;property name=&quot;maxOpenPreparedStatements&quot; value=&quot;20&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="applicationcontext-mybatis">applicationContext-mybatis</h3>
<ul>
<li>applicationContext-mybatis.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- 配置用于创建SqlSessionFactory的工厂bean，可以直接在Spring的IOC中获取SqlSessionFactory --&gt;
    &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;!-- 设置MyBatis核心配置文件的路径 --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/mybatis-config.xml&quot;&gt;
        &lt;/property&gt;
        &lt;!-- 设置数据源 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
        &lt;!--设置映射文件的路径 --&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/xxx/mapper/xml/*.xml&quot;&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- 配置mapper接口的扫描 --&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.xxx.mapper&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="applicationcontext-tx">applicationContext-tx</h3>
<ul>
<li>applicationContext-tx.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;!--配置事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- 开启事务的注解驱动 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;

&lt;/beans&gt;
</code></pre>
<h2 id="mybatis">Mybatis</h2>
<h3 id="mybatis-config">mybatis-config</h3>
<ul>
<li>mybatis-config.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;
    
    &lt;settings&gt;
        &lt;!--将表中字段的下划线自动转换为驼峰--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    
    &lt;!--设置类型别名--&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;${typeAliases_PACKAGE_NAME}&quot;/&gt;
    &lt;/typeAliases&gt;
    
    &lt;plugins&gt;
        &lt;!--设置分页插件--&gt;
        &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
            &lt;!--reasonable：分页合理化参数，默认值为false,直接根据参数进行查询。
              当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。--&gt;
            &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
    
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!--引入映射文件--&gt;
    &lt;mappers&gt;
        &lt;!--        &lt;mapper resource=&quot;mybatisdemo/mappers/UserMapper.xml&quot;/&gt;--&gt;
        &lt;!--
        以包为单位，将包下所有的映射文件引入核心配置文件
        注意：
         1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下
         2. mapper接口要和mapper映射文件的名字一致
         &lt;package name=&quot;com.example.mybatis.mapper&quot;/&gt;
        --&gt;
        &lt;!--        &lt;package name=&quot;&quot;/&gt;--&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="mybatis-mapper">mybatis-mapper</h3>
<ul>
<li>XxxxMapper.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;${NAMESPACE}&quot;&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="generatorconfig">generatorConfig</h3>
<ul>
<li>generatorConfig.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;
    &lt;!--
    targetRuntime: 执行生成的逆向工程的版本
    MyBatis3Simple: 生成基本的CRUD（清新简洁版）
    MyBatis3: 生成带条件的CRUD（奢华尊享版）
    --&gt;
    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
        &lt;!-- 数据库的连接信息 --&gt;
        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://127.0.0.1:3305/yaorange_office_ssm?characterEncoding=utf8&amp;amp;useSSL=false&quot;
                        userId=&quot;root&quot;
                        password=&quot;xxx&quot;&gt;
        &lt;/jdbcConnection&gt;
        &lt;!-- javaBean的生成策略--&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.xxx.entity&quot; targetProject=&quot;src/main/java&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;
        &lt;/javaModelGenerator&gt;
        &lt;!-- SQL映射文件的生成策略 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;com.xxx.mapper&quot;
                         targetProject=&quot;src/main/resources&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;
        &lt;/sqlMapGenerator&gt;
        &lt;!-- Mapper接口的生成策略 --&gt;
        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;
                             targetPackage=&quot;com.xxx.mapper&quot; targetProject=&quot;src/main/java&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;
        &lt;/javaClientGenerator&gt;
        &lt;!-- 逆向分析的表 --&gt;
        &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;
        &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;
        &lt;table tableName=&quot;article&quot; domainObjectName=&quot;Article&quot;/&gt;
        &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot;/&gt;
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<h2 id="spring-boot">Spring Boot</h2>
<h3 id="banner">banner</h3>
<p>banner.txt</p>
<pre><code class="language-txt">Spring Boot Version: ${spring-boot.version}
////////////////////////////////////////////////////////////////////
//                          _ooOoo_                               //
//                         o8888888o                              //
//                         88&quot; . &quot;88                              //
//                         (| ^_^ |)                              //
//                         O\  =  /O                              //
//                      ____/`---'\____                           //
//                    .'  \\|     |//  `.                         //
//                   /  \\|||  :  |||//  \                        //
//                  /  _||||| -:- |||||-  \                       //
//                  |   | \\\  -  /// |   |                       //
//                  | \_|  ''\---/''  |   |                       //
//                  \  .-\__  `-`  ___/-. /                       //
//                ___`. .'  /--.--\  `. . ___                     //
//              .&quot;&quot; '&lt;  `.___\_&lt;|&gt;_/___.'  &gt;'&quot;&quot;.                  //
//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //
//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //
//      ========`-.____`-.___\_____/___.-`____.-'========         //
//                           `=---='                              //
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //
//             佛祖保佑       永不宕机      永无BUG               //
////////////////////////////////////////////////////////////////////
</code></pre>
<h3 id="application">application</h3>
<ul>
<li>application.yaml</li>
</ul>
<pre><code class="language-yaml">spring:
  datasource:
    # 连接数据库
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3305/mydb?characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false
    username: root
    password: xxx

    # 配置druid
    druid:
      initial-size: 1
      max-active: 20
      max-wait: 6000
      min-idle: 1
      filters: stat
      stat-view-servlet:
        enabled: true
        login-password: druid
        login-username: druid
        reset-enable: true
        url-pattern: /druid/*
      test-on-borrow: true

# 日志
logging:
  level:
    com.yaorange.ssm: DEBUG
    org.springframework.jdbc.datasource: DEBUG

# mybatis
mybatis:
  mapper-locations: classpath:com/xxx/mapper/xml/*Mapper.xml
  type-aliases-package: com.yaorange.entity

# 分页合理化参数
pagehelper:
  reasonable: true
</code></pre>
<h3 id="springboot-cors-congig">SpringBoot-CORS-Congig</h3>
<ul>
<li>MvcConfiguration.java</li>
</ul>
<pre><code class="language-java">@Configuration(proxyBeanMethods = false)
public class MvcConfiguration {

    /**
     * 处理CORS
     *
     * @return
     */
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping(&quot;/api/**&quot;)
                        .allowedOriginPatterns(&quot;http://localhost:*&quot;)
                        .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)
                        .allowCredentials(true)//设置是否允许客户端跨域携带验证数据，如Cookie值
                        .maxAge(3600);
            }
        };
    }

}
</code></pre>
<h2 id="redis">Redis</h2>
<h3 id="rediscache">RedisCache</h3>
<ul>
<li>RedisCache.java</li>
</ul>
<pre><code class="language-java">/**
 * Spring Redis 工具类
 **/
@SuppressWarnings(value = {&quot;unchecked&quot;, &quot;rawtypes&quot;})
@Component
public class RedisCache {

    private final RedisTemplate redisTemplate;

    public RedisCache(RedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key   缓存的键值
     * @param value 缓存的值
     */
    public &lt;T&gt; void setCacheObject(final String key, final T value) {
        redisTemplate.opsForValue().set(key, value);
    }

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key      缓存的键值
     * @param value    缓存的值
     * @param timeout  时间
     * @param timeUnit 时间颗粒度
     */
    public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) {
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    /**
     * 设置有效时间
     *
     * @param key     Redis键
     * @param timeout 超时时间
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout) {
        return expire(key, timeout, TimeUnit.SECONDS);
    }

    /**
     * 设置有效时间
     *
     * @param key     Redis键
     * @param timeout 超时时间
     * @param unit    时间单位
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout, final TimeUnit unit) {
        return redisTemplate.expire(key, timeout, unit);
    }

    /**
     * 获取有效时间
     *
     * @param key Redis键
     * @return 有效时间
     */
    public long getExpire(final String key) {
        return redisTemplate.getExpire(key);
    }

    /**
     * 判断 key是否存在
     *
     * @param key 键
     * @return true 存在 false不存在
     */
    public Boolean hasKey(String key) {
        return redisTemplate.hasKey(key);
    }

    /**
     * 获得缓存的基本对象。
     *
     * @param key 缓存键值
     * @return 缓存键值对应的数据
     */
    public &lt;T&gt; T getCacheObject(final String key) {
        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();
        return operation.get(key);
    }

    /**
     * 删除单个对象
     *
     * @param key
     */
    public boolean deleteObject(final String key) {
        return redisTemplate.delete(key);
    }

    /**
     * 删除集合对象
     *
     * @param collection 多个对象
     * @return
     */
    public long deleteObject(final Collection collection) {
        return redisTemplate.delete(collection);
    }

    /**
     * 缓存List数据
     *
     * @param key      缓存的键值
     * @param dataList 待缓存的List数据
     * @return 缓存的对象
     */
    public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) {
        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);
        return count == null ? 0 : count;
    }

    /**
     * 获得缓存的list对象
     *
     * @param key 缓存的键值
     * @return 缓存键值对应的数据
     */
    public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) {
        return redisTemplate.opsForList().range(key, 0, -1);
    }

    /**
     * 缓存Set
     *
     * @param key     缓存键值
     * @param dataSet 缓存的数据
     * @return 缓存数据的对象
     */
    public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet) {
        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);
        Iterator&lt;T&gt; it = dataSet.iterator();
        while (it.hasNext()) {
            setOperation.add(it.next());
        }
        return setOperation;
    }

    /**
     * 获得缓存的set
     *
     * @param key
     * @return
     */
    public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) {
        return redisTemplate.opsForSet().members(key);
    }

    /**
     * 缓存Map
     *
     * @param key
     * @param dataMap
     */
    public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) {
        if (dataMap != null) {
            redisTemplate.opsForHash().putAll(key, dataMap);
        }
    }

    /**
     * 获得缓存的Map
     *
     * @param key
     * @return
     */
    public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * 往Hash中存入数据
     *
     * @param key   Redis键
     * @param hKey  Hash键
     * @param value 值
     */
    public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value) {
        redisTemplate.opsForHash().put(key, hKey, value);
    }

    /**
     * 获取Hash中的数据
     *
     * @param key  Redis键
     * @param hKey Hash键
     * @return Hash中的对象
     */
    public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) {
        HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash();
        return opsForHash.get(key, hKey);
    }

    /**
     * 删除Hash中的数据
     *
     * @param key
     * @param hKey
     */
    public void delCacheMapValue(final String key, final String hKey) {
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.delete(key, hKey);
    }

    /**
     * 获取多个Hash中的数据
     *
     * @param key   Redis键
     * @param hKeys Hash键集合
     * @return Hash对象集合
     */
    public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys) {
        return redisTemplate.opsForHash().multiGet(key, hKeys);
    }

    /**
     * 获得缓存的基本对象列表
     *
     * @param pattern 字符串前缀
     * @return 对象列表
     */
    public Collection&lt;String&gt; keys(final String pattern) {
        return redisTemplate.keys(pattern);
    }
}
</code></pre>
<h2 id="spring-security">Spring Security</h2>
<h3 id="pom">pom</h3>
<ul>
<li>Pom.xml</li>
</ul>
<pre><code class="language-xml">&lt;!-- Spring Security--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--redis依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--fastjson依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.83&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--jwt依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
    &lt;version&gt;0.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="jwtutils">JwtUtils</h3>
<ul>
<li>JwtUtils.java</li>
</ul>
<pre><code class="language-java">/**
 * JWT工具类
 */
public class JwtUtils {

    //有效期为
    //public static final Long JWT_TTL = 60 * 60 * 1000L;// 60 * 60 * 1000  一个小时
    private static final Long JWT_TTL = 60 * 60 * 24000L;// 60 * 60 * 24000  二十四个小时

    //设置秘钥明文
    private static final char[] JWT_SECRET_KEY = &quot;sangeng&quot;.toCharArray();

    public static String getUUID() {
        String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);
        return token;
    }

    /**
     * 生成jtw
     *
     * @param subject token中要存放的数据（json格式）
     * @return
     */
    public static String createJWT(String subject) {
        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间
        return builder.compact();
    }

    /**
     * 生成jtw
     *
     * @param subject   token中要存放的数据（json格式）
     * @param ttlMillis token超时时间
     * @return
     */
    public static String createJWT(String subject, Long ttlMillis) {
        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间
        return builder.compact();
    }

    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;
        SecretKey secretKey = generalKey();
        long nowMillis = System.currentTimeMillis();
        Date now = new Date(nowMillis);
        if (ttlMillis == null) {
            ttlMillis = JwtUtils.JWT_TTL;
        }
        long expMillis = nowMillis + ttlMillis;
        Date expDate = new Date(expMillis);
        return Jwts.builder()
                .setId(uuid)              //唯一的ID
                .setSubject(subject)   // 主题  可以是JSON数据
                .setIssuer(&quot;admin&quot;)     // 签发者
                .setIssuedAt(now)      // 签发时间
                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥
                .setExpiration(expDate);
    }

    /**
     * 创建token
     *
     * @param id
     * @param subject
     * @param ttlMillis
     * @return
     */
    public static String createJWT(String id, String subject, Long ttlMillis) {
        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间
        return builder.compact();
    }

    /**
     * 生成加密后的秘钥 secretKey
     *
     * @return
     */
    public static SecretKey generalKey() {
        byte[] encodedKey = Base64.getDecoder().decode(new String(JWT_SECRET_KEY));
        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;);
        return key;
    }

    /**
     * 解析
     *
     * @param jwt
     * @return
     * @throws Exception
     */
    public static Claims parseJWT(String jwt) throws Exception {
        SecretKey secretKey = generalKey();
        return Jwts.parser()
                .setSigningKey(secretKey)
                .parseClaimsJws(jwt)
                .getBody();
    }

    public static void main(String[] args) throws Exception {
        String token = JwtUtils.createJWT(&quot;cook&quot;);
        Claims claims = parseJWT(token);
        System.out.println(token);//eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI3YTI5ZTQ4OThjMmI0YjMwOTczNTc4YmZjMmQwMWE2NSIsInN1YiI6ImNvb2siLCJpc3MiOiJhZG1pbiIsImlhdCI6MTY2MTE4NzM5MywiZXhwIjoxNjYxMjczNzkzfQ.dUO663dn5SIndbPgwIedXmY2YazG4WqD4rYzgGrtHXM
        System.out.println(claims);//{jti=7a29e4898c2b4b30973578bfc2d01a65, sub=cook, iss=admin, iat=1661187393, exp=1661273793}
    }

}
</code></pre>
<h3 id="fastjsonredisserializer">FastJsonRedisSerializer</h3>
<ul>
<li>FastJsonRedisSerializer.java</li>
</ul>
<pre><code class="language-java">/**
 * Redis使用FastJson序列化
 */
public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt; {

    public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);

    private Class&lt;T&gt; clazz;

    static {
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
    }

    public FastJsonRedisSerializer(Class&lt;T&gt; clazz) {
        super();
        this.clazz = clazz;
    }

    @Override
    public byte[] serialize(T t) throws SerializationException {
        if (t == null) {
            return new byte[0];
        }
        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);
    }

    @Override
    public T deserialize(byte[] bytes) throws SerializationException {
        if (bytes == null || bytes.length &lt;= 0) {
            return null;
        }
        String str = new String(bytes, DEFAULT_CHARSET);

        return JSON.parseObject(str, clazz);
    }
    
    protected JavaType getJavaType(Class&lt;?&gt; clazz) {
        return TypeFactory.defaultInstance().constructType(clazz);
    }
}
</code></pre>
<h3 id="webutils-2">WebUtils</h3>
<ul>
<li>WebUtils.java</li>
</ul>
<pre><code class="language-java">public class WebUtils {
    /**
     * 将字符串渲染到客户端
     *
     * @param response 渲染对象
     * @param string   待渲染的字符串
     * @return null
     */
    public static String renderString(HttpServletResponse response, String string) {
        try {
            response.setStatus(200);
            response.setContentType(&quot;application/json&quot;);
            response.setCharacterEncoding(&quot;utf-8&quot;);
            response.getWriter().print(string);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>
<h3 id="redisconfig">RedisConfig</h3>
<ul>
<li>RedisConfig.java</li>
</ul>
<pre><code class="language-java">@Configuration
public class RedisConfig {

    @Bean
    @SuppressWarnings(value = {&quot;unchecked&quot;, &quot;rawtypes&quot;})
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);

        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);

        // 使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(serializer);

        // Hash的key也采用StringRedisSerializer的序列化方式
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(serializer);

        template.afterPropertiesSet();

        // 开启AutoType，处理异常，com.alibaba.fastjson.JSONException: autoType is not support. org.springframework.security.core.authority.SimpleGrantedAuthority
        // 建议使用这种方式，小范围指定白名单
        ParserConfig.getGlobalInstance().addAccept(&quot;org.springframework.security.core.authority.&quot;);
        TypeUtils.addMapping(&quot;org.springframework.security.core.authority.SimpleGrantedAuthority&quot;,
                SimpleGrantedAuthority.class);

        return template;
    }
}
</code></pre>
<h3 id="userdetailsbean">UserDetailsBean</h3>
<p>UserDetailsBean.java</p>
<pre><code class="language-java">/**
 * 登录用户 UserDetails
 */
public class UserDetailsBean implements UserDetails {

    /**
     * 封装用户信息
     */
    private User user;

    /**
     * 封装用户权限信息
     */
    private List&lt;String&gt; authorityList;

    private List&lt;SimpleGrantedAuthority&gt; authorities;

    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        // 写法一：
//        List&lt;SimpleGrantedAuthority&gt; authorities = authorities.stream().map(s -&gt; new SimpleGrantedAuthority(s)).collect(Collectors.toList());
        // 写法二：
        authorities = authorityList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());
        // 写法三：
//        Collection&lt;SimpleGrantedAuthority&gt; authorities = null;
//        for (String s : authorities) {
//            authorities.add(new SimpleGrantedAuthority(s));
//        }
        return authorities;
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUserName();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return user.getStatus().equals(&quot;0&quot;);
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public List&lt;String&gt; getAuthorityList() {
        return authorityList;
    }

    public void setAuthorityList(List&lt;String&gt; authorityList) {
        this.authorityList = authorityList;
    }

    public void setAuthorities(List&lt;SimpleGrantedAuthority&gt; authorities) {
        this.authorities = authorities;
    }

    public UserDetailsBean() {
    }

    public UserDetailsBean(User user, List&lt;String&gt; authorityList) {
        this.user = user;
        this.authorityList = authorityList;
    }

}
</code></pre>
<h3 id="userdetailsserviceimpl">UserDetailsServiceImpl</h3>
<p>UserDetailsServiceImpl.java</p>
<pre><code class="language-java">@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserMapper userMapper;

    /**
     * 从数据库中查出用户信息，
     * 供 AuthenticationProvider 进行密码比对
     *
     * @param username 由 AuthenticationProvider 提供，也就是前端传入的username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1、根据用户名查询用户信息
        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.eq(User::getUserName, username);
        User user = userMapper.selectOne(queryWrapper);
        // 2、如果查询不到数据就通过抛出异常来给出提示
        if (null == user) {
            throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;);
        }
        // 3、根据用户名查询权限信息，将其添加到 UserDetailsBean 中的 authorities
        List&lt;String&gt; list = userMapper.selectPermsByUserId(user.getId());
        // 4、将查出的用户信息，权限信息，封装成UserDetails（UserDetailsBean）对象返回
        return new UserDetailsBean(user, list);
    }
}
</code></pre>
<h3 id="jwtauthenticationtokenfilter">JwtAuthenticationTokenFilter</h3>
<ul>
<li>JwtAuthenticationTokenFilter.java</li>
</ul>
<pre><code class="language-java">@Component
@RequiredArgsConstructor
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    private final RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //获取token
        String token = request.getHeader(&quot;token&quot;);
        //判断token是否非空
        if (StringUtils.isEmpty(token)) {
            //为空，则直接放行，请求会去下一个登录接口
            filterChain.doFilter(request, response);
            return;
        }
        //不为空，则解析token获取userid
        String userId;
        try {
            Claims jwt = JwtUtils.parseJWT(token);
            userId = jwt.getSubject();
        } catch (Exception e) {
            //解析失败，提示token非法
            // 方法一：
            // 注意，此时需要自定义认证异常处理，否则只会响应403的空白错误；
            // 同时，我发现这里无论抛出哪个AuthenticationException的异常，无聊怎么传递消息，
            // 在自定义认证异常时，异常消息都会被覆盖成&quot;Full authentication is required to access this resource&quot;
            // 所以，这里还是采用第二种方法处理异常。
//            throw new AuthenticationServiceException(&quot;Token非法&quot;,new Throwable(&quot;Token非法&quot;));
            //方法二：
            request.getRequestDispatcher(&quot;/jwtFilterException/&quot; + &quot;Token非法&quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //解析成功，通过userid从Redis缓存中获取 UserDetailsBean
        UserDetailsBean userDetailsBean = redisCache.getCacheObject(&quot;login:&quot; + userId);
        //获取不了，提示会话失效，请重新登录
        if (null == userDetailsBean) {
            //解析失败，提示token非法
            request.getRequestDispatcher(&quot;/jwtFilterException/&quot; + &quot;会话失效，请重新登录&quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //获取的了，将 UserDetailsBean 封装成 authentication 对象，显式地为用户去注册身份认证
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetailsBean, null, userDetailsBean.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authentication);
        //放行
        filterChain.doFilter(request, response);
    }

}
</code></pre>
<h3 id="jwtfilterexceptioncontroller">JwtFilterExceptionController</h3>
<p>JwtFilterExceptionController.java</p>
<pre><code class="language-java">@RestController
public class JwtFilterExceptionController {

    @RequestMapping(&quot;/jwtFilterException/{message}&quot;)
    public Result jwtFilterException(@PathVariable(&quot;message&quot;) String message) {
        return Result.error(message);
    }

}
</code></pre>
<h3 id="accessdeniedhandlerimpl">AccessDeniedHandlerImpl</h3>
<p>AccessDeniedHandlerImpl.java</p>
<pre><code class="language-java">@Component
public class AccessDeniedHandlerImpl implements AccessDeniedHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        Result&lt;Object&gt; result = Result.error(HttpStatus.FORBIDDEN.value(), accessDeniedException.getMessage());
        String json = JSON.toJSONString(result);
        WebUtils.renderString(response, json);
    }

}
</code></pre>
<h3 id="authenticationentrypointimpl">AuthenticationEntryPointImpl</h3>
<p>AuthenticationEntryPointImpl.java</p>
<pre><code class="language-java">@Component
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {
        Result&lt;Object&gt; result = Result.error(HttpStatus.UNAUTHORIZED.value(), e.getMessage());
        String json = JSON.toJSONString(result);
        WebUtils.renderString(response, json);
    }
    
}
</code></pre>
<h3 id="securityconfig">SecurityConfig</h3>
<ul>
<li>SecurityConfig.java</li>
</ul>
<pre><code class="language-java">@Configuration
@RequiredArgsConstructor
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;

    private final AuthenticationEntryPoint authenticationEntryPoint;

    private final AccessDeniedHandler accessDeniedHandler;

    /**
     * 替换默认密码编码器
     * 使用BCryptPasswordEncoder
     *
     * @return
     */
    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                // 关闭csrf
                .csrf().disable()
                // 不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // 对于登录接口 允许匿名访问
                .authorizeRequests()
                .antMatchers(&quot;/user/login&quot;).anonymous()
                // 除上面外的所有请求全部需要鉴权认证
                .anyRequest().authenticated();

        // 把 JWT 过滤器添加到过滤器链中
        http
                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
        
        // 配置自定义的认证和授权异常处理类
        http
                .exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);
        // 允许跨域
        http.cors();
    }

    /**
     * 在容器中注入AuthenticationManager
     * 供登录接口的Service调用
     *
     * @return
     * @throws Exception
     */
    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }

}
</code></pre>
<h1 id="vue">Vue</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Security笔记]]></title>
        <id>https://kuangyang828.github.io/spring-security-bi-ji/</id>
        <link href="https://kuangyang828.github.io/spring-security-bi-ji/">
        </link>
        <updated>2022-08-19T01:23:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springsecurity从入门到精通">SpringSecurity从入门到精通</h1>
<h2 id="0简介">0.简介</h2>
<p><strong>Spring Security</strong> 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架<strong>Shiro</strong>，它提供了更丰富的功能，社区资源也比Shiro丰富。</p>
<p>一般来说中大型的项目都是使用<strong>SpringSecurity</strong> 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。</p>
<p>一般Web应用的需要进行<strong>认证</strong>和<strong>授权</strong>。</p>
<p>①<strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p>
<p>②<strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p>
<p>而认证和授权也是SpringSecurity作为安全框架的核心功能。</p>
<h2 id="1快速入门">1.快速入门</h2>
<h3 id="11-准备工作">1.1 准备工作</h3>
<p>我们先要搭建一个简单的SpringBoot工程</p>
<h4 id="1-添加依赖">① 添加依赖</h4>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.5.0&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h4 id="2-创建启动类">② 创建启动类</h4>
<pre><code class="language-java">@SpringBootApplication
public class SecurityApplication {

    public static void main(String[] args) {
        SpringApplication.run(SecurityApplication.class,args);
    }
}

</code></pre>
<h4 id="3-创建controller">③ 创建Controller</h4>
<pre><code class="language-java">import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @RequestMapping(&quot;/hello&quot;)
    public String hello(){
        return &quot;hello&quot;;
    }
}
</code></pre>
<h3 id="12-引入springsecurity">1.2 引入SpringSecurity</h3>
<p>在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>
<p>引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。</p>
</li>
<li>
<p>必须登陆之后才能对接口进行访问。</p>
</li>
</ul>
<h2 id="2认证">2.认证</h2>
<h3 id="21-登陆校验流程">2.1 登陆校验流程</h3>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220817165509.png" alt="" loading="lazy"></figure>
<h3 id="22-原理初探">2.2 原理初探</h3>
<p>想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。</p>
<h4 id="221-springsecurity完整流程">2.2.1 SpringSecurity完整流程</h4>
<p>SpringSecurity的原理其实就是一个<strong>过滤器链</strong>，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220817165658.png" alt="" loading="lazy"></figure>
<p>图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。</p>
<ul>
<li>
<p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p>
</li>
<li>
<p>**ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>
</li>
<li>
<p>**FilterSecurityInterceptor：**负责权限校验的过滤器。</p>
</li>
</ul>
<p>​</p>
<p>我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220817165723.png" alt="" loading="lazy"></figure>
<h4 id="222-认证流程详解">2.2.2 认证流程详解</h4>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220817165917.png" alt="" loading="lazy"></figure>
<p>概念速查:</p>
<p><strong>Authentication接口</strong>: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>
<p><strong>AuthenticationManager接口</strong>：定义了认证Authentication的方法</p>
<p><strong>UserDetailsService接口</strong>：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>
<p><strong>UserDetails接口</strong>：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>
<h3 id="23-解决问题">2.3 解决问题</h3>
<h4 id="231-思路分析">2.3.1 思路分析</h4>
<p>登录</p>
<pre><code>① 自定义 UserDetailsService 的实现类 UserDetailsServiceImpl

			在这个实现类中去查询数据库，来判断密码是否正确

② 自定义登录接口  

			调用 ProviderManager 的方法进行认证 如果认证通过生成jwt

			把用户信息存入redis中
</code></pre>
<p>校验：</p>
<pre><code class="language-txt">① 定义Jwt认证过滤器

			获取token

			解析token获取其中的userid

			从Redis中获取用户信息

			存入SecurityContextHolder
</code></pre>
<h4 id="232-准备工作">2.3.2 准备工作</h4>
<p>① 添加依赖</p>
<pre><code class="language-xml">&lt;!--redis依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--fastjson依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
     &lt;version&gt;1.2.83&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--jwt依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
    &lt;version&gt;0.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>② 添加Redis相关配置</p>
<pre><code class="language-java">import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.TypeFactory;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.SerializationException;
import com.alibaba.fastjson.parser.ParserConfig;
import org.springframework.util.Assert;
import java.nio.charset.Charset;

/**
 * Redis使用FastJson序列化
 * 
 * @author sg
 */
public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;
{

    public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);

    private Class&lt;T&gt; clazz;

    static
    {
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
    }

    public FastJsonRedisSerializer(Class&lt;T&gt; clazz)
    {
        super();
        this.clazz = clazz;
    }

    @Override
    public byte[] serialize(T t) throws SerializationException
    {
        if (t == null)
        {
            return new byte[0];
        }
        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);
    }

    @Override
    public T deserialize(byte[] bytes) throws SerializationException
    {
        if (bytes == null || bytes.length &lt;= 0)
        {
            return null;
        }
        String str = new String(bytes, DEFAULT_CHARSET);

        return JSON.parseObject(str, clazz);
    }


    protected JavaType getJavaType(Class&lt;?&gt; clazz)
    {
        return TypeFactory.defaultInstance().constructType(clazz);
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
public class RedisConfig {

    @Bean
    @SuppressWarnings(value = {&quot;unchecked&quot;, &quot;rawtypes&quot;})
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);

        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);

        // 使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(serializer);

        // Hash的key也采用StringRedisSerializer的序列化方式
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(serializer);

        template.afterPropertiesSet();

        // 开启AutoType，处理异常，com.alibaba.fastjson.JSONException: autoType is not support. org.springframework.security.core.authority.SimpleGrantedAuthority
        // 建议使用这种方式，小范围指定白名单
        ParserConfig.getGlobalInstance().addAccept(&quot;org.springframework.security.core.authority.&quot;);
        TypeUtils.addMapping(&quot;org.springframework.security.core.authority.SimpleGrantedAuthority&quot;,
                SimpleGrantedAuthority.class);

        return template;
    }
}
</code></pre>
<p>③ 响应类</p>
<pre><code class="language-java">import com.fasterxml.jackson.annotation.JsonInclude;

/**
 * @Author 三更  B站： https://space.bilibili.com/663528522
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ResponseResult&lt;T&gt; {
    /**
     * 状态码
     */
    private Integer code;
    /**
     * 提示信息，如果有错误时，前端可以获取该字段进行提示
     */
    private String msg;
    /**
     * 查询到的结果数据，
     */
    private T data;

    public ResponseResult(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public ResponseResult(Integer code, T data) {
        this.code = code;
        this.data = data;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public ResponseResult(Integer code, String msg, T data) {
        this.code = code;
        this.msg = msg;
        this.data = data;
    }
}
</code></pre>
<p>④ JWT 工具类</p>
<pre><code class="language-java">/**
 * JWT工具类
 */
public class JwtUtils {

    //有效期为
    //public static final Long JWT_TTL = 60 * 60 * 1000L;// 60 * 60 * 1000  一个小时
    private static final Long JWT_TTL = 60 * 60 * 24000L;// 60 * 60 * 24000  二十四个小时

    //设置秘钥明文
    private static final char[] JWT_SECRET_KEY = &quot;sangeng&quot;.toCharArray();

    public static String getUUID() {
        String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);
        return token;
    }

    /**
     * 生成jtw
     *
     * @param subject token中要存放的数据（json格式）
     * @return
     */
    public static String createJWT(String subject) {
        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间
        return builder.compact();
    }

    /**
     * 生成jtw
     *
     * @param subject   token中要存放的数据（json格式）
     * @param ttlMillis token超时时间
     * @return
     */
    public static String createJWT(String subject, Long ttlMillis) {
        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间
        return builder.compact();
    }

    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) {
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;
        SecretKey secretKey = generalKey();
        long nowMillis = System.currentTimeMillis();
        Date now = new Date(nowMillis);
        if (ttlMillis == null) {
            ttlMillis = JwtUtils.JWT_TTL;
        }
        long expMillis = nowMillis + ttlMillis;
        Date expDate = new Date(expMillis);
        return Jwts.builder()
                .setId(uuid)              //唯一的ID
                .setSubject(subject)   // 主题  可以是JSON数据
                .setIssuer(&quot;admin&quot;)     // 签发者
                .setIssuedAt(now)      // 签发时间
                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥
                .setExpiration(expDate);
    }

    /**
     * 创建token
     *
     * @param id
     * @param subject
     * @param ttlMillis
     * @return
     */
    public static String createJWT(String id, String subject, Long ttlMillis) {
        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间
        return builder.compact();
    }

    /**
     * 生成加密后的秘钥 secretKey
     *
     * @return
     */
    public static SecretKey generalKey() {
        byte[] encodedKey = Base64.getDecoder().decode(new String(JWT_SECRET_KEY));
        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;);
        return key;
    }

    /**
     * 解析
     *
     * @param jwt
     * @return
     * @throws Exception
     */
    public static Claims parseJWT(String jwt) throws Exception {
        SecretKey secretKey = generalKey();
        return Jwts.parser()
                .setSigningKey(secretKey)
                .parseClaimsJws(jwt)
                .getBody();
    }

    public static void main(String[] args) throws Exception {
        String token = JwtUtils.createJWT(&quot;cook&quot;);
        Claims claims = parseJWT(token);
        System.out.println(token);//eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI3YTI5ZTQ4OThjMmI0YjMwOTczNTc4YmZjMmQwMWE2NSIsInN1YiI6ImNvb2siLCJpc3MiOiJhZG1pbiIsImlhdCI6MTY2MTE4NzM5MywiZXhwIjoxNjYxMjczNzkzfQ.dUO663dn5SIndbPgwIedXmY2YazG4WqD4rYzgGrtHXM
        System.out.println(claims);//{jti=7a29e4898c2b4b30973578bfc2d01a65, sub=cook, iss=admin, iat=1661187393, exp=1661273793}
    }

}
</code></pre>
<pre><code class="language-java">import java.util.*;
import java.util.concurrent.TimeUnit;

@SuppressWarnings(value = { &quot;unchecked&quot;, &quot;rawtypes&quot; })
@Component
public class RedisCache
{
    @Autowired
    public RedisTemplate redisTemplate;

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key 缓存的键值
     * @param value 缓存的值
     */
    public &lt;T&gt; void setCacheObject(final String key, final T value)
    {
        redisTemplate.opsForValue().set(key, value);
    }

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key 缓存的键值
     * @param value 缓存的值
     * @param timeout 时间
     * @param timeUnit 时间颗粒度
     */
    public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)
    {
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    }

    /**
     * 设置有效时间
     *
     * @param key Redis键
     * @param timeout 超时时间
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout)
    {
        return expire(key, timeout, TimeUnit.SECONDS);
    }

    /**
     * 设置有效时间
     *
     * @param key Redis键
     * @param timeout 超时时间
     * @param unit 时间单位
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout, final TimeUnit unit)
    {
        return redisTemplate.expire(key, timeout, unit);
    }

    /**
     * 获得缓存的基本对象。
     *
     * @param key 缓存键值
     * @return 缓存键值对应的数据
     */
    public &lt;T&gt; T getCacheObject(final String key)
    {
        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();
        return operation.get(key);
    }

    /**
     * 删除单个对象
     *
     * @param key
     */
    public boolean deleteObject(final String key)
    {
        return redisTemplate.delete(key);
    }

    /**
     * 删除集合对象
     *
     * @param collection 多个对象
     * @return
     */
    public long deleteObject(final Collection collection)
    {
        return redisTemplate.delete(collection);
    }

    /**
     * 缓存List数据
     *
     * @param key 缓存的键值
     * @param dataList 待缓存的List数据
     * @return 缓存的对象
     */
    public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList)
    {
        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);
        return count == null ? 0 : count;
    }

    /**
     * 获得缓存的list对象
     *
     * @param key 缓存的键值
     * @return 缓存键值对应的数据
     */
    public &lt;T&gt; List&lt;T&gt; getCacheList(final String key)
    {
        return redisTemplate.opsForList().range(key, 0, -1);
    }

    /**
     * 缓存Set
     *
     * @param key 缓存键值
     * @param dataSet 缓存的数据
     * @return 缓存数据的对象
     */
    public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet)
    {
        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);
        Iterator&lt;T&gt; it = dataSet.iterator();
        while (it.hasNext())
        {
            setOperation.add(it.next());
        }
        return setOperation;
    }

    /**
     * 获得缓存的set
     *
     * @param key
     * @return
     */
    public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key)
    {
        return redisTemplate.opsForSet().members(key);
    }

    /**
     * 缓存Map
     *
     * @param key
     * @param dataMap
     */
    public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap)
    {
        if (dataMap != null) {
            redisTemplate.opsForHash().putAll(key, dataMap);
        }
    }

    /**
     * 获得缓存的Map
     *
     * @param key
     * @return
     */
    public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key)
    {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * 往Hash中存入数据
     *
     * @param key Redis键
     * @param hKey Hash键
     * @param value 值
     */
    public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value)
    {
        redisTemplate.opsForHash().put(key, hKey, value);
    }

    /**
     * 获取Hash中的数据
     *
     * @param key Redis键
     * @param hKey Hash键
     * @return Hash中的对象
     */
    public &lt;T&gt; T getCacheMapValue(final String key, final String hKey)
    {
        HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash();
        return opsForHash.get(key, hKey);
    }

    /**
     * 删除Hash中的数据
     * 
     * @param key
     * @param hkey
     */
    public void delCacheMapValue(final String key, final String hkey)
    {
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.delete(key, hkey);
    }

    /**
     * 获取多个Hash中的数据
     *
     * @param key Redis键
     * @param hKeys Hash键集合
     * @return Hash对象集合
     */
    public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys)
    {
        return redisTemplate.opsForHash().multiGet(key, hKeys);
    }

    /**
     * 获得缓存的基本对象列表
     *
     * @param pattern 字符串前缀
     * @return 对象列表
     */
    public Collection&lt;String&gt; keys(final String pattern)
    {
        return redisTemplate.keys(pattern);
    }
}
</code></pre>
<pre><code class="language-java">import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class WebUtils
{
    /**
     * 将字符串渲染到客户端
     * 
     * @param response 渲染对象
     * @param string 待渲染的字符串
     * @return null
     */
    public static String renderString(HttpServletResponse response, String string) {
        try
        {
            response.setStatus(200);
            response.setContentType(&quot;application/json&quot;);
            response.setCharacterEncoding(&quot;utf-8&quot;);
            response.getWriter().print(string);
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>
<p>⑤实体类</p>
<pre><code class="language-java">import java.io.Serializable;
import java.util.Date;


/**
 * 用户表(User)实体类
 *
 * @author 三更
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User implements Serializable {
    private static final long serialVersionUID = -40356785423868312L;
    
    /**
    * 主键
    */
    private Long id;
    /**
    * 用户名
    */
    private String userName;
    /**
    * 昵称
    */
    private String nickName;
    /**
    * 密码
    */
    private String password;
    /**
    * 账号状态（0正常 1停用）
    */
    private String status;
    /**
    * 邮箱
    */
    private String email;
    /**
    * 手机号
    */
    private String phonenumber;
    /**
    * 用户性别（0男，1女，2未知）
    */
    private String sex;
    /**
    * 头像
    */
    private String avatar;
    /**
    * 用户类型（0管理员，1普通用户）
    */
    private String userType;
    /**
    * 创建人的用户id
    */
    private Long createBy;
    /**
    * 创建时间
    */
    private Date createTime;
    /**
    * 更新人
    */
    private Long updateBy;
    /**
    * 更新时间
    */
    private Date updateTime;
    /**
    * 删除标志（0代表未删除，1代表已删除）
    */
    private Integer delFlag;
}
</code></pre>
<h4 id="233-实现">2.3.3 实现</h4>
<h5 id="2331-数据库校验用户">2.3.3.1 数据库校验用户</h5>
<ul>
<li>从之前的分析我们可以知道，我们可以自定义一个UserDetailsServiceImpl,</li>
<li>让SpringSecurity使用我们的UserDetailsServiceImpl。</li>
<li>我们自己的UserDetailsServiceImpl可以从数据库中查询用户名和密码。</li>
</ul>
<h6 id="准备工作">准备工作</h6>
<p>我们先创建一个用户表， 建表语句如下：</p>
<pre><code class="language-mysql">CREATE TABLE `sys_user` (
  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` VARCHAR(64) NOT NULL DEFAULT 'NULL' COMMENT '用户名',
  `nick_name` VARCHAR(64) NOT NULL DEFAULT 'NULL' COMMENT '昵称',
  `password` VARCHAR(64) NOT NULL DEFAULT 'NULL' COMMENT '密码',
  `status` CHAR(1) DEFAULT '0' COMMENT '账号状态（0正常 1停用）',
  `email` VARCHAR(64) DEFAULT NULL COMMENT '邮箱',
  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT '手机号',
  `sex` CHAR(1) DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',
  `avatar` VARCHAR(128) DEFAULT NULL COMMENT '头像',
  `user_type` CHAR(1) NOT NULL DEFAULT '1' COMMENT '用户类型（0管理员，1普通用户）',
  `create_by` BIGINT(20) DEFAULT NULL COMMENT '创建人的用户id',
  `create_time` DATETIME DEFAULT NULL COMMENT '创建时间',
  `update_by` BIGINT(20) DEFAULT NULL COMMENT '更新人',
  `update_time` DATETIME DEFAULT NULL COMMENT '更新时间',
  `del_flag` INT(11) DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表'
</code></pre>
<p>引入MybatisPuls和mysql驱动的依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.5.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>配置数据库信息</p>
<pre><code class="language-yml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
</code></pre>
<p>定义Mapper接口</p>
<pre><code class="language-java">public interface UserMapper extends BaseMapper&lt;User&gt; {
}
</code></pre>
<p>修改User实体类</p>
<pre><code class="language-java">类名上加@TableName(value = &quot;sys_user&quot;) ,delFlag字段上加 @TableLogic
</code></pre>
<p>配置Mapper扫描</p>
<pre><code class="language-java">@SpringBootApplication
@MapperScan(&quot;com.sangeng.mapper&quot;)
public class SimpleSecurityApplication {
    public static void main(String[] args) {
        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);
        System.out.println(run);
    }
}
</code></pre>
<p>添加junit依赖</p>
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>测试 MyBatis-Plus 是否能正常使用</p>
<pre><code class="language-java">/**
 * @Author 三更  B站： https://space.bilibili.com/663528522
 */
@SpringBootTest
public class MapperTest {

    @Autowired
    private UserMapper userMapper;

    @Test
    public void testUserMapper(){
        List&lt;User&gt; users = userMapper.selectList(null);
        System.out.println(users);
    }
}
</code></pre>
<h6 id="核心代码实现">核心代码实现</h6>
<h6 id="1-创建userdetailsservice的实现类">① 创建UserDetailsService的实现类</h6>
<ul>
<li>重写其中的方法。来从数据库中查询用户信息</li>
</ul>
<p>1）UserDetailsServiceImpl</p>
<pre><code class="language-java">@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserMapper userMapper;

    /**
     * 从数据库中查出用户信息，
     * 供 AuthenticationProvider 进行密码比对
     *
     * @param username 由 AuthenticationProvider 提供，也就是前端传入的username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1、根据用户名查询用户信息
        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.eq(User::getUserName, username);
        User user = userMapper.selectOne(queryWrapper);
        // 2、如果查询不到数据就通过抛出异常来给出提示
        if (null == user) {
            throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;);
        }
        //TODO 3、根据用户名查询权限信息，将其添加到 UserDetailsBean 中的 authorities

        // 4、将查出的用户信息，权限信息，封装成UserDetails（UserDetailsBean）对象返回
        return new UserDetailsBean(user);
    }
}
</code></pre>
<p>2）UserDetailsBean</p>
<p>因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。</p>
<pre><code class="language-java">/**
 * 登录用户 UserDetails
 */
public class UserDetailsBean implements UserDetails {

    /**
     * 封装用户信息
     */
    private User user;

    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        return null;
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUserName();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return user.getStatus().equals(&quot;0&quot;);
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public UserDetailsBean() {
    }

    public UserDetailsBean(User user) {
        this.user = user;
    }
}
</code></pre>
<h6 id="2-配置密码编码器">② 配置密码编码器</h6>
<p><code>AuthenticationProvider</code>，在根据返回的UserDetails进行密码比对时：</p>
<ul>
<li>
<p>默认使用的PasswordEncoder要求数据库中的密码格式为：{type}password 。它会根据 type 去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换默认的 PasswordEncoder。</p>
</li>
<li>
<p>我们一般使用SpringSecurity推荐的的<mark>BCryptPasswordEncoder</mark>，</p>
</li>
<li>
<p>所以我们可以定义一个SpringSecurity的配置类，new 一个 BCryptPasswordEncoder，然后使用 @Bean 注解将其注入 Spring  容器，替换默认的密码编码器。</p>
</li>
</ul>
<pre><code class="language-java">@Configuration
public class SecurityConfig {

    /**
     * 替换默认密码编码器
     * 使用BCryptPasswordEncoder
     * @return
     */
    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder(){
        return new BCryptPasswordEncoder();
    }

}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>如果你想让用户的密码是<code>明文存储</code>，</p>
<p>则不需要替换默认的密码编码器，</p>
<p>只需在密码前加<code>{noop}</code>，这里的 noop 就是指定加密类型为明文</p>
<p><code>当然，在真的项目中谁会把密码明文存储呢？</code></p>
<p>例如</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220817203822.png" alt="" loading="lazy"></figure>
<p>这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。</p>
</blockquote>
<h6 id="3-测试">③ 测试</h6>
<ul>
<li>使用浏览器，通过默认的认证页面测试</li>
</ul>
<h5 id="2333-自定义登陆接口">2.3.3.3 自定义登陆接口</h5>
<ul>
<li>
<p>接下我们需要<mark>自定义登陆接口</mark>，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。</p>
</li>
<li>
<p>在接口中调用<mark>AuthenticationManager</mark>的==authenticate()==方法来进行用户认证，所以还需要配置类中把AuthenticationManager注入容器。</p>
</li>
<li>
<p>认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入Redis，可以把用户id作为key。</p>
</li>
</ul>
<h6 id="1-创建登录接口的-controller">① 创建登录接口的 Controller</h6>
<ul>
<li>LoginController</li>
</ul>
<pre><code class="language-java">@RestController
public class LoginController {

    @Autowired
    private LoginServcie loginServcie;

    @PostMapping(&quot;/user/login&quot;)
    public ResponseResult login(@RequestBody User user){
        return loginServcie.login(user);
    }
  
}
</code></pre>
<h6 id="2-给登录接口放行同时为-spring-容器注入-authenticationmanager">② 给登录接口放行，同时为 Spring 容器注入 AuthenticationManager</h6>
<p><mark>注意</mark> ：此时配置类要继承WebSecurityConfigurerAdapter</p>
<pre><code class="language-java">@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                // 关闭csrf
                .csrf().disable()
                // 不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // 对于登录接口 允许匿名访问
                .authorizeRequests()
                .antMatchers(&quot;/user/login&quot;).anonymous()
                // 除上面外的所有请求全部需要鉴权认证
                .anyRequest().authenticated();
    }

    /**
     * 在容器中注入AuthenticationManager
     * 供登录接口的Service调用
     *
     * @return
     * @throws Exception
     */
    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }

}
</code></pre>
<h6 id="3-创建登录接口的-service">③ 创建登录接口的 Service</h6>
<ul>
<li>LoginService</li>
<li>LoginServiceImpl</li>
</ul>
<pre><code class="language-java">public interface LoginServcie {
  
    Result login(User user);

}
</code></pre>
<pre><code class="language-java">@Service
@RequiredArgsConstructor
public class LoginServcieImpl implements LoginServcie {

    private final AuthenticationManager authenticationManager;

    private final RedisCache redisCache;

    @Override
    public Result login(User user) {
        //非空判断
        if (null == user || null == user.getUserName() || null == user.getPassword()) {
            return Result.error(&quot;用户名或密码不能为空&quot;);
        }
        //调用AuthenticationManager的authenticate()方法，判断密码对不对
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword());
        Authentication authenticate = null;
        try {
            authenticate = authenticationManager.authenticate(authentication);
        } catch (BadCredentialsException e) {
            return Result.error(&quot;用户名或密码错误&quot;);
        } catch (LockedException e) {
            return Result.error(&quot;账号被锁定，请联系管理员&quot;);
        }
        //若密码正确，则用 userid 生成token
        UserDetailsBean userDetailsBean = (UserDetailsBean) authenticate.getPrincipal();
        String userId = userDetailsBean.getUser().getId().toString();
        String token = JwtUtils.createJWT(userId);
        //将用户信息 UserDetails 放入 Redis 缓存中，用户id作为key
        redisCache.setCacheObject(&quot;login:&quot; + userId, userDetailsBean);
        //返回token给前端
        HashMap&lt;String, String&gt; tokenMap = new HashMap&lt;&gt;();
        tokenMap.put(&quot;token&quot;, token);
        return Result.OK(&quot;登录成功&quot;, tokenMap);
    }

}
</code></pre>
<h6 id="4-测试登录接口">④ 测试登录接口</h6>
<ul>
<li>使用Postan测试</li>
</ul>
<h5 id="2334-认证过滤器">2.3.3.4 认证过滤器</h5>
<ul>
<li>
<p>用户登录成功后，对其他所有接口的请求都会携带相应的 token ，后续操作都是通过 token 鉴权</p>
</li>
<li>
<p>所以，我们需要自定义一个 JWT 过滤器，如果 token 有效，则<mark>显式</mark>地为用户去<mark>注册身份认证</mark>：</p>
</li>
<li>
<p><mark>SecurityContextHolder.getContext().setAuthentication(anAuthentication);</mark></p>
</li>
<li>
<p>这个过滤器具体流程为：</p>
<ul>
<li>
<p>获取请求头中的token，对token进行解析取出其中的userid。</p>
</li>
<li>
<p>使用userid去redis中获取对应的UserDetailsBean对象。</p>
</li>
<li>
<p>然后封装成 authentication 对象存入 SecurityContextHolder 显式注册身份认证</p>
</li>
</ul>
</li>
</ul>
<h6 id="1-创建-jwt-过滤器">① 创建 JWT 过滤器</h6>
<p>1）JwtAuthenticationTokenFilter</p>
<pre><code class="language-java">@Component
@RequiredArgsConstructor
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    private final RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //获取token
        String token = request.getHeader(&quot;token&quot;);
        //判断token是否非空
        if (StringUtils.isEmpty(token)) {
            //为空，则直接放行，请求会去下一个登录接口
            filterChain.doFilter(request, response);
            return;
        }
        //不为空，则解析token获取userid
        String userId;
        try {
            Claims jwt = JwtUtils.parseJWT(token);
            userId = jwt.getSubject();
        } catch (Exception e) {
            //解析失败，提示token非法
            // 方法一：
            // 注意，此时需要自定义认证异常处理，否则只会响应403的空白错误；
            // 同时，我发现这里无论抛出哪个AuthenticationException的异常，无聊怎么传递消息，
            // 在自定义认证异常时，异常消息都会被覆盖成&quot;Full authentication is required to access this resource&quot;
            // 所以，这里还是采用第二种方法处理异常。
//            throw new AuthenticationServiceException(&quot;Token非法&quot;,new Throwable(&quot;Token非法&quot;));
            //方法二：
            request.getRequestDispatcher(&quot;/jwtFilterException/&quot; + &quot;Token非法&quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //解析成功，通过userid从Redis缓存中获取 UserDetailsBean
        UserDetailsBean userDetailsBean = redisCache.getCacheObject(&quot;login:&quot; + userId);
        //获取不了，提示会话失效，请重新登录
        if (null == userDetailsBean) {
            //解析失败，提示token非法
            request.getRequestDispatcher(&quot;/jwtFilterException/&quot; + &quot;会话失效，请重新登录&quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //获取的了，将 UserDetailsBean 封装成 authentication 对象，显式地为用户去注册身份认证
        // TODO: 将权限信息封装进 authentication 对象
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetailsBean, null, userDetailsBean.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authentication);
        //放行
        filterChain.doFilter(request, response);
    }

}
</code></pre>
<p>2）JwtFilterExceptionController</p>
<pre><code class="language-java">@RestController
public class JwtFilterExceptionController {

    @RequestMapping(&quot;/jwtFilterException/{message}&quot;)
    public Result jwtFilterException(@PathVariable(&quot;message&quot;) String message) {
        return Result.error(message);
    }
    
}
</code></pre>
<h6 id="2-注册过滤器">② 注册过滤器</h6>
<pre><code class="language-java">@Configuration
@RequiredArgsConstructor
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;

    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                // 关闭csrf
                .csrf().disable()
                // 不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // 对于登录接口 允许匿名访问
                .authorizeRequests()
                .antMatchers(&quot;/user/login&quot;).anonymous()
                // 除上面外的所有请求全部需要鉴权认证
                .anyRequest().authenticated();

        // 把 JWT 过滤器添加到过滤器链中
        http
                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
    }

    /**
     * 在容器中注入AuthenticationManager
     * 供登录接口的Service调用
     *
     * @return
     * @throws Exception
     */
    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }
    
}
</code></pre>
<h6 id="3-测试-2">③ 测试</h6>
<ul>
<li>使用Postman测试</li>
</ul>
<h5 id="2335-退出登录">2.3.3.5 退出登录</h5>
<ul>
<li>我们只需要定义一个退出登录接口</li>
<li>通过 SecurityContextHolder 获取当前用户的认证信息，</li>
<li>然后通过认证信息获取 userid</li>
<li>再通过 userid 删除redis中对应的数据即可</li>
</ul>
<pre><code class="language-java">@Override
public Result logout() {
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
    UserDetailsBean userDetailsBean = (UserDetailsBean) authentication.getPrincipal();
    Long userId = userDetailsBean.getUser().getId();
    redisCache.deleteObject(&quot;login:&quot; + userId);
    return Result.OK(&quot;退出登录成功&quot;);
}
</code></pre>
<h2 id="3授权">3.授权</h2>
<h3 id="30-权限系统的作用">3.0 权限系统的作用</h3>
<p>例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。</p>
<p>总结起来就是<strong>不同的用户可以使用不同的功能</strong>。这就是权限系统要去实现的效果。</p>
<p>我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。</p>
<p>所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。</p>
<h3 id="31-授权基本流程">3.1 授权基本流程</h3>
<ul>
<li>
<p>在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。</p>
</li>
<li>
<p>在FilterSecurityInterceptor中会从SecurityContextHolder获取当前用户的Authentication，然后获取其中的权限信息。</p>
</li>
<li>
<p>然后判断当前用户的权限信息是否与接口设置的所需权限匹配。</p>
</li>
<li>
<p>匹配则放行，否则拦截。</p>
<ul>
<li>
<p>所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</p>
</li>
<li>
<p>然后设置我们的接口等资源所需要的权限即可。</p>
</li>
</ul>
</li>
</ul>
<h3 id="32-授权实现">3.2 授权实现</h3>
<h4 id="321-基于注解设置访问资源的权限">3.2.1 基于注解设置访问资源的权限</h4>
<h5 id="1-开启基于注解的配置">① 开启基于注解的配置</h5>
<pre><code class="language-java">@EnableGlobalMethodSecurity(prePostEnabled = true)
</code></pre>
<h5 id="2-使用-preauthorize-设置权限">② 使用 @PreAuthorize 设置权限</h5>
<pre><code class="language-java">@RestController
public class HelloController {

    @PreAuthorize(&quot;hasAuthority('ROLE_TEST')&quot;)
    @RequestMapping(&quot;/hello&quot;)
    public String hello(){
        return &quot;hello&quot;;
    }

}
</code></pre>
<h5 id="3-测试-3">③ 测试</h5>
<ul>
<li>我们可以先用 Postman 进行简单的测试</li>
<li>结果当然是 403 无权限</li>
</ul>
<h4 id="322-封装权限信息">3.2.2 封装权限信息</h4>
<h5 id="1-修改userdetailsbean">① 修改UserDetailsBean</h5>
<pre><code class="language-java">/**
 * 登录用户 UserDetails
 */
public class UserDetailsBean implements UserDetails {

    /**
     * 封装用户信息
     */
    private User user;

    /**
     * 封装用户权限信息
     */
    private List&lt;String&gt; authorityList;
    
    private List&lt;SimpleGrantedAuthority&gt; authorities;

    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        // 写法一：
//        List&lt;SimpleGrantedAuthority&gt; authorities = authorities.stream().map(s -&gt; new SimpleGrantedAuthority(s)).collect(Collectors.toList());
        // 写法二：
        authorities = authorityList.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());
        // 写法三：
//        Collection&lt;SimpleGrantedAuthority&gt; authorities = null;
//        for (String s : authorities) {
//            authorities.add(new SimpleGrantedAuthority(s));
//        }
        return authorities;
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUserName();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return user.getStatus().equals(&quot;0&quot;);
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public List&lt;String&gt; getAuthorityList() {
        return authorityList;
    }

    public void setAuthorityList(List&lt;String&gt; authorityList) {
        this.authorityList = authorityList;
    }

    public void setAuthorities(List&lt;SimpleGrantedAuthority&gt; authorities) {
        this.authorities = authorities;
    }

    public UserDetailsBean() {
    }

    public UserDetailsBean(User user, List&lt;String&gt; authorityList) {
        this.user = user;
        this.authorityList = authorityList;
    }

}
</code></pre>
<h5 id="2-修改userdetailsserviceimpl">② 修改UserDetailsServiceImpl</h5>
<ul>
<li>TODO</li>
</ul>
<pre><code class="language-java">@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserMapper userMapper;

    /**
     * 从数据库中查出用户信息，
     * 供 AuthenticationProvider 进行密码比对
     *
     * @param username 由 AuthenticationProvider 提供，也就是前端传入的username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1、根据用户名查询用户信息
        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.eq(User::getUserName, username);
        User user = userMapper.selectOne(queryWrapper);
        // 2、如果查询不到数据就通过抛出异常来给出提示
        if (null == user) {
            throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;);
        }
        //TODO 3、根据用户名查询权限信息，将其添加到 UserDetailsBean 中的 authorities
        List&lt;String&gt; list = Arrays.asList(&quot;ROLE_USER&quot;, &quot;ROLE_ADMIN&quot;);
        // 4、将查出的用户信息，权限信息，封装成UserDetails（UserDetailsBean）对象返回
        return new UserDetailsBean(user,list);
    }
}
</code></pre>
<h5 id="3-修改jwtauthenticationtokenfilter">③ 修改JwtAuthenticationTokenFilter</h5>
<ul>
<li>TODO</li>
</ul>
<pre><code class="language-java">@Component
@RequiredArgsConstructor
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    private final RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //获取token
        String token = request.getHeader(&quot;token&quot;);
        //判断token是否非空
        if (StringUtils.isEmpty(token)) {
            //为空，则直接放行，请求会去下一个登录接口
            filterChain.doFilter(request, response);
            return;
        }
        //不为空，则解析token获取userid
        String userId;
        try {
            Claims jwt = JwtUtils.parseJWT(token);
            userId = jwt.getSubject();
        } catch (Exception e) {
            //解析失败，提示token非法
            request.getRequestDispatcher(&quot;/jwtFilterException/&quot; + &quot;Token非法&quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //解析成功，通过userid从Redis缓存中获取 UserDetailsBean
        UserDetailsBean userDetailsBean = redisCache.getCacheObject(&quot;login:&quot; + userId);
        //获取不了，提示会话失效，请重新登录
        if (null == userDetailsBean) {
            //解析失败，提示token非法
            request.getRequestDispatcher(&quot;/jwtFilterException/&quot; + &quot;会话失效，请重新登录&quot;).forward(request, response);
            filterChain.doFilter(request, response);
            return;
        }
        //获取的了，将 UserDetailsBean 封装成 authentication 对象，显式地为用户去注册身份认证
        // TODO: 将权限信息封装进 authentication 对象
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetailsBean, null, userDetailsBean.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authentication);
        //放行
        filterChain.doFilter(request, response);
    }

}
</code></pre>
<h5 id="4-测试">④ 测试</h5>
<ul>
<li>使用 Postman 进行测试</li>
</ul>
<h4 id="323-从数据库查询权限信息">3.2.3 从数据库查询权限信息</h4>
<h5 id="3231-rbac权限模型">3.2.3.1 RBAC权限模型</h5>
<p>RBAC权限模型（Role-Based Access Control）</p>
<p>即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220818201512.png" alt="" loading="lazy"></figure>
<h5 id="3232-准备工作">3.2.3.2 准备工作</h5>
<pre><code class="language-sql">CREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;

USE `sg_security`;

/*Table structure for table `sys_menu` */

DROP TABLE IF EXISTS `sys_menu`;

CREATE TABLE `sys_menu` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `menu_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '菜单名',
  `path` varchar(200) DEFAULT NULL COMMENT '路由地址',
  `component` varchar(255) DEFAULT NULL COMMENT '组件路径',
  `visible` char(1) DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',
  `status` char(1) DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',
  `perms` varchar(100) DEFAULT NULL COMMENT '权限标识',
  `icon` varchar(100) DEFAULT '#' COMMENT '菜单图标',
  `create_by` bigint(20) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint(20) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int(11) DEFAULT '0' COMMENT '是否删除（0未删除 1已删除）',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='菜单表';

/*Table structure for table `sys_role` */

DROP TABLE IF EXISTS `sys_role`;

CREATE TABLE `sys_role` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) DEFAULT NULL,
  `role_key` varchar(100) DEFAULT NULL COMMENT '角色权限字符串',
  `status` char(1) DEFAULT '0' COMMENT '角色状态（0正常 1停用）',
  `del_flag` int(1) DEFAULT '0' COMMENT 'del_flag',
  `create_by` bigint(200) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint(200) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT='角色表';

/*Table structure for table `sys_role_menu` */

DROP TABLE IF EXISTS `sys_role_menu`;

CREATE TABLE `sys_role_menu` (
  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `menu_id` bigint(200) NOT NULL DEFAULT '0' COMMENT '菜单id',
  PRIMARY KEY (`role_id`,`menu_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;

/*Table structure for table `sys_user` */

DROP TABLE IF EXISTS `sys_user`;

CREATE TABLE `sys_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '用户名',
  `nick_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '昵称',
  `password` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '密码',
  `status` char(1) DEFAULT '0' COMMENT '账号状态（0正常 1停用）',
  `email` varchar(64) DEFAULT NULL COMMENT '邮箱',
  `phonenumber` varchar(32) DEFAULT NULL COMMENT '手机号',
  `sex` char(1) DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',
  `avatar` varchar(128) DEFAULT NULL COMMENT '头像',
  `user_type` char(1) NOT NULL DEFAULT '1' COMMENT '用户类型（0管理员，1普通用户）',
  `create_by` bigint(20) DEFAULT NULL COMMENT '创建人的用户id',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) DEFAULT NULL COMMENT '更新人',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `del_flag` int(11) DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';

/*Table structure for table `sys_user_role` */

DROP TABLE IF EXISTS `sys_user_role`;

CREATE TABLE `sys_user_role` (
  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `role_id` bigint(200) NOT NULL DEFAULT '0' COMMENT '角色id',
  PRIMARY KEY (`user_id`,`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

</code></pre>
<pre><code class="language-mysql">SELECT 
	DISTINCT m.`perms`
FROM
	sys_user_role ur
	LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`
	LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`
	LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`
WHERE
	user_id = 2
	AND r.`status` = 0
	AND m.`status` = 0
</code></pre>
<pre><code class="language-java">package com.sangeng.domain;

import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.Date;

/**
 * 菜单表(Menu)实体类
 *
 * @author makejava
 * @since 2021-11-24 15:30:08
 */
@TableName(value=&quot;sys_menu&quot;)
@Data
@AllArgsConstructor
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class Menu implements Serializable {
    private static final long serialVersionUID = -54979041104113736L;
    
    private Long id;
    /**
    * 菜单名
    */
    private String menuName;
    /**
    * 路由地址
    */
    private String path;
    /**
    * 组件路径
    */
    private String component;
    /**
    * 菜单状态（0显示 1隐藏）
    */
    private String visible;
    /**
    * 菜单状态（0正常 1停用）
    */
    private String status;
    /**
    * 权限标识
    */
    private String perms;
    /**
    * 菜单图标
    */
    private String icon;
    
    private Long createBy;
    
    private Date createTime;
    
    private Long updateBy;
    
    private Date updateTime;
    /**
    * 是否删除（0未删除 1已删除）
    */
    @TableLogic
    private Integer delFlag;
    /**
    * 备注
    */
    private String remark;
}
</code></pre>
<h5 id="3233-代码实现">3.2.3.3 代码实现</h5>
<ul>
<li>我们只需要根据用户 id 去查询到其所对应的权限信息即可。</li>
</ul>
<p>所以我们可以先定义个 mapper ，其中提供一个方法可以根据 userid 查询权限信息。</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.sangeng.domain.Menu;

import java.util.List;

/**
 * @Author 三更  B站： https://space.bilibili.com/663528522
 */
public interface MenuMapper extends BaseMapper&lt;Menu&gt; {
    List&lt;String&gt; selectPermsByUserId(@Param(&quot;id&quot;) Long id);
}
</code></pre>
<ul>
<li>多表联查，所以需要创建对应的 mapper 映射文件，定义对应的sql语句</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sangeng.mapper.MenuMapper&quot;&gt;

    &lt;select id=&quot;selectPermsByUserId&quot; resultType=&quot;java.lang.String&quot;&gt;
        SELECT
            DISTINCT m.`perms`
        FROM
            sys_user_role ur
            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`
            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`
            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`
        WHERE
            user_id = #{id}
            AND r.`status` = 0
            AND m.`status` = 0
    &lt;/select&gt;
  
&lt;/mapper&gt;
</code></pre>
<ul>
<li>在 application.yml 中配置 mapper 映射文件的位置</li>
</ul>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
  redis:
    host: localhost
    port: 6379
mybatis-plus:
  mapper-locations: classpath*:/mapper/**/*.xml 

</code></pre>
<ul>
<li>然后我们可以在 UserDetailsServiceImpl 中去调用该 mapper 的方法</li>
<li>将查询的权限信息封装到 UserDetailsBean 对象中即可。</li>
</ul>
<pre><code class="language-java">@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserMapper userMapper;

    /**
     * 从数据库中查出用户信息，
     * 供 AuthenticationProvider 进行密码比对
     *
     * @param username 由 AuthenticationProvider 提供，也就是前端传入的username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1、根据用户名查询用户信息
        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.eq(User::getUserName, username);
        User user = userMapper.selectOne(queryWrapper);
        // 2、如果查询不到数据就通过抛出异常来给出提示
        if (null == user) {
            throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;);
        }
        // 3、根据用户名查询权限信息，将其添加到 UserDetailsBean 中的 authorities
        List&lt;String&gt; list = userMapper.selectPermsByUserId(user.getId());
        // 4、将查出的用户信息，权限信息，封装成UserDetails（UserDetailsBean）对象返回
        return new UserDetailsBean(user,list);
    }
}
</code></pre>
<h2 id="4-自定义失败处理">4、自定义失败处理</h2>
<ul>
<li>
<p>我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。</p>
</li>
<li>
<p>在SpringSecurity中，如果我们在<mark>认证</mark>或者<mark>授权</mark>的过程中出现了<mark>异常</mark>会被<mark>ExceptionTranslationFilter</mark>捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p>
</li>
<li>
<p>如果是<mark>认证</mark>过程中出现的异常会被封装成AuthenticationException然后调用<mark>AuthenticationEntryPoint</mark>对象的方法去进行异常处理。</p>
</li>
<li>
<p>如果是<mark>授权</mark>过程中出现的异常会被封装成AccessDeniedException然后调用<mark>AccessDeniedHandler</mark>对象的方法去进行异常处理。</p>
</li>
<li>
<p>所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。</p>
</li>
</ul>
<h3 id="1-自定义实现类">① 自定义实现类</h3>
<p>1）自定义授权异常处理</p>
<pre><code class="language-java">@Component
public class AccessDeniedHandlerImpl implements AccessDeniedHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        Result&lt;Object&gt; result = Result.error(HttpStatus.FORBIDDEN.value(), accessDeniedException.getMessage());
        String json = JSON.toJSONString(result);
        WebUtils.renderString(response,json);
    }

}
</code></pre>
<p>2）自定义认证异常处理</p>
<pre><code class="language-java">/**
 * @Author 三更  B站： https://space.bilibili.com/663528522
 */
@Component
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;);
        String json = JSON.toJSONString(result);
        WebUtils.renderString(response,json);
    }
}
</code></pre>
<h3 id="2-配置给-springsecurity">② 配置给 SpringSecurity</h3>
<ul>
<li>先注入对应的处理器</li>
</ul>
<pre><code class="language-java">@Autowired
private AuthenticationEntryPoint authenticationEntryPoint;

@Autowired
private AccessDeniedHandler accessDeniedHandler;
</code></pre>
<ul>
<li>然后我们可以使用HttpSecurity对象的方法去配置。</li>
</ul>
<pre><code class="language-java">// 配置自定义的认证和授权异常处理类
http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).
        accessDeniedHandler(accessDeniedHandler);
</code></pre>
<h2 id="5-跨域">5、跨域</h2>
<ul>
<li>
<p>浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。</p>
</li>
<li>
<p>同源策略要求源相同才能正常进行通信，即<mark>协议</mark>、<mark>域名</mark>、<mark>端口号</mark>都完全一致。</p>
</li>
<li>
<p>前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。</p>
</li>
<li>
<p>所以我们就要处理一下，让前端能进行跨域请求。</p>
</li>
</ul>
<h3 id="1-首先开启-springmvc-的跨域访问">① 首先开启 SpringMVC 的跨域访问</h3>
<pre><code class="language-java">@Configuration(proxyBeanMethods = false)
public class MvcConfiguration {

    /**
     * 处理CORS
     *
     * @return
     */
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping(&quot;/**&quot;)
                        .allowedOriginPatterns(&quot;http://localhost:*&quot;)
                        .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)
                        .allowCredentials(true)//设置是否允许客户端跨域携带验证数据，如Cookie值
                        .maxAge(3600);
            }
        };
    }

}
</code></pre>
<p>或</p>
<pre><code class="language-java">@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
      // 设置允许跨域的路径
        registry.addMapping(&quot;/**&quot;)
                // 设置允许跨域请求的域名
                .allowedOriginPatterns(&quot;*&quot;)
                // 是否允许cookie
                .allowCredentials(true)
                // 设置允许的请求方式
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;)
                // 设置允许的header属性
                .allowedHeaders(&quot;*&quot;)
                // 跨域允许时间
                .maxAge(3600);
    }
}
</code></pre>
<h3 id="2-开启-springsecurity-的跨域访问">② 开启 SpringSecurity 的跨域访问</h3>
<p>由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。</p>
<pre><code class="language-java">// 允许跨域
http.cors();
</code></pre>
<h2 id="6-遗留小问题">6、遗留小问题</h2>
<h3 id="61-其它权限校验方法">6.1 其它权限校验方法</h3>
<p>我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。</p>
<hr>
<p>这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。</p>
<p>hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。</p>
<p>它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。</p>
<hr>
<ul>
<li><mark>hasAnyAuthority</mark>方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。</li>
</ul>
<pre><code class="language-java">    @PreAuthorize(&quot;hasAnyAuthority('admin','test','system:dept:list')&quot;)
    public String hello(){
        return &quot;hello&quot;;
    }
</code></pre>
<ul>
<li><mark>hasRole</mark>要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <mark>ROLE_</mark> 后再去比较。所以这种情况下要用用户对应的权限也要有<strong>ROLE_</strong> 这个前缀才可以。</li>
</ul>
<pre><code class="language-java">    @PreAuthorize(&quot;hasRole('system:dept:list')&quot;)
    public String hello(){
        return &quot;hello&quot;;
    }
</code></pre>
<ul>
<li><mark>hasAnyRole</mark> 有<mark>Any</mark>任意的角色就可以访问。它内部也会把我们传入的参数拼接上<mark>ROLE_</mark> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</li>
</ul>
<pre><code class="language-java">    @PreAuthorize(&quot;hasAnyRole('admin','system:dept:list')&quot;)
    public String hello(){
        return &quot;hello&quot;;
    }
</code></pre>
<h3 id="62-自定义权限校验方法">6.2 自定义权限校验方法</h3>
<ul>
<li>我们也可以定义自己的权限校验方法，在 @PreAuthorize 注解中使用我们的方法。</li>
</ul>
<pre><code class="language-java">@Component(&quot;ex&quot;)
public class SGExpressionRoot {

    public boolean hasAuthority(String authority){
        //获取当前用户的权限
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        List&lt;String&gt; authorities = loginUser.getAuthorities();
        //判断用户权限集合中是否存在authority
        return authorities.contains(authority);
    }
}
</code></pre>
<ul>
<li>在 SPEL 表达式中，使用 @ex 相当于获取容器中 bean 的名字未ex的对象。然后再调用这个对象的 hasAuthority 方法</li>
</ul>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
@PreAuthorize(&quot;@ex.hasAuthority('system:dept:list')&quot;)
public String hello(){
    return &quot;hello&quot;;
}
</code></pre>
<h3 id="63-基于配置的权限控制">6.3 基于配置的权限控制</h3>
<ul>
<li>我们也可以在配置类中使用使用配置的方式对资源进行权限控制。</li>
</ul>
<pre><code class="language-java">@Override
protected void configure(HttpSecurity http) throws Exception {
    http
            //关闭csrf
            .csrf().disable()
            //不通过Session获取SecurityContext
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeRequests()
            // 对于登录接口 允许匿名访问
            .antMatchers(&quot;/user/login&quot;).anonymous()
            .antMatchers(&quot;/testCors&quot;).hasAuthority(&quot;system:dept:list222&quot;)
            // 除上面外的所有请求全部需要鉴权认证
            .anyRequest().authenticated();

    //添加过滤器
    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);

    //配置异常处理器
    http.exceptionHandling()
            //配置认证失败处理器
            .authenticationEntryPoint(authenticationEntryPoint)
            .accessDeniedHandler(accessDeniedHandler);

    //允许跨域
    http.cors();
}
</code></pre>
<h3 id="64-csrf">6.4 CSRF</h3>
<pre><code>CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。

https://blog.csdn.net/freeking101/article/details/86537087

SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。

我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。
</code></pre>
<h3 id="65-认证成功处理器">6.5 认证成功处理器</h3>
<ul>
<li>
<p>实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。</p>
</li>
<li>
<p>我们也可以自己去自定义成功处理器进行成功后的相应处理。</p>
</li>
</ul>
<pre><code class="language-java">@Component
public class SGSuccessHandler implements AuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        System.out.println(&quot;认证成功了&quot;);
    }
}

</code></pre>
<pre><code class="language-java">@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private AuthenticationSuccessHandler successHandler;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin().successHandler(successHandler);

        http.authorizeRequests().anyRequest().authenticated();
    }
}
</code></pre>
<h3 id="66-认证失败处理器">6.6 认证失败处理器</h3>
<ul>
<li>
<p>实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。</p>
</li>
<li>
<p>我们也可以自己去自定义失败处理器进行失败后的相应处理。</p>
</li>
</ul>
<pre><code class="language-java">@Component
public class SGFailureHandler implements AuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
        System.out.println(&quot;认证失败了&quot;);
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private AuthenticationSuccessHandler successHandler;

    @Autowired
    private AuthenticationFailureHandler failureHandler;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin()
                //配置认证成功处理器
                .successHandler(successHandler)
                //配置认证失败处理器
                .failureHandler(failureHandler);

        http.authorizeRequests().anyRequest().authenticated();
    }
}

</code></pre>
<h3 id="67-登出成功处理器">6.7 登出成功处理器</h3>
<pre><code class="language-java">@Component
public class SGLogoutSuccessHandler implements LogoutSuccessHandler {
    @Override
    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        System.out.println(&quot;注销成功&quot;);
    }
}

</code></pre>
<pre><code class="language-java">@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private AuthenticationSuccessHandler successHandler;

    @Autowired
    private AuthenticationFailureHandler failureHandler;

    @Autowired
    private LogoutSuccessHandler logoutSuccessHandler;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin()
                //配置认证成功处理器
                .successHandler(successHandler)
                //配置认证失败处理器
                .failureHandler(failureHandler);

        http.logout()
                //配置注销成功处理器
                .logoutSuccessHandler(logoutSuccessHandler);

        http.authorizeRequests().anyRequest().authenticated();
    }
}
</code></pre>
<h3 id="68-其他认证方案畅想">6.8 其他认证方案畅想</h3>
<ul>
<li>......</li>
</ul>
<h1 id="oauth-2">OAuth 2</h1>
<h2 id="开始">开始</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[POI与EasyExcel笔记]]></title>
        <id>https://kuangyang828.github.io/poi-yu-easyexcel-bi-ji/</id>
        <link href="https://kuangyang828.github.io/poi-yu-easyexcel-bi-ji/">
        </link>
        <updated>2022-08-13T07:23:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="poi与easyexcel">POI与EasyExcel</h1>
<h2 id="poi">POI</h2>
<p>Apache POI为Java程序提供API，来支持Microsoft Office格式档案读和写的功能。</p>
<p><code>HSSF</code> － 提供读写 Microsoft Excel <code>XLS</code>格式档案的功能。<code>Excel2003</code></p>
<p><code>XSSF</code> － 提供读写Microsoft Excel OOXML <code>XLSX</code>格式档案的功能。<code>Excel2007+</code></p>
<p><mark>S</mark>XSSF － XSSF的加强版，采用缓存机制，可以写非常大的数据量，如 100万 条甚至更多，写数据速度快，占用更少的内存</p>
<p>HWPF － 提供读写[Microsoft Word[DOC]格式档案的功能。</p>
<p>HSLF － 提供读写Microsoft PowerPoint格式档案的功能。</p>
<p>HDGF － 提供读写Microsoft Visio格式档案的功能。</p>
<p>HPBF － 提供读写Microsoft Publisher格式档案的功能。</p>
<p>HSMF － 提供读写Microsoft Outlook格式档案的功能。</p>
<ul>
<li>其中Excel2003文件最多存储65536行数据，Excel2007+则没有限制</li>
</ul>
<h2 id="easyexcel">EasyExcel</h2>
<ul>
<li>EasyExcel是阿里巴巴开源的快速、简洁、<mark>解决大文件内存溢出</mark>的java处理Excel工具</li>
<li>https://github.com/alibaba/easyexcel</li>
<li>POI存在内存泄露的主要原因是，在操作过程中它是将所有数据写入到内存，再一次性写入磁盘。当然也有优点，速度快。</li>
<li>EasyExcel是一行一行的读写，用这样的方式解决了内存占用高甚至溢出的问题。</li>
</ul>
<h1 id="poi-excel写">POI-Excel写</h1>
<p>1、创建Maven项目</p>
<p>2、添加依赖</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!--xls(03)--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
        &lt;artifactId&gt;poi&lt;/artifactId&gt;
        &lt;version&gt;3.9&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--xlsx(07)--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
        &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;
        &lt;version&gt;3.9&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--日期格式化工具--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;joda-time&lt;/groupId&gt;
        &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
        &lt;version&gt;2.10.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>3、编写测试类</p>
<pre><code class="language-java">public class ExcelWrite {
 
    private String PATH=&quot;F:\\ideaProject\\study\\&quot;;
 
    @Test
    public void write03() throws IOException {
        // 1、创建工作薄
        Workbook workbook = new HSSFWorkbook();
        //2、创建工作表
        Sheet sheet = workbook.createSheet(&quot;test1&quot;);
 
        //3、创建行(0:第一行)
        Row row1 = sheet.createRow(0);
        //4、创建单元格(0:第一行的第一个格子)
        Cell cell00 = row1.createCell(0);
        cell00.setCellValue(&quot;测试数据&quot;);
        //第一行的第二个格子
        Cell cell01 = row1.createCell(1);
        cell01.setCellValue(&quot;testData&quot;);
 
        //第二行
        Row row2 = sheet.createRow(1);
        //第二行的第一个格子
        Cell cell10 = row2.createCell(0);
        cell10.setCellValue(&quot;时间&quot;);
        //第二行的第二个格子
        Cell cell11 = row2.createCell(1);
        cell11.setCellValue(new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;));
 
        //生成Excel（IO流）
        //03版本的Excel是使用 .xls 结尾！！！
        FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;POI03测试.xls&quot;);
 
        workbook.write(fileOutputStream);
 
        //关闭流
        fileOutputStream.close();
 
        System.out.println(&quot;03Excel输出完毕&quot;);
    }
 
    @Test
    public void write07() throws IOException {
        // 1、创建工作薄
        Workbook workbook = new XSSFWorkbook();
        //2、创建工作表
        Sheet sheet = workbook.createSheet(&quot;test1&quot;);
 
        //3、创建行(0:第一行)
        Row row1 = sheet.createRow(0);
        //4、创建单元格(0:第一行的第一个格子)
        Cell cell00 = row1.createCell(0);
        cell00.setCellValue(&quot;测试数据&quot;);
        //第一行的第二个格子
        Cell cell01 = row1.createCell(1);
        cell01.setCellValue(&quot;testData&quot;);
 
        //第二行
        Row row2 = sheet.createRow(1);
        //第二行的第一个格子
        Cell cell10 = row2.createCell(0);
        cell10.setCellValue(&quot;时间&quot;);
        //第二行的第二个格子
        Cell cell11 = row2.createCell(1);
        cell11.setCellValue(new DateTime().toString(&quot;yyyy-MM-dd HH:mm:ss&quot;));
 
        //生成Excel（IO流）
        //03版本的Excel是使用 .xlsx 结尾！！！
        FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;POI07测试.xlsx&quot;);
 
        workbook.write(fileOutputStream);
 
        //关闭流
        fileOutputStream.close();
 
        System.out.println(&quot;07Excel输出完毕&quot;);
    }
}
</code></pre>
<p>注意，Excel文件后缀与对应的对象</p>
<table>
<thead>
<tr>
<th>Excel版本</th>
<th>文件后缀</th>
<th>对应的对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>2003</td>
<td>xls</td>
<td>HSSF</td>
</tr>
<tr>
<td>2007</td>
<td>xlsx</td>
<td>XSSF / SXSSF</td>
</tr>
</tbody>
</table>
<h2 id="hssf">HSSF</h2>
<pre><code class="language-java">@Test
public void write03BigData() throws IOException {
    long begin = System.currentTimeMillis();
 
    //创建簿
    Workbook workbook = new HSSFWorkbook();
    //创建表
    Sheet sheet = workbook.createSheet();
    //写数据
    for (int rowNum = 0; rowNum &lt; 65536; rowNum++) {
        Row row = sheet.createRow(rowNum);
        for (int cellNum = 0; cellNum &lt; 10; cellNum++) {
            Cell cell = row.createCell(cellNum);
            cell.setCellValue(cellNum);
        }
    }
    System.out.println(&quot;over&quot;);
    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;TestWrite03BigData.xls&quot;);
    workbook.write(fileOutputStream);
    fileOutputStream.close();
 
    long end = System.currentTimeMillis();
 
    System.out.println((double) (end-begin)/1000);
}
</code></pre>
<ul>
<li>优点：写入过程中先写入内存，不操作磁盘，最后一次性写入磁盘，速度快</li>
<li>缺点：最多只能处理 <mark>65536</mark> 行，否则会抛出异常</li>
<li><mark>java.lang.IllegalArgumentException: Invalid row number (65536) outside allowable range (0..65535)</mark></li>
</ul>
<h2 id="xssf">XSSF</h2>
<pre><code class="language-xml">@Test
public void write07BigData() throws IOException {
    long begin = System.currentTimeMillis();
 
    //创建簿
    Workbook workbook = new XSSFWorkbook();
    //创建表
    Sheet sheet = workbook.createSheet();
    //写数据
    for (int rowNum = 0; rowNum &lt; 100000; rowNum++) {
        Row row = sheet.createRow(rowNum);
        for (int cellNum = 0; cellNum &lt; 10; cellNum++) {
            Cell cell = row.createCell(cellNum);
            cell.setCellValue(cellNum);
        }
    }
    System.out.println(&quot;over&quot;);
    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;TestWrite07BigData.xlsx&quot;);
    workbook.write(fileOutputStream);
    fileOutputStream.close();
 
    long end = System.currentTimeMillis();
 
    System.out.println((double) (end-begin)/1000);
}
</code></pre>
<ul>
<li>优点：因为XSSF是对应Excel2007版本，所以它可以写较大的数据量，如 20万条</li>
<li>缺点：因为POI的<code>一次性</code>机制，写数据时速度非常慢，非常耗内存，也会发生内存溢出，如 100万条</li>
</ul>
<h2 id="sxssf">SXSSF</h2>
<pre><code class="language-java">@Test
public void write07BigDataS() throws IOException {
    long begin = System.currentTimeMillis();
 
    //创建簿
    Workbook workbook = new SXSSFWorkbook();
    //创建表
    Sheet sheet = workbook.createSheet();
    //写数据
    for (int rowNum = 0; rowNum &lt; 100000; rowNum++) {
        Row row = sheet.createRow(rowNum);
        for (int cellNum = 0; cellNum &lt; 10; cellNum++) {
            Cell cell = row.createCell(cellNum);
            cell.setCellValue(cellNum);
        }
    }
    System.out.println(&quot;over&quot;);
    FileOutputStream fileOutputStream = new FileOutputStream(PATH + &quot;TestWrite07BigDataS.xlsx&quot;);
    workbook.write(fileOutputStream);
    fileOutputStream.close();
  
    //删除临时文件
    ((SXSSFWorkbook) workbook).dispose();
 
    long end = System.currentTimeMillis();
    System.out.println((double) (end-begin)/1000);
}
</code></pre>
<ul>
<li>优点：采用缓存机制，可以写非常大的数据量，如 100万 条甚至更多，写数据速度快，占用更少的内存</li>
<li>可以使用<mark>dispose</mark>( )方法删除临时文件</li>
<li>默认由 100 条记录被保存在内存中，如果超过这数量，则最前面的数据被写入临时文件</li>
<li>如果想自定义<mark>内存中数据的数量</mark>，可以使用<mark>有参构造器</mark>。new SXSSFWorkbook(amount)</li>
</ul>
<blockquote>
<p>SXSSFWorkbook 官方解释：</p>
<ul>
<li>
<p>实现“BigGridDemo”策略的流式XSSFWorkbook版本。</p>
</li>
<li>
<p>这允许写入非常大的文件而不会耗尽内存，因为任何时候只有可配置的行部分被保存在内存中。</p>
</li>
</ul>
<p>But，</p>
<ul>
<li>请注意，仍然可能会消耗大量内存，</li>
<li>这些内存基于正在使用的功能，例如合并区域，注释...仍然只存储在内存中</li>
<li>因此如果广泛使用，可能需要大量内存。</li>
</ul>
</blockquote>
<h1 id="poi-excel读">POI-Excel读</h1>
<h2 id="hssf-2">HSSF</h2>
<pre><code class="language-java">@Test
public void testRead03() throws IOException {
    //获取文件流
    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;POIPOI03测试.xls&quot;);
 
    //1、获取工作簿
    Workbook workbook = new HSSFWorkbook(fileInputStream);
    //2、得到表
    Sheet sheet = workbook.getSheetAt(0);
    //3、得到行
    Row row = sheet.getRow(0);
    //4、得到列
    Cell cell = row.getCell(0);
 
    //读取值时一定要注意类型
    System.out.println(cell.getStringCellValue());
 
    fileInputStream.close();
}
</code></pre>
<p>==注意：==读取值时一定要注意类型，类型选择不匹配会报错</p>
<h2 id="xssf-2">XSSF</h2>
<pre><code class="language-java">@Test
public void testRead07() throws IOException {
    //获取文件流
    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;POIPOI07测试.xlsx&quot;);
 
    //1、获取工作簿
    Workbook workbook = new XSSFWorkbook(fileInputStream);
    //2、得到表
    Sheet sheet = workbook.getSheetAt(0);
    //3、得到行
    Row row = sheet.getRow(0);
    //4、得到列
    Cell cell = row.getCell(0);
 
    //读取值时一定要注意类型
    System.out.println(cell.getStringCellValue());
 
    fileInputStream.close();
}
</code></pre>
<h2 id="读取不同的数据类型">读取不同的数据类型</h2>
<pre><code class="language-java">@Test
public void testCellType() throws Exception {
    //获取文件
    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;会员消费商品明细表.xls&quot;);
 
    //获取工作薄
    Workbook workbook = new HSSFWorkbook(fileInputStream);
    //得到表
    Sheet sheet = workbook.getSheetAt(0);
 
    //获取标题内容
    Row rowTitle = sheet.getRow(0);
    if (rowTitle != null){
        //获取一行中有多少个单元格
        int cellCount = rowTitle.getPhysicalNumberOfCells();
        for (int cellNum = 0; cellNum &lt; cellCount; cellNum++) {
            //获取单元
            Cell cell = rowTitle.getCell(cellNum);
            if (cell != null){
                //获取类型
                int cellType = cell.getCellType();
                String cellValue = cell.getStringCellValue();
                System.out.print(cellValue + &quot; | &quot;);
            }
        }
        System.out.println();
    }
 
    //获取表中的内容
    int rowCount = sheet.getPhysicalNumberOfRows();
    for (int rowNum = 1; rowNum &lt; rowCount; rowNum++) {
        Row rowData = sheet.getRow(rowNum);
        if (rowData != null){
            //读取列
            int cellCout = rowTitle.getPhysicalNumberOfCells();
            for (int cellNum = 0; cellNum &lt; cellCout; cellNum++) {
                System.out.print(&quot;【&quot; + (rowNum+1) + &quot;-&quot; + (cellNum+1) + &quot;】&quot;);
              
                Cell cell = rowData.getCell(cellNum);
                //匹配列的数据类型
                if (cell != null){
                    int cellType = cell.getCellType();
                    String cellValue = &quot;&quot;;
 
                    switch (cellType){
                        case HSSFCell.CELL_TYPE_STRING://字符串
                            System.out.print(&quot;【STRING】&quot;);
                            cellValue = cell.getStringCellValue();
                            break;
                        case HSSFCell.CELL_TYPE_BOOLEAN://布尔值
                            System.out.print(&quot;【BOOLEAN】&quot;);
                            cellValue = String.valueOf(cell.getBooleanCellValue());
                            break;
                        case HSSFCell.CELL_TYPE_NUMERIC://数字类型
                            System.out.print(&quot;【NUMERIC】&quot;);
 
                            if (HSSFDateUtil.isCellDateFormatted(cell)){//日期
                                System.out.print(&quot;【日期】&quot;);
                                Date date = cell.getDateCellValue();
                                cellValue = new DateTime().toString(&quot;yyyy-MM-dd&quot;);
                            }else{
                                // 不是日期格式，则防止当数字过长时以科学计数法显示
                                System.out.print(&quot;【转换成字符串】&quot;);
                                cell.setCellType(HSSFCell.CELL_TYPE_STRING);
                                cellValue = cell.toString();
                            }
                            break;
                        case HSSFCell.CELL_TYPE_BLANK://空
                            System.out.print(&quot;【BLANK】&quot;);
                            break;
                        case Cell.CELL_TYPE_ERROR:
                            System.out.print(&quot;【数据类型错误】&quot;);
                            break;
                    }
                    System.out.println(cellValue);
                }
            }
        }
    }
    fileInputStream.close();
}
</code></pre>
<h2 id="读计算公式">读计算公式</h2>
<pre><code class="language-java">@Test
public void testFormula() throws Exception {
    FileInputStream fileInputStream = new FileInputStream(PATH + &quot;计算公式.xls&quot;);
    Workbook workbook = new HSSFWorkbook(fileInputStream);
    Sheet sheetAt = workbook.getSheetAt(0);
 
    //获取计算公式所在的行
    Row row = sheetAt.getRow(4);
    //计算公式的第几个单元格
    Cell cell = row.getCell(0);
 
    //拿到计算公式
    FormulaEvaluator formulaEvaluator = new HSSFFormulaEvaluator((HSSFWorkbook) workbook);
 
    //输出单元格内容
    int cellType = cell.getCellType();
    switch (cellType){
        case Cell.CELL_TYPE_FORMULA://公式
            //获取单元格的计算公式
            String formula = cell.getCellFormula();
            System.out.println(formula);
 
            //计算
            CellValue evaluate = formulaEvaluator.evaluate(cell);
            String cellValue = evaluate.formatAsString();
            System.out.println(cellValue);
            break;
    }
}
</code></pre>
<h1 id="easyexcel操作">EasyExcel操作</h1>
<ul>
<li>EasyExcel操作参照官方快速开始即可</li>
<li>https://github.com/alibaba/easyexcel</li>
</ul>
<h2 id="写入">写入</h2>
<ul>
<li>按固定类格式进行写入</li>
</ul>
<h2 id="读取">读取</h2>
<ul>
<li>根据监听器设置的规则进行读取</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue3快速上手笔记]]></title>
        <id>https://kuangyang828.github.io/vue3-kuai-su-shang-shou-bi-ji/</id>
        <link href="https://kuangyang828.github.io/vue3-kuai-su-shang-shou-bi-ji/">
        </link>
        <updated>2022-08-11T08:54:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue3快速上手">Vue3快速上手</h1>
<img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" />
<h2 id="1vue3简介">1.Vue3简介</h2>
<ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a></li>
<li>github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0</li>
</ul>
<h2 id="2vue3带来了什么">2.Vue3带来了什么</h2>
<h3 id="1性能的提升">1.性能的提升</h3>
<ul>
<li>
<p>打包大小减少41%</p>
</li>
<li>
<p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li>
<p>内存减少54%</p>
<p>......</p>
</li>
</ul>
<h3 id="2源码的升级">2.源码的升级</h3>
<ul>
<li>
<p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li>
<p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>......</p>
</li>
</ul>
<h3 id="3拥抱typescript">3.拥抱TypeScript</h3>
<ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3 id="4新的特性">4.新的特性</h3>
<ol>
<li>
<p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>......</li>
</ul>
</li>
<li>
<p>新的内置组件</p>
<ul>
<li>Fragment</li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li>
<p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>......</li>
</ul>
</li>
</ol>
<h1 id="一-创建vue30工程">一、创建Vue3.0工程</h1>
<h2 id="1使用-vue-cli-创建">1.使用 vue-cli 创建</h2>
<p>官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</p>
<pre><code class="language-bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
vue --version
## 安装或者升级你的@vue/cli
npm install -g @vue/cli
## 创建
vue create vue_test
## 启动
cd vue_test
npm run serve
</code></pre>
<h2 id="2使用-vite-创建">2.使用 vite 创建</h2>
<p>官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite</p>
<p>vite官网：https://vitejs.cn</p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：
<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p>
<pre><code class="language-bash">## 创建工程
npm init vite-app &lt;project-name&gt;
## 进入工程目录
cd &lt;project-name&gt;
## 安装依赖
npm install
## 运行
npm run dev
</code></pre>
<h1 id="二-常用-composition-api">二、常用 Composition API</h1>
<p>官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html</p>
<h2 id="1拉开序幕的setup">1.拉开序幕的setup</h2>
<ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：
<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：
<ol>
<li>尽量不要与Vue2.x配置混用
<ul>
<li>Vue2.x配置（data、methos、computed...）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed...）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h2 id="2ref函数">2.ref函数</h2>
<ul>
<li>作用: 定义一个响应式的数据</li>
<li>语法: <code>const xxx = ref(initValue)</code>
<ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{{xxx}}&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：
<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="3reactive函数">3.reactive函数</h2>
<ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h2 id="4vue30中的响应式原理">4.Vue3.0中的响应式原理</h2>
<h3 id="vue2x的响应式">vue2.x的响应式</h3>
<ul>
<li>
<p>实现原理：</p>
<ul>
<li>
<p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li>
<p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<pre><code class="language-js">Object.defineProperty(data, 'count', {
    get () {}, 
    set () {}
})
</code></pre>
</li>
</ul>
</li>
<li>
<p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="vue30的响应式">Vue3.0的响应式</h3>
<ul>
<li>实现原理:
<ul>
<li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li>
<li>通过Reflect（反射）:  对源对象的属性进行操作。</li>
<li>MDN文档中描述的Proxy与Reflect：
<ul>
<li>
<p>Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</p>
</li>
<li>
<p>Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</p>
<pre><code class="language-js">new Proxy(data, {
	// 拦截读取属性值
    get (target, prop) {
    	return Reflect.get(target, prop)
    },
    // 拦截设置属性值或添加新属性
    set (target, prop, value) {
    	return Reflect.set(target, prop, value)
    },
    // 拦截删除属性
    deleteProperty (target, prop) {
    	return Reflect.deleteProperty(target, prop)
    }
})

proxy.name = 'tom'   
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5reactive对比ref">5.reactive对比ref</h2>
<ul>
<li>从定义数据角度对比：
<ul>
<li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：
<ul>
<li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：
<ul>
<li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2 id="6setup的两个注意点">6.setup的两个注意点</h2>
<ul>
<li>
<p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li>
<p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象
<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7计算属性与监视">7.计算属性与监视</h2>
<h3 id="1computed函数">1.computed函数</h3>
<ul>
<li>
<p>与Vue2.x中computed配置功能一致</p>
</li>
<li>
<p>写法</p>
<pre><code class="language-js">import {computed} from 'vue'

setup(){
    ...
	//计算属性——简写
    let fullName = computed(()=&gt;{
        return person.firstName + '-' + person.lastName
    })
    //计算属性——完整
    let fullName = computed({
        get(){
            return person.firstName + '-' + person.lastName
        },
        set(value){
            const nameArr = value.split('-')
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        }
    })
}
</code></pre>
</li>
</ul>
<h3 id="2watch函数">2.watch函数</h3>
<ul>
<li>
<p>与Vue2.x中watch配置功能一致</p>
</li>
<li>
<p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<pre><code class="language-js">//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=&gt;{
	console.log('sum变化了',newValue,oldValue)
},{immediate:true})

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=&gt;{
	console.log('sum或msg变化了',newValue,oldValue)
}) 

/* 情况三：监视reactive定义的响应式数据
			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=&gt;{
	console.log('person变化了',newValue,oldValue)
},{immediate:true,deep:false}) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true}) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true})

//特殊情况
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
    console.log('person的job变化了',newValue,oldValue)
},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
</code></pre>
</li>
</ul>
<h3 id="3watcheffect函数">3.watchEffect函数</h3>
<ul>
<li>
<p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li>
<p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li>
<p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<pre><code class="language-js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=&gt;{
    const x1 = sum.value
    const x2 = person.age
    console.log('watchEffect配置的回调执行了')
})
</code></pre>
</li>
</ul>
<h2 id="8生命周期">8.生命周期</h2>
<h3 id="vue2x的生命周期">Vue2.x的生命周期</h3>
<img src="https://v2.cn.vuejs.org/images/lifecycle.png" alt="img" style="zoom: 50%;" />
<h3 id="vue30的生命周期">Vue3.0的生命周期</h3>
<img src="https://cn.vuejs.org/assets/lifecycle.16e4c08e.png" alt="img" style="zoom:50%;" />
<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：
<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：
<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>===&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>===&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> ===&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> ===&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h2 id="9自定义hook函数">9.自定义hook函数</h2>
<ul>
<li>
<p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li>
<p>类似于vue2.x中的mixin。</p>
</li>
<li>
<p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h2 id="10toref">10.toRef</h2>
<ul>
<li>
<p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li>
<p>语法：<code>const name = toRef(person,'name')</code></p>
</li>
<li>
<p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li>
<p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
</li>
</ul>
<h1 id="三-其它-composition-api">三、其它 Composition API</h1>
<h2 id="1shallowreactive-与-shallowref">1.shallowReactive 与 shallowRef</h2>
<ul>
<li>
<p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li>
<p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li>
<p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="2readonly-与-shallowreadonly">2.readonly 与 shallowReadonly</h2>
<ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="3toraw-与-markraw">3.toRaw 与 markRaw</h2>
<ul>
<li>toRaw：
<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：
<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:
<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4customref">4.customRef</h2>
<ul>
<li>
<p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li>
<p>实现防抖效果：</p>
<pre><code class="language-vue">&lt;template&gt;
	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;
	&lt;h3&gt;{{keyword}}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref,customRef} from 'vue'
	export default {
		name:'Demo',
		setup(){
			// let keyword = ref('hello') //使用Vue准备好的内置ref
			//自定义一个myRef
			function myRef(value,delay){
				let timer
				//通过customRef去实现自定义
				return customRef((track,trigger)=&gt;{
					return{
						get(){
							track() //告诉Vue这个value值是需要被“追踪”的
							return value
						},
						set(newValue){
							clearTimeout(timer)
							timer = setTimeout(()=&gt;{
								value = newValue
								trigger() //告诉Vue去更新界面
							},delay)
						}
					}
				})
			}
			let keyword = myRef('hello',500) //使用程序员自定义的ref
			return {
				keyword
			}
		}
	}
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2 id="5provide-与-inject">5.provide 与 inject</h2>
<img src="https://v3.cn.vuejs.org/images/components_provide.png" style="zoom:50%;"/>
<ul>
<li>
<p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li>
<p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li>
<p>具体写法：</p>
<ol>
<li>
<p>祖组件中：</p>
<pre><code class="language-js">setup(){
	......
    let car = reactive({name:'奔驰',price:'40万'})
    provide('car',car)
    ......
}
</code></pre>
</li>
<li>
<p>后代组件中：</p>
<pre><code class="language-js">setup(props,context){
	......
    const car = inject('car')
    return {car}
	......
}
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="6响应式数据的判断">6.响应式数据的判断</h2>
<ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h1 id="四-composition-api-的优势">四、Composition API 的优势</h1>
<h2 id="1options-api-存在的问题">1.Options API 存在的问题</h2>
<p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;"/>
 <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;"/> 
<h2 id="2composition-api-的优势">2.Composition API 的优势</h2>
<p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;"/>
 <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;"/> 
<h1 id="五-新的组件">五、新的组件</h1>
<h2 id="1fragment">1.Fragment</h2>
<ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h2 id="2teleport">2.Teleport</h2>
<ul>
<li>
<p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<pre><code class="language-vue">&lt;teleport to=&quot;移动位置&quot;&gt;
	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
		&lt;div class=&quot;dialog&quot;&gt;
			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;
			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/teleport&gt;
</code></pre>
</li>
</ul>
<h2 id="3suspense">3.Suspense</h2>
<ul>
<li>
<p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li>
<p>使用步骤：</p>
<ul>
<li>
<p>异步引入组件</p>
<pre><code class="language-js">import {defineAsyncComponent} from 'vue'
const Child = defineAsyncComponent(()=&gt;import('./components/Child.vue'))
</code></pre>
</li>
<li>
<p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<pre><code class="language-vue">&lt;template&gt;
	&lt;div class=&quot;app&quot;&gt;
		&lt;h3&gt;我是App组件&lt;/h3&gt;
		&lt;Suspense&gt;
			&lt;template v-slot:default&gt;
				&lt;Child/&gt;
			&lt;/template&gt;
			&lt;template v-slot:fallback&gt;
				&lt;h3&gt;加载中.....&lt;/h3&gt;
			&lt;/template&gt;
		&lt;/Suspense&gt;
	&lt;/div&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="六-其他">六、其他</h1>
<h2 id="1全局api的转移">1.全局API的转移</h2>
<ul>
<li>
<p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li>
<p>例如：注册全局组件、注册全局指令等。</p>
<pre><code class="language-js">//注册全局组件
Vue.component('MyButton', {
  data: () =&gt; ({
    count: 0
  }),
  template: '&lt;button @click=&quot;count++&quot;&gt;Clicked {{ count }} times.&lt;/button&gt;'
})

//注册全局指令
Vue.directive('focus', {
  inserted: el =&gt; el.focus()
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li>
<p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h2 id="2其他改变">2.其他改变</h2>
<ul>
<li>
<p>data选项应始终被声明为一个函数。</p>
</li>
<li>
<p>过度类名的更改：</p>
<ul>
<li>
<p>Vue2.x写法</p>
<pre><code class="language-css">.v-enter,
.v-leave-to {
  opacity: 0;
}
.v-leave,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
<li>
<p>Vue3.x写法</p>
<pre><code class="language-css">.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-leave-from,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li>
<p>父组件中绑定事件</p>
<pre><code class="language-vue">&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;
</code></pre>
</li>
<li>
<p>子组件中声明自定义事件</p>
<pre><code class="language-vue">&lt;script&gt;
  export default {
    emits: ['close']
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li>
<p>......</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSM整合]]></title>
        <id>https://kuangyang828.github.io/ssm-zheng-he/</id>
        <link href="https://kuangyang828.github.io/ssm-zheng-he/">
        </link>
        <updated>2022-07-26T06:44:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>视频课程链接：<br>
<a href="https://youtube.com/playlist?list=PLmOn9nNkQxJFbsU4Qz8CdRiVM4Qs3ci75">🔗YouTube（下载资料更方便）</a><br>
<a href="https://www.bilibili.com/video/BV1Ya411S7aT">🔗bilibili</a></p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727103525.png" alt="" loading="lazy"></figure>
<h1 id="ssm整合">SSM整合</h1>
<h1 id="1-contextloaderlistener">1、ContextLoaderListener</h1>
<p>Spring提供了监听器ContextLoaderListener，实现ServletContextListener接口，可监听 ServletContext 的状态，在web服务器的启动，读取Spring的配置文件，创建Spring的IOC容器。web 应用中必须在web.xml中配置</p>
<pre><code class="language-xml">&lt;!--
    配置Spring的监听器，在服务器启动时加载Spring的配置文件
    Spring配置文件默认位置和名称：/WEB-INF/applicationContext.xml
    可通过上下文参数自定义Spring配置文件的位置和名称
 --&gt;
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;!-- 设置Spring的配置文件的位置和名称 --&gt;
&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:Spring.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<h1 id="2-准备工作">2、准备工作</h1>
<h2 id="1创建maven-module">①创建Maven Module</h2>
<h2 id="2导入依赖">②导入依赖</h2>
<pre><code class="language-xml">&lt;packaging&gt;war&lt;/packaging&gt;

&lt;properties&gt;
    &lt;spring.version&gt;5.3.1&lt;/spring.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--springmvc--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Mybatis核心 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--mybatis和spring的整合包--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- druid连接池 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.0.9&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- MySQL驱动 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.38&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- log4j日志 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
        &lt;version&gt;1.2.17&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
        &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
        &lt;version&gt;5.2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 日志 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- ServletAPI --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;version&gt;2.12.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
        &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;version&gt;1.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Spring5和Thymeleaf整合包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;
        &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;
        &lt;version&gt;3.0.12.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h2 id="3创建表">③创建表</h2>
<pre><code class="language-sql">CREATE TABLE `t_emp`(
    `emp_id`   int(11) NOT NULL AUTO_INCREMENT,
    `emp_name` varchar(20) DEFAULT NULL,
    `age`      int(11) DEFAULT NULL,
    `sex`      char(1)     DEFAULT NULL,
    `email`    varchar(50) DEFAULT NULL,
    PRIMARY KEY (`emp_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
</code></pre>
<h1 id="3-配置webxml">3、配置web.xml</h1>
<pre><code class="language-xml">&lt;!--配置springMVC的编码过滤器--&gt;
&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;!--如果只设置encoding参数则编码过滤器只对请求request生效--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--设置forceResponseEncoding参数为true，编码过滤器才对响应respose生效--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

&lt;!-- 配置处理请求方式PUT和DELETE的过滤器 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

&lt;!-- 配置SpringMVC的前端控制器 --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 设置SpringMVC的配置文件的位置和名称 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:SpringMVC.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!-- 将DispatcherServlet 的初始化时间提前到服务器启动时 --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;!-- 配置Spring的监听器 --&gt;
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;!-- 设置Spring的配置文件的位置和名称 --&gt;
&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:Spring.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<h1 id="4-创建springmvc的配置文件并配置">4、创建SpringMVC的配置文件并配置</h1>
<pre><code class="language-xml">&lt;!--扫描控制层组件--&gt;
&lt;context:component-scan base-package=&quot;com.atguigu.controller&quot;&gt;&lt;/context:component-scan&gt;

&lt;!--配置视图解析器--&gt;
&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;
    &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;
    &lt;property name=&quot;templateEngine&quot;&gt;
        &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt;
            &lt;property name=&quot;templateResolver&quot;&gt;
                &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;
                    &lt;!-- 视图前缀 --&gt;
                    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;
                    &lt;!-- 视图后缀 --&gt;
                    &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt;
                    &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt;
                    &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置默认的servlet处理静态资源 --&gt;
&lt;mvc:default-servlet-handler/&gt;

&lt;!-- 开启MVC的注解驱动 --&gt;
&lt;mvc:annotation-driven/&gt;

&lt;!-- 配置访问首页的视图控制器 --&gt;
&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;&gt;&lt;/mvc:view-controller&gt;

&lt;!-- 处理CORS --&gt;
&lt;mvc:cors&gt;
    &lt;!--
        allowed-origins: &lt;origin&gt; | *
        其中，origin 参数的值指定允许访问该资源的外域 origin 域名。
        对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符*，表示允许来自所有域的请求。
    --&gt;
    &lt;!--&lt;mvc:mapping path=&quot;/**&quot; allowed-origins=&quot;http:/z/example.com/&quot; allowed-methods=&quot;GET,POST&quot; max-age=&quot;3600&quot;/&gt;--&gt;
    &lt;!--
        allowed-origin-patterns
        替代llowed-origins，此属性允许更灵活的模式，例如 *.domain1.com
    --&gt;
    &lt;mvc:mapping path=&quot;/**&quot; allowed-origin-patterns=&quot;http://localhost:*&quot; allowed-methods=&quot;GET,POST&quot; max-age=&quot;3600&quot;/&gt;
&lt;/mvc:cors&gt;
</code></pre>
<h1 id="5-搭建mybatis环境">5、搭建MyBatis环境</h1>
<h2 id="1创建属性文件jdbcproperties">①创建属性文件jdbc.properties</h2>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/mydb?characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false
# jdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
jdbc.username=root
jdbc.password=
</code></pre>
<h2 id="2创建mybatis的核心配置文件mybatis-configxml">②创建MyBatis的核心配置文件mybatis-config.xml</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;!--将表中字段的下划线自动转换为驼峰--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
        &lt;!--开启延迟加载--&gt;
        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;!--设置类型别名--&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.atguigu.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;plugins&gt;
        &lt;!--设置分页插件--&gt;
        &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
            &lt;!--reasonable：分页合理化参数，默认值为false,直接根据参数进行查询。
              当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。--&gt;
            &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;

    &lt;!--引入映射文件--&gt;
    &lt;mappers&gt;
        &lt;!--        &lt;mapper resource=&quot;mybatisdemo/mappers/UserMapper.xml&quot;/&gt;--&gt;
        &lt;!--
        以包为单位，将包下所有的映射文件引入核心配置文件
        注意：
			1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下
			2. mapper接口要和mapper映射文件的名字一致
			&lt;package name=&quot;com.example.mybatis.mapper&quot;/&gt;
        --&gt;
        &lt;package name=&quot;com.atguigu.mapper&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h2 id="3创建mapper接口和映射文件">③创建Mapper接口和映射文件</h2>
<pre><code class="language-java">public interface EmployeeMapper {
    List&lt;Employee&gt; getEmployeeList();
}
</code></pre>
<pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.atguigu.ssm.mapper.EmployeeMapper&quot;&gt;
    
    &lt;select id=&quot;getEmployeeList&quot; resultType=&quot;Employee&quot;&gt;
        select *
        from t_emp
    &lt;/select&gt;
    
&lt;/mapper&gt;
</code></pre>
<blockquote>
<ul>
<li>
<p>关于mapper映射文件的位置一般有两种写法：</p>
<ul>
<li>
<p>a. MyBatis映射文件存放的位置是src/main/resources/mappers目录下</p>
</li>
<li>
<p>b. 将MyBatis映射文件存放到src/main/java同一目录下，</p>
<ul>
<li>
<p>此时需要在pom.xml中手动指定映射文件的存放位置，因为这样Maven才会编译这些xml</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
</li>
<li>
<p>在mybatis中配置映射文件的存放位置</p>
<pre><code class="language-xml">&lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;&gt;&lt;/property&gt;
    &lt;!--
     设置映射文件的路径
     只有映射文件的包和mapper接口的包不一致时需要设置
     --&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/xxxxx/mapper/xml/*.xml&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="4创建日志文件log4jxml">④创建日志文件log4j.xml</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;
&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;
    &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;
        &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot;/&gt;
        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
            &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \n&quot;/&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;logger name=&quot;java.sql&quot;&gt;
        &lt;level value=&quot;debug&quot;/&gt;
    &lt;/logger&gt;
    &lt;logger name=&quot;org.apache.ibatis&quot;&gt;
        &lt;level value=&quot;info&quot;/&gt;
    &lt;/logger&gt;
    &lt;root&gt;
        &lt;level value=&quot;debug&quot;/&gt;
        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
</code></pre>
<h1 id="6-创建spring的配置文件并配置">6、创建Spring的配置文件并配置</h1>
<pre><code class="language-xml">&lt;!--扫描组件（除控制层）--&gt;
&lt;content:component-scan base-package=&quot;com.atguigu&quot;&gt;
    &lt;content:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
&lt;/content:component-scan&gt;

&lt;!-- 引入jdbc.properties --&gt;
&lt;content:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/content:property-placeholder&gt;

&lt;!-- 配置Druid数据源 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置用于创建SqlSessionFactory的工厂bean，可以直接在Spring的IOC中获取SqlSessionFactory --&gt;
&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;!-- 设置MyBatis核心配置文件的路径（可以不设置） --&gt;
    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;
    &lt;/property&gt;
    &lt;!-- 设置数据源 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;!--
     设置映射文件的路径
     只有映射文件的包和mapper接口的包不一致时需要设置
     --&gt;
    &lt;!--
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;&gt;
    &lt;/property&gt;
    --&gt;
&lt;/bean&gt;

&lt;!--
    配置mapper接口的扫描
    可以将指定包下所有的mapper接口通过SqlSessionFactory创建动态代理实现类对象
    并将这些对象作为bean交给IOC容器管理
--&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.atguigu.mapper&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!--配置事务管理器--&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!--
开启事务的注解驱动
通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务
--&gt;
&lt;!--
 transaction-manager属性的默认值是transactionManager，
 如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性
--&gt;
&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;
</code></pre>
<h1 id="7-测试功能">7、测试功能</h1>
<h2 id="1创建组件">①创建组件</h2>
<p>实体类Employee</p>
<pre><code class="language-java">public class Employee {

    private Integer empId;
    private String empName;
    private Integer age;
    private String sex;
    private String email;

    public Employee() {
    }

    public Employee(Integer empId, String empName, Integer age, String sex, String email) {
        this.empId = empId;
        this.empName = empName;
        this.age = age;
        this.sex = sex;
        this.email = email;
    }

    public Integer getEmpId() {
        return empId;
    }

    public void setEmpId(Integer empId) {
        this.empId = empId;
    }

    public String getEmpName() {
        return empName;
    }

    public void setEmpName(String empName) {
        this.empName = empName;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return &quot;Employee{&quot; +
                &quot;empId=&quot; + empId +
                &quot;, empName='&quot; + empName + '\'' +
                &quot;, age=&quot; + age +
                &quot;, sex='&quot; + sex + '\'' +
                &quot;, email='&quot; + email + '\'' +
                '}';
    }
}
</code></pre>
<p>创建控制层组件EmployeeController</p>
<pre><code class="language-java">@Controller
public class EmployeeController {
    @Autowired
    private EmployeeService employeeService;

    @RequestMapping(value = &quot;/employee/page/{pageNum}&quot;, method =
            RequestMethod.GET)
    public String getEmployeeList(Model model, @PathVariable(&quot;pageNum&quot;) Integer
            pageNum) {
        PageInfo&lt;Employee&gt; page = employeeService.getEmployeeList(pageNum);
        model.addAttribute(&quot;page&quot;, page);
        return &quot;employee_list&quot;;
    }
}
</code></pre>
<p>创建接口EmployeeService</p>
<pre><code class="language-java">public interface EmployeeService {
    PageInfo&lt;Employee&gt; getEmployeeList(Integer pageNum);
}
</code></pre>
<p>创建实现类EmployeeServiceImpl</p>
<pre><code class="language-java">@Service
public class EmployeeServiceImpl implements EmployeeService {
    @Autowired
    private EmployeeMapper employeeMapper;

    @Override
    public PageInfo&lt;Employee&gt; getEmployeeList(Integer pageNum) {
        PageHelper.startPage(pageNum, 4);
        List&lt;Employee&gt; list = employeeMapper.getEmployeeList();
        PageInfo&lt;Employee&gt; page = new PageInfo&lt;&gt;(list, 5);
        return page;
    }
}
</code></pre>
<h2 id="2创建页面">②创建页面</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Employee Info&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@{/static/css/index_work.css}&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th colspan=&quot;6&quot;&gt;Employee Info&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;emp_id&lt;/th&gt;
        &lt;th&gt;emp_name&lt;/th&gt;
        &lt;th&gt;age&lt;/th&gt;
        &lt;th&gt;sex&lt;/th&gt;
        &lt;th&gt;email&lt;/th&gt;
        &lt;th&gt;options&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr th:each=&quot;employee : ${page.list}&quot;&gt;
        &lt;td th:text=&quot;${employee.empId}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${employee.empName}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${employee.age}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${employee.sex}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${employee.email}&quot;&gt;&lt;/td&gt;
        &lt;td&gt;
            &lt;a href=&quot;&quot;&gt;delete&lt;/a&gt;
            &lt;a href=&quot;&quot;&gt;update&lt;/a&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td colspan=&quot;6&quot;&gt;
             &lt;span th:if=&quot;${page.hasPreviousPage}&quot;&gt;
                    &lt;a th:href=&quot;@{/employee/page/1}&quot;&gt;首页&lt;/a&gt;
                    &lt;a th:href=&quot;@{'/employee/page/'+${page.prePage}}&quot;&gt;上一页&lt;/a&gt;
             &lt;/span&gt;
            &lt;span th:each=&quot;num : ${page.navigatepageNums}&quot;&gt;
                    &lt;a th:if=&quot;${page.pageNum==num}&quot;
                       th:href=&quot;@{'/employee/page/'+${num}}&quot; th:text=&quot;'['+${num}+']'&quot; style=&quot;color:
                    red;&quot;&gt;&lt;/a&gt;
                    &lt;a th:if=&quot;${page.pageNum!=num}&quot;
                       th:href=&quot;@{'/employee/page/'+${num}}&quot; th:text=&quot;${num} &quot;&gt;&lt;/a&gt;
            &lt;/span&gt;
            &lt;span th:if=&quot;${page.hasNextPage}&quot;&gt;
                    &lt;a th:href=&quot;@{'/employee/page/'+${page.nextPage}}&quot;&gt;下一页&lt;/a&gt;
                    &lt;a th:href=&quot;@{'/employee/page/'+${page.pages}}&quot;&gt;末页&lt;/a&gt;
            &lt;/span&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3访问测试分页功能">③访问测试分页功能</h2>
<p>localhost:8080/employee/page/1</p>
<h1 id="8-加入druid监控">8、加入Druid监控</h1>
<h2 id="1创建属性文件druidproperties">①创建属性文件druid.properties</h2>
<pre><code class="language-properties">#连接池建立时创建的初始化连接数
pool.init=1
#连接池中最小空闲连接数
pool.minIdle=3
#连接池中最大的活跃连接数
pool.maxActive=20
#定义最长等待时间
pool.maxWait=60000
</code></pre>
<h2 id="2在spring配置文件中为druid数据源添加相应的属性">②在Spring配置文件中为Druid数据源添加相应的属性</h2>
<pre><code class="language-xml">&lt;!-- 引入jdbc.properties和druid.properties --&gt;
&lt;content:property-placeholder location=&quot;classpath:jdbc.properties,classpath:druid.properties&quot;&gt;&lt;/content:property-placeholder&gt;

&lt;!-- 配置Druid数据源 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;
    &lt;!--数据源控制属性--&gt;
    &lt;!-- 配置初始化大小、最小、最大 --&gt;
    &lt;property name=&quot;initialSize&quot; value=&quot;${pool.init}&quot;/&gt;
    &lt;property name=&quot;minIdle&quot; value=&quot;${pool.minIdle}&quot;/&gt;
    &lt;property name=&quot;maxActive&quot; value=&quot;${pool.maxActive}&quot;/&gt;
    &lt;!-- 配置获取连接等待超时的时间 --&gt;
    &lt;property name=&quot;maxWait&quot; value=&quot;${pool.maxWait}&quot;/&gt;
    &lt;!-- 配置监控统计拦截的filters --&gt;
    &lt;property name=&quot;filters&quot; value=&quot;stat&quot;/&gt;
    &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;
    &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;2000&quot;/&gt;
    &lt;!--其他配置--&gt;
    &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot;/&gt;
    &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt;
    &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot;/&gt;
    &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot;/&gt;
    &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;
    &lt;property name=&quot;maxOpenPreparedStatements&quot; value=&quot;20&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h2 id="3在webxml中配置监控页面">③在web.xml中配置监控页面</h2>
<pre><code class="language-xml">&lt;!-- druid监控配置--&gt;
&lt;!-- 参考文档：https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;!-- 允许清空统计数据 --&gt;
        &lt;param-name&gt;resetEnable&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--配置访问监控页面登录的用户名和密码（可选），实际开发中都会配置--&gt;
    &lt;init-param&gt;
        &lt;!-- 用户名 --&gt;
        &lt;param-name&gt;loginUsername&lt;/param-name&gt;
        &lt;param-value&gt;druid&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;!-- 密码 --&gt;
        &lt;param-name&gt;loginPassword&lt;/param-name&gt;
        &lt;param-value&gt;druid&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;
    &lt;!-- 访问监控页面的映射请求，实际访问一般都在浏览器输入http://xxx/druid/index --&gt;
    &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac设置JAVA_HOME环境变量]]></title>
        <id>https://kuangyang828.github.io/mac-she-zhi-java_home-huan-jing-bian-liang/</id>
        <link href="https://kuangyang828.github.io/mac-she-zhi-java_home-huan-jing-bian-liang/">
        </link>
        <updated>2022-07-25T05:38:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="获取java的安装路径">获取JAVA的安装路径</h2>
<ul>
<li>这个命令可以用来显示电脑中安装的所有Java JDK</li>
</ul>
<pre><code>/usr/libexec/java_home -V
</code></pre>
<h2 id="添加java_home到profile">添加JAVA_HOME到profile</h2>
<pre><code>vi ~/.bash_profile
</code></pre>
<p>添加如下环境配置</p>
<pre><code># java
JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home&quot;
export JAVA_HOME
PATH=$PATH:$JAVA_HOME/bin
export PATH
</code></pre>
<h2 id="让配置生效">让配置生效</h2>
<pre><code>source ~/.bash_profile
</code></pre>
<h2 id="测试">测试</h2>
<pre><code>echo $JAVA_HOME
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring笔记]]></title>
        <id>https://kuangyang828.github.io/spring-bi-ji/</id>
        <link href="https://kuangyang828.github.io/spring-bi-ji/">
        </link>
        <updated>2022-07-21T14:50:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>视频课程链接：<br>
<a href="https://www.bilibili.com/video/BV1Ya411S7aT?p=63">🔗bilibili（新版）</a><br>
<a href="https://www.bilibili.com/video/BV1Vf4y127N5">🔗bilibili（旧版）</a></p>
</blockquote>
<h1 id="1-spring简介">1、Spring简介</h1>
<h2 id="11-spring概述">1.1、Spring概述</h2>
<p>官网地址：https://spring.io/</p>
<blockquote>
<p>Spring 是<code>最受欢迎</code>的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。</p>
<p>Spring 框架是一个<code>开源</code>的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首 次在 Apache 2.0 许可下发布。</p>
<p>Spring 是<code>轻量级</code>的框架，其基础版本只有 2 MB 左右的大小。</p>
<p>Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程实践。</p>
</blockquote>
<h2 id="12-spring家族">1.2、Spring家族</h2>
<p>项目列表：https://spring.io/projects</p>
<h2 id="13-spring-framework">1.3、Spring Framework</h2>
<p>Spring 基础框架，可以视为 Spring 基础设施，基本上任何其他 Spring 项目都是以 Spring Framework 为基础的。</p>
<h3 id="131-spring-framework特性">1.3.1、Spring Framework特性</h3>
<ul>
<li>非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。</li>
<li>控制反转：IOC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。</li>
<li>面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。</li>
<li>容器：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。</li>
<li>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。</li>
<li>声明式：很多以前需要编写代码才能实现的功能，现在只需要声明需求即可由框架代为实现。</li>
<li>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。</li>
</ul>
<h3 id="132-spring-framework五大功能模块">1.3.2、Spring Framework五大功能模块</h3>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core Container</td>
<td>核心容器，在Spring环境下使用任何功能都必须基于IOC容器。</td>
</tr>
<tr>
<td>AOP&amp;Aspects</td>
<td>面向切面编程。</td>
</tr>
<tr>
<td>Testing</td>
<td>提供了对 junit 或 TestNG 测试框架的整合。</td>
</tr>
<tr>
<td>Data Access/Integration</td>
<td>提供了对数据访问/集成的功能。</td>
</tr>
<tr>
<td>Spring MVC</td>
<td>提供了面向Web应用程序的集成功能</td>
</tr>
</tbody>
</table>
<h1 id="2-ioc">2、IOC</h1>
<h2 id="21-ioc容器">2.1、IOC容器</h2>
<h3 id="211-ioc思想">2.1.1、IOC思想</h3>
<p>IOC：Inversion of Control，翻译过来是<strong>反转控制</strong>。</p>
<h4 id="1获取资源的传统方式">①获取资源的传统方式</h4>
<p>自己做饭：买菜、洗菜、择菜、改刀、炒菜，全过程参与，费时费力，必须清楚了解资源创建整个过程中的全部细节且熟练掌握。</p>
<p>在应用程序中的组件需要获取资源时，传统的方式是组件<strong>主动</strong>的从容器中获取所需要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。</p>
<h4 id="2反转控制方式获取资源">②反转控制方式获取资源</h4>
<p>点外卖：下单、等、吃，省时省力，不必关心资源创建过程的所有细节。</p>
<p>反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向———改由容器主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的<strong>被动</strong>形式。</p>
<h4 id="3di">③DI</h4>
<p>DI：Dependency Injection，翻译过来是<strong>依赖注入</strong>。</p>
<p>DI 是 IOC 的另一种表述方式（实现方式）：即组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器的资源注入。相对于IOC而言，这种表述更直接。</p>
<p>所以结论是：IOC 就是一种反转控制的思想， 而 DI 是对 IOC 的一种==<strong>具体实现</strong>==。</p>
<h3 id="212-ioc容器在spring中的实现">2.1.2、IOC容器在Spring中的实现</h3>
<p>Spring 的 IOC 容器就是 IOC 思想的一个落地的产品实现。IOC 容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建 IOC 容器。Spring 提供了 IOC 容器的两种实现方式：</p>
<h4 id="1beanfactory">①BeanFactory</h4>
<ul>
<li>这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。</li>
</ul>
<h4 id="2applicationcontext">②ApplicationContext</h4>
<ul>
<li>BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</li>
</ul>
<blockquote>
<p>以后在 Spring 环境下看到一个类或接口的名称中包含 ApplicationContext，那基本就可以断定，这个类或接口与 IOC 容器有关。</p>
</blockquote>
<h4 id="3applicationcontext的主要实现类">③ApplicationContext的主要实现类</h4>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721104046.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClassPathXmlApplicationContext</td>
<td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>ConfigurableApplicationContext</td>
<td>ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文（容器）的能力。</td>
</tr>
<tr>
<td>WebApplicationContext</td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td>
</tr>
</tbody>
</table>
<h2 id="22-基于xml管理bean">2.2、基于XML管理bean</h2>
<h3 id="221-实验一创建bean">2.2.1、实验一：创建bean</h3>
<h4 id="1创建maven-module">①创建Maven Module</h4>
<h4 id="2引入依赖">②引入依赖</h4>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721105410.png" alt="" loading="lazy"></figure>
<h4 id="3创建类helloworld">③创建类HelloWorld</h4>
<pre><code class="language-java">package com.atguigu.spring.pojo;

public class HelloWorld {
    public void sayHello() {
        System.out.println(&quot;Hello Spring&quot;);
    }
}
</code></pre>
<h4 id="4创建spring的配置文件">④创建Spring的配置文件</h4>
<p>applicationContext.xml</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721110013.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721110038.png" alt="" loading="lazy"></figure>
<h4 id="5在spring的配置文件中配置bean">⑤在Spring的配置文件中配置bean</h4>
<pre><code class="language-xml">&lt;!--
		配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理
		通过bean标签配置IOC容器所管理的bean
		属性：
				id：设置bean的唯一标识
				class：设置bean所对应类型的全类名
--&gt;
&lt;bean id=&quot;helloworld&quot; class=&quot;com.atguigu.spring.bean.HelloWorld&quot;&gt;&lt;/bean&gt;
</code></pre>
<h4 id="6创建测试类测试">⑥创建测试类测试</h4>
<pre><code class="language-java">@Test
public void testHelloWorld() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    HelloWorld helloWorld = ioc.getBean(HelloWorld.class);
    helloWorld.sayHello();
}
</code></pre>
<h4 id="7思路">⑦思路</h4>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721112410.png" alt="" loading="lazy"></figure>
<h4 id="8注意">⑧注意</h4>
<p>Spring 底层默认通过反射技术调用组件类的无参构造器来创建组件对象，这一点需要注意。如果在需要无参构造器时，没有无参构造器，则会抛出下面的异常：</p>
<blockquote>
<p>org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'helloworld' defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.atguigu.spring.bean.HelloWorld]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.atguigu.spring.bean.HelloWorld. ()</p>
</blockquote>
<h3 id="222-实验二获取bean">2.2.2、实验二：获取bean</h3>
<h4 id="1方式一根据id获取">①方式一：根据id获取</h4>
<p>由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。</p>
<h4 id="2方式二根据类型获取">②方式二：根据类型获取</h4>
<pre><code class="language-java">@Test
public void testHelloWorld() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    HelloWorld bean = ioc.getBean(HelloWorld.class);
    bean.sayHello();
}
</code></pre>
<h4 id="3方式三根据id和类型">③方式三：根据id和类型</h4>
<pre><code class="language-java">@Test
public void testHelloWorld() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    HelloWorld bean = ioc.getBean(&quot;helloworld&quot;, HelloWorld.class);
    bean.sayHello();
}
</code></pre>
<h4 id="4注意">④注意</h4>
<ul>
<li>
<p>当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个</p>
</li>
<li>
<p>当IOC容器中一共配置了两个：</p>
<pre><code class="language-xml">&lt;bean id=&quot;helloworldOne&quot; class=&quot;com.atguigu.spring.bean.HelloWorld&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;helloworldTwo&quot; class=&quot;com.atguigu.spring.bean.HelloWorld&quot;&gt;&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>根据类型获取时会抛出异常：</p>
<blockquote>
<p>org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.atguigu.spring.bean.HelloWorld' available: expected single matching bean but found 2: helloworldOne,helloworldTwo</p>
</blockquote>
</li>
</ul>
<h4 id="5扩展">⑤扩展</h4>
<p>如果组件类实现了接口，根据接口类型可以获取组件类 bean 吗？</p>
<blockquote>
<p>可以，前提是bean唯一</p>
</blockquote>
<p>如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取实现类 bean 吗？</p>
<blockquote>
<p>不行，因为bean不唯一</p>
</blockquote>
<p>如果一个父类只有一个子类，根据父类类型可以获取子类 bean 吗？</p>
<blockquote>
<p>可以，前提是bean唯一</p>
</blockquote>
<p>如果一个父类有多个子类，根据父类类型可以子类获取 bean 吗？</p>
<blockquote>
<p>不行，因为bean不唯一</p>
</blockquote>
<h4 id="6结论">⑥结论</h4>
<p>根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 <strong>instanceof</strong> 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。</p>
<h3 id="223-实验三依赖注入之setter注入">2.2.3、实验三：依赖注入之setter注入</h3>
<h4 id="1创建学生类student">①创建学生类Student</h4>
<pre><code class="language-java">public class Student {
    
    private Integer id;
    private String name;
    private Integer age;
    private String sex;

    public Student() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, sex='&quot; + sex + '\'' +
                '}';
    }

}
</code></pre>
<h4 id="2配置bean时为属性赋值">②配置bean时为属性赋值</h4>
<p>spring-di.xml</p>
<pre><code class="language-xml"> &lt;bean id=&quot;studentOne&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
     &lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt;
     &lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关）
     --&gt;
     &lt;!-- value属性：指定属性值 --&gt;
     &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
 &lt;/bean&gt;
</code></pre>
<h4 id="3测试">③测试</h4>
<pre><code class="language-java">@Test
public void testDIBySet() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;);
    Student studentOne = ioc.getBean(&quot;studentOne&quot;, Student.class);
    System.out.println(studentOne);
}
</code></pre>
<h3 id="224-实验四依赖注入之构造器注入">2.2.4、实验四：依赖注入之构造器注入</h3>
<h4 id="1在student类中添加有参构造">①在Student类中添加有参构造</h4>
<pre><code class="language-java">public Student(Integer id, String name, Integer age, String sex) {
    this.id = id;
    this.name = name;
    this.age = age;
    this.sex = sex;
}
</code></pre>
<h4 id="2配置bean">②配置bean</h4>
<pre><code class="language-xml">&lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;33&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>注意：</p>
<p>constructor-arg标签还有两个属性可以进一步描述构造器参数：</p>
<ul>
<li>index属性：指定参数所在位置的索引（从0开始）</li>
<li>name属性：指定参数名</li>
</ul>
</blockquote>
<h4 id="3测试-2">③测试</h4>
<pre><code class="language-java">@Test
public void testDIBySet() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;);
    Student studentOne = ioc.getBean(&quot;studentTwo&quot;, Student.class);
    System.out.println(studentOne);
}
</code></pre>
<h3 id="225-实验五特殊值处理">2.2.5、实验五：特殊值处理</h3>
<h4 id="1字面量赋值">①字面量赋值</h4>
<blockquote>
<p>什么是字面量？ (基本类型变量)</p>
<p>int a = 10;</p>
<p>声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。（这里10就是字面量）</p>
<p>而如果a是带引号的：'a'，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。</p>
</blockquote>
<pre><code class="language-xml">&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;
&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
</code></pre>
<h4 id="2null值">②null值</h4>
<pre><code class="language-xml"> &lt;property name=&quot;name&quot;&gt;
     &lt;null/&gt;
 &lt;/property&gt;
</code></pre>
<blockquote>
<p>注意：</p>
<pre><code class="language-xml">&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt;
</code></pre>
<p>以上写法，为name所赋的值是字符串null</p>
</blockquote>
<h4 id="3xml实体">③xml实体</h4>
<pre><code class="language-xml">&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;
&lt;!-- 解决方案一：使用XML实体来代替 --&gt;
&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt;
</code></pre>
<h4 id="4cdata节">④CDATA节</h4>
<pre><code class="language-xml">&lt;property name=&quot;expression&quot;&gt;
		&lt;!-- 解决方案二：使用CDATA节 --&gt;
		&lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt;
		&lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt;
		&lt;!-- 所以CDATA节中写什么符号都随意 --&gt;
&lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;
&lt;/property&gt;
</code></pre>
<h3 id="226-实验六为类类型属性赋值">2.2.6、实验六：为类类型属性赋值</h3>
<h4 id="1创建班级类clazz">①创建班级类Clazz</h4>
<pre><code class="language-java">public class Clazz {
    private Integer clazzId;
    private String clazzName;

    public Integer getClazzId() {
        return clazzId;
    }

    public void setClazzId(Integer clazzId) {
        this.clazzId = clazzId;
    }

    public String getClazzName() {
        return clazzName;
    }

    public void setClazzName(String clazzName) {
        this.clazzName = clazzName;
    }

    @Override
    public String toString() {
        return &quot;Clazz{&quot; +
                &quot;clazzId=&quot; + clazzId +
                &quot;, clazzName='&quot; + clazzName + '\'' +
                '}';
    }

    public Clazz() {
    }

    public Clazz(Integer clazzId, String clazzName) {
        this.clazzId = clazzId;
        this.clazzName = clazzName;
    }
}
</code></pre>
<h4 id="2修改student类">②修改Student类</h4>
<p>在Student类中添加以下代码：</p>
<pre><code class="language-java">private Clazz clazz;
public Clazz getClazz() {
    return clazz;
}
public void setClazz(Clazz clazz) {
    this.clazz = clazz;
}
</code></pre>
<h4 id="3方式一引用外部已声明的bean">③方式一：引用外部已声明的bean</h4>
<p>配置Clazz类型的bean：</p>
<pre><code class="language-xml">&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring.bean.Clazz&quot;&gt;
    &lt;property name=&quot;clazzId&quot; value=&quot;1111&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazzName&quot; value=&quot;财源滚滚班&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>为Student中的clazz属性赋值：</p>
<pre><code class="language-xml">&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;
    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>错误演示：</p>
<pre><code class="language-xml">&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazz&quot; value=&quot;clazzOne&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type 'java.lang.String' to required type 'com.atguigu.spring.bean.Clazz' for property 'clazz': no matching editors or conversion strategy found 意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值</p>
</blockquote>
<h4 id="4方式二内部bean">④方式二：内部bean</h4>
<pre><code class="language-xml">&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazz&quot;&gt;
        &lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt;
        &lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt;
        &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring.bean.Clazz&quot;&gt;
            &lt;property name=&quot;clazzId&quot; value=&quot;2222&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;clazzName&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="3方式三级联属性赋值">③方式三：级联属性赋值</h4>
<pre><code class="language-xml">&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;!-- 级联的方式，要保证提前为clazz属性赋值或者实例化 --&gt;
    &lt;!-- 所以这种方式相当于修改，一般不用级联赋值 --&gt;
    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazz.clazzId&quot; value=&quot;3333&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazz.clazzName&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="227-实验七为数组类型属性赋值">2.2.7、实验七：为数组类型属性赋值</h3>
<h4 id="1修改student类">①修改Student类</h4>
<p>在Student类中添加以下代码：</p>
<pre><code class="language-java">private String[] hobbies;
public String[] getHobbies() {
    return hobbies;
}
public void setHobbies(String[] hobbies) {
    this.hobbies = hobbies;

</code></pre>
<h4 id="2配置bean-2">②配置bean</h4>
<pre><code class="language-xml">&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;
    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;抽烟&lt;/value&gt;
            &lt;value&gt;喝酒&lt;/value&gt;
            &lt;value&gt;烫头&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="228-实验八为集合类型属性赋值">2.2.8、实验八：为集合类型属性赋值</h3>
<h4 id="1为list集合类型属性赋值">①为List集合类型属性赋值</h4>
<p>在Clazz类中添加以下代码：</p>
<pre><code class="language-java">private List&lt;Student&gt; students;
public List&lt;Student&gt; getStudents() {
    return students;
}
public void setStudents(List&lt;Student&gt; students) {
    this.students = students;
}
</code></pre>
<p>配置bean：</p>
<pre><code class="language-xml">&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring.bean.Clazz&quot;&gt;
    &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;students&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt;
            &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可</p>
</blockquote>
<h4 id="2为map集合类型属性赋值">②为Map集合类型属性赋值</h4>
<p>创建教师类Teacher：</p>
<pre><code class="language-java">public class Teacher {
    private Integer teacherId;

    private String teacherName;

    public Teacher() {
    }

    public Teacher(Integer teacherId, String teacherName) {
        this.teacherId = teacherId;
        this.teacherName = teacherName;
    }

    public Integer getTeacherId() {
        return teacherId;
    }

    public void setTeacherId(Integer teacherId) {
        this.teacherId = teacherId;
    }

    public String getTeacherName() {
        return teacherName;
    }

    public void setTeacherName(String teacherName) {
        this.teacherName = teacherName;
    }

    @Override
    public String toString() {
        return &quot;Teacher{&quot; +
                &quot;teacherId=&quot; + teacherId +
                &quot;, teacherName='&quot; + teacherName + '\'' +
                '}';
    }
}
</code></pre>
<p>在Student类中添加以下代码：</p>
<pre><code class="language-java">private Map&lt;String, Teacher&gt; teacherMap;
public Map&lt;String, Teacher&gt; getTeacherMap() {
    return teacherMap;
}
public void setTeacherMap(Map&lt;String, Teacher&gt; teacherMap) {
    this.teacherMap = teacherMap;
}
</code></pre>
<p>配置bean：</p>
<pre><code class="language-xml">&lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring.bean.Teacher&quot;&gt;
    &lt;property name=&quot;teacherId&quot; value=&quot;10010&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;teacherName&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring.bean.Teacher&quot;&gt;
    &lt;property name=&quot;teacherId&quot; value=&quot;10086&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;teacherName&quot; value=&quot;二宝&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;
    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;抽烟&lt;/value&gt;
            &lt;value&gt;喝酒&lt;/value&gt;
            &lt;value&gt;烫头&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name=&quot;teacherMap&quot;&gt;
        &lt;map&gt;
            &lt;entry&gt;
                &lt;key&gt;
                    &lt;value&gt;10010&lt;/value&gt;
                &lt;/key&gt;
                &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt;
            &lt;/entry&gt;
            &lt;entry&gt;
                &lt;key&gt;
                    &lt;value&gt;10086&lt;/value&gt;
                &lt;/key&gt;
                &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean
</code></pre>
<h4 id="3引用集合类型的bean">③引用集合类型的bean</h4>
<pre><code class="language-xml">&lt;!--list集合类型的bean--&gt;
&lt;util:list id=&quot;students&quot;&gt;
    &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt;
    &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt;
    &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;
&lt;/util:list&gt;
&lt;!--map集合类型的bean--&gt;
&lt;util:map id=&quot;teacherMap&quot;&gt;
    &lt;entry&gt;
        &lt;key&gt;
            &lt;value&gt;10010&lt;/value&gt;
        &lt;/key&gt;
        &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
        &lt;key&gt;
            &lt;value&gt;10086&lt;/value&gt;
        &lt;/key&gt;
        &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt;
    &lt;/entry&gt;
&lt;/util:map&gt;
&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring.bean.Clazz&quot;&gt;
    &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;students&quot; ref=&quot;students&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean.Student&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;
    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;抽烟&lt;/value&gt;
            &lt;value&gt;喝酒&lt;/value&gt;
            &lt;value&gt;烫头&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name=&quot;teacherMap&quot; ref=&quot;teacherMap&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>使用util:list、util:map标签必须引入相应的命名空间，可以通过idea的提示功能选择</p>
</blockquote>
<h3 id="229-实验九依赖注入之p命名空间">2.2.9、实验九：依赖注入之p命名空间</h3>
<p>引入p命名空间后，可以通过以下方式为bean的各个属性赋值</p>
<pre><code class="language-xml">&lt;bean id=&quot;studentSix&quot; class=&quot;com.atguigu.spring.bean.Student&quot;
		p:id=&quot;1006&quot; p:name=&quot;小明&quot; p:clazz-ref=&quot;clazzOne&quot; p:teacherMapref=&quot;teacherMap&quot;&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="2210-实验十引入外部属性文件">2.2.10、实验十：引入外部属性文件</h3>
<h4 id="1加入依赖">①加入依赖</h4>
<pre><code class="language-xml">&lt;!-- MySQL驱动 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.16&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 数据源 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.0.31&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="2创建外部属性文件">②创建外部属性文件</h4>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721151535.png" alt="" loading="lazy"></figure>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/ssm?characterEncoding=utf8&amp;useUnicode=true
jdbc.username=root
jdbc.password=
</code></pre>
<h4 id="3引入属性文件">③引入属性文件</h4>
<pre><code class="language-xml">&lt;!-- 引入外部属性文件 --&gt;
&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;
</code></pre>
<h4 id="4配置bean">④配置bean</h4>
<pre><code class="language-xml">&lt;!-- 配置数据源 --&gt;
&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="5测试">⑤测试</h4>
<pre><code class="language-java">@Test
public void testDataSource() throws SQLException {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;springdatasource.xml&quot;);
    DataSource dataSource = ioc.getBean(DataSource.class);
    Connection connection = dataSource.getConnection();
    System.out.println(connection);
}
</code></pre>
<h3 id="2211-实验十一bean的作用域">2.2.11、实验十一：bean的作用域</h3>
<h4 id="1概念">①概念</h4>
<ul>
<li>在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton（默认）</td>
<td>在IOC容器中，这个bean的对象始终为单实例</td>
<td>IOC容器初始化时</td>
</tr>
<tr>
<td>prototype</td>
<td>这个bean在IOC容器中有多个实例</td>
<td>获取bean时</td>
</tr>
</tbody>
</table>
<ul>
<li>如果是在WebApplicationContext环境下还会有另外三个作用域（但不常用）：</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>在一个请求范围内有效</td>
</tr>
<tr>
<td>session</td>
<td>在一个会话范围内有效</td>
</tr>
<tr>
<td>global-session</td>
<td>一般用于Portlet应用环境</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Portlet是可以复用的Web模块,用于管理和显示用户界面。</p>
<p>各作用域范围大小对比<br>
prototype &lt; request &lt; session &lt; global-session &lt; singleton</p>
</blockquote>
<h4 id="2创建类user">②创建类User</h4>
<pre><code class="language-java">public class User {
    
    private Integer id;
    private String username;
    private String password;
    private Integer age;

    public User() {
    }

    public User(Integer id, String username, String password, Integer age) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.age = age;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, username='&quot; + username + '\'' +
                &quot;, password='&quot; + password + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<h4 id="3配置bean">③配置bean</h4>
<p>springscope.xml</p>
<pre><code class="language-xml">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;
&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;
&lt;bean class=&quot;com.atguigu.bean.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
</code></pre>
<h4 id="4测试">④测试</h4>
<pre><code class="language-java">@Test
public void testBeanScope() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;springscope.xml&quot;);
    User user1 = ioc.getBean(User.class);
    User user2 = ioc.getBean(User.class);
    System.out.println(user1 == user2);
}
</code></pre>
<h3 id="2212-实验十二bean的生命周期">2.2.12、实验十二：bean的生命周期</h3>
<h4 id="1具体的生命周期过程">①具体的生命周期过程</h4>
<ul>
<li>bean对象创建（调用无参构造器）</li>
<li>给bean对象设置属性</li>
<li>bean对象初始化之前操作（由bean的后置处理器负责）</li>
<li>bean对象初始化（需在配置bean时指定初始化方法）</li>
<li>bean对象初始化之后操作（由bean的后置处理器负责）</li>
<li>bean对象就绪可以使用</li>
<li>bean对象销毁（需在配置bean时指定销毁方法）</li>
<li>IOC容器关闭</li>
</ul>
<h4 id="2修改类user">②修改类User</h4>
<pre><code class="language-java">public class User {
    private Integer id;
    private String username;
    private String password;
    private Integer age;

    public User() {
        System.out.println(&quot;生命周期：1、创建对象&quot;);
    }

    public User(Integer id, String username, String password, Integer age) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.age = age;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        System.out.println(&quot;生命周期：2、依赖注入&quot;);
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public void initMethod() {
        System.out.println(&quot;生命周期：3、初始化&quot;);
    }

    public void destroyMethod() {
        System.out.println(&quot;生命周期：5、销毁&quot;);
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, username='&quot; + username + '\'' +
                &quot;, password='&quot; + password + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<blockquote>
<p>注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法</p>
</blockquote>
<h4 id="3配置bean-2">③配置bean</h4>
<p>spring-lifecycle.xml</p>
<pre><code class="language-xml">&lt;!-- 使用init-method属性指定初始化方法 --&gt;
&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;
&lt;bean class=&quot;com.atguigu.bean.User&quot; scope=&quot;prototype&quot; init-method=&quot;initMethod&quot;
destroy-method=&quot;destroyMethod&quot;&gt;
		&lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
		&lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4测试-2">④测试</h4>
<pre><code class="language-java">@Test
public void testLife() {
    ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;);
    User bean = ioc.getBean(User.class);
    System.out.println(&quot;生命周期：4、通过IOC容器获取bean并使用&quot;);
    ioc.close();
}
</code></pre>
<h4 id="5bean的后置处理器">⑤bean的后置处理器</h4>
<ul>
<li>bean的后置处理器会在生命周期的初始化前后添加额外的操作，</li>
<li>需要实现BeanPostProcessor接口，且配置到IOC容器中，</li>
<li>需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行</li>
</ul>
<p>创建bean的后置处理器：</p>
<pre><code class="language-java">package com.atguigu.spring.process;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class MyBeanProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName)
            throws BeansException {
        System.out.println(&quot;☆☆☆&quot; + beanName + &quot; = &quot; + bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName)
            throws BeansException {
        System.out.println(&quot;★★★&quot; + beanName + &quot; = &quot; + bean);
        return bean;
    }
}
</code></pre>
<p>在IOC容器中配置后置处理器：</p>
<pre><code class="language-xml">&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;
&lt;bean id=&quot;myBeanProcessor&quot; class=&quot;com.atguigu.spring.process.MyBeanProcessor&quot;/&gt;
</code></pre>
<h3 id="2213-实验十三factorybean">2.2.13、实验十三：FactoryBean</h3>
<h4 id="1简介">①简介</h4>
<ul>
<li>
<p>FactoryBean是Spring提供的一种整合第三方框架的常用机制。</p>
</li>
<li>
<p>和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。</p>
</li>
<li>
<p>通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。</p>
</li>
<li>
<p>将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。</p>
</li>
</ul>
<pre><code class="language-java">/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory;

import org.springframework.lang.Nullable;

/**
 * Interface to be implemented by objects used within a {@link BeanFactory} which
 * are themselves factories for individual objects. If a bean implements this
 * interface, it is used as a factory for an object to expose, not directly as a
 * bean instance that will be exposed itself.
 *
 * &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a normal bean.&lt;/b&gt;
 * A FactoryBean is defined in a bean style, but the object exposed for bean
 * references ({@link #getObject()}) is always the object that it creates.
 *
 * &lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create
 * objects lazily on demand or eagerly on startup. The {@link SmartFactoryBean}
 * interface allows for exposing more fine-grained behavioral metadata.
 *
 * &lt;p&gt;This interface is heavily used within the framework itself, for example for
 * the AOP {@link org.springframework.aop.framework.ProxyFactoryBean} or the
 * {@link org.springframework.jndi.JndiObjectFactoryBean}. It can be used for
 * custom components as well; however, this is only common for infrastructure code.
 *
 * &lt;p&gt;&lt;b&gt;{@code FactoryBean} is a programmatic contract. Implementations are not
 * supposed to rely on annotation-driven injection or other reflective facilities.&lt;/b&gt;
 * {@link #getObjectType()} {@link #getObject()} invocations may arrive early in the
 * bootstrap process, even ahead of any post-processor setup. If you need access to
 * other beans, implement {@link BeanFactoryAware} and obtain them programmatically.
 *
 * &lt;p&gt;&lt;b&gt;The container is only responsible for managing the lifecycle of the FactoryBean
 * instance, not the lifecycle of the objects created by the FactoryBean.&lt;/b&gt; Therefore,
 * a destroy method on an exposed bean object (such as {@link java.io.Closeable#close()}
 * will &lt;i&gt;not&lt;/i&gt; be called automatically. Instead, a FactoryBean should implement
 * {@link DisposableBean} and delegate any such close call to the underlying object.
 *
 * &lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory's
 * synchronization of bean creation. There is usually no need for internal
 * synchronization other than for purposes of lazy initialization within the
 * FactoryBean itself (or the like).
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @since 08.03.2003
 * @param &lt;T&gt; the bean type
 * @see org.springframework.beans.factory.BeanFactory
 * @see org.springframework.aop.framework.ProxyFactoryBean
 * @see org.springframework.jndi.JndiObjectFactoryBean
 */
public interface FactoryBean&lt;T&gt; {

	/**
	 * The name of an attribute that can be
	 * {@link org.springframework.core.AttributeAccessor#setAttribute set} on a
	 * {@link org.springframework.beans.factory.config.BeanDefinition} so that
	 * factory beans can signal their object type when it can't be deduced from
	 * the factory bean class.
	 * @since 5.2
	 */
	String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;;


	/**
	 * Return an instance (possibly shared or independent) of the object
	 * managed by this factory.
	 * &lt;p&gt;As with a {@link BeanFactory}, this allows support for both the
	 * Singleton and Prototype design pattern.
	 * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of
	 * the call (for example because it is involved in a circular reference),
	 * throw a corresponding {@link FactoryBeanNotInitializedException}.
	 * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return {@code null}
	 * objects. The factory will consider this as normal value to be used; it
	 * will not throw a FactoryBeanNotInitializedException in this case anymore.
	 * FactoryBean implementations are encouraged to throw
	 * FactoryBeanNotInitializedException themselves now, as appropriate.
	 * @return an instance of the bean (can be {@code null})
	 * @throws Exception in case of creation errors
	 * @see FactoryBeanNotInitializedException
	 */
	@Nullable
	T getObject() throws Exception;

	/**
	 * Return the type of object that this FactoryBean creates,
	 * or {@code null} if not known in advance.
	 * &lt;p&gt;This allows one to check for specific types of beans without
	 * instantiating objects, for example on autowiring.
	 * &lt;p&gt;In the case of implementations that are creating a singleton object,
	 * this method should try to avoid singleton creation as far as possible;
	 * it should rather estimate the type in advance.
	 * For prototypes, returning a meaningful type here is advisable too.
	 * &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has
	 * been fully initialized. It must not rely on state created during
	 * initialization; of course, it can still use such state if available.
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return
	 * {@code null} here. Therefore it is highly recommended to implement
	 * this method properly, using the current state of the FactoryBean.
	 * @return the type of object that this FactoryBean creates,
	 * or {@code null} if not known at the time of the call
	 * @see ListableBeanFactory#getBeansOfType
	 */
	@Nullable
	Class&lt;?&gt; getObjectType();

	/**
	 * Is the object managed by this factory a singleton? That is,
	 * will {@link #getObject()} always return the same object
	 * (a reference that can be cached)?
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; If a FactoryBean indicates to hold a singleton object,
	 * the object returned from {@code getObject()} might get cached
	 * by the owning BeanFactory. Hence, do not return {@code true}
	 * unless the FactoryBean always exposes the same reference.
	 * &lt;p&gt;The singleton status of the FactoryBean itself will generally
	 * be provided by the owning BeanFactory; usually, it has to be
	 * defined as singleton there.
	 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This method returning {@code false} does not
	 * necessarily indicate that returned objects are independent instances.
	 * An implementation of the extended {@link SmartFactoryBean} interface
	 * may explicitly indicate independent instances through its
	 * {@link SmartFactoryBean#isPrototype()} method. Plain {@link FactoryBean}
	 * implementations which do not implement this extended interface are
	 * simply assumed to always return independent instances if the
	 * {@code isSingleton()} implementation returns {@code false}.
	 * &lt;p&gt;The default implementation returns {@code true}, since a
	 * {@code FactoryBean} typically manages a singleton instance.
	 * @return whether the exposed object is a singleton
	 * @see #getObject()
	 * @see SmartFactoryBean#isPrototype()
	 */
	default boolean isSingleton() {
		return true;
	}

}
</code></pre>
<h4 id="2创建类userfactorybean">②创建类UserFactoryBean</h4>
<pre><code class="language-java">public class UserFactoryBean implements FactoryBean&lt;User&gt; {
    @Override
    public User getObject() throws Exception {
        return new User();
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return User.class;
    }
}
</code></pre>
<h4 id="3配置bean-3">③配置bean</h4>
<p>springfactorybean.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.bean.UserFactoryBean&quot;&gt;&lt;/bean&gt;
</code></pre>
<h4 id="4测试-3">④测试</h4>
<pre><code class="language-java">@Test
public void testUserFactoryBean() {
    //获取IOC容器
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;springfactorybean.xml&quot;);
    User user = (User) ioc.getBean(&quot;user&quot;);
    System.out.println(user);
}
</code></pre>
<h3 id="2214-实验十四基于xml的自动装配">2.2.14、实验十四：基于xml的自动装配</h3>
<blockquote>
<p>自动装配：</p>
<p>根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值</p>
</blockquote>
<h4 id="1场景模拟">①场景模拟</h4>
<p>创建类UserController</p>
<pre><code class="language-java">public class UserController {
    private UserService userService;

    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public void saveUser() {
        userService.saveUser();
    }
}
</code></pre>
<p>创建接口UserService</p>
<pre><code class="language-java">public interface UserService {
    
    void saveUser();
    
}
</code></pre>
<p>创建类UserServiceImpl实现接口UserService</p>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
    private UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void saveUser() {
        userDao.saveUser();
    }
}
</code></pre>
<p>创建接口UserDao</p>
<pre><code class="language-java">public interface UserDao {

    void saveUser();
    
}
</code></pre>
<p>创建类UserDaoImpl实现接口UserDao</p>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {

    @Override
    public void saveUser() {
        System.out.println(&quot;保存成功&quot;);
    }
    
}
</code></pre>
<h4 id="2配置bean-3">②配置bean</h4>
<p>autowirexml.xml</p>
<blockquote>
<p>使用bean标签的autowire属性设置自动装配效果</p>
<p>自动装配方式：byType</p>
<p>byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值</p>
<p>若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值 null</p>
<p>若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionException</p>
</blockquote>
<pre><code class="language-xml">&lt;bean id=&quot;userController&quot;
class=&quot;com.atguigu.autowire.xml.controller.UserController&quot; autowire=&quot;byType&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userService&quot;
class=&quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
</code></pre>
<blockquote>
<p>自动装配方式：byName</p>
<p>byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值</p>
</blockquote>
<pre><code class="language-xml">&lt;bean id=&quot;userController&quot;
class=&quot;com.atguigu.autowire.xml.controller.UserController&quot; autowire=&quot;byName&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userService&quot;
class=&quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userServiceImpl&quot;
class=&quot;com.atguigu.autowire.xml.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.autowire.xml.dao.impl.UserDaoImpl&quot;&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="3测试-3">③测试</h4>
<pre><code class="language-java">@Test
public void testAutoWireByXML() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;autowirexml.xml&quot;);
    UserController userController = ioc.getBean(UserController.class);
    userController.saveUser();
}
</code></pre>
<h2 id="23-基于注解管理bean">2.3、基于注解管理bean</h2>
<h3 id="231-实验一标记与扫描">2.3.1、实验一：标记与扫描</h3>
<h4 id="1注解">①注解</h4>
<ul>
<li>和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。</li>
<li>本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。</li>
<li>举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721171841.png" alt="" loading="lazy"></figure>
<ul>
<li>班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们 做的工作，相当于框架的具体操作。</li>
</ul>
<h4 id="2扫描">②扫描</h4>
<ul>
<li>Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。</li>
</ul>
<h4 id="3新建maven-module">③新建Maven Module</h4>
<pre><code class="language-xml">&lt;dependencies&gt;

    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    
&lt;/dependencies&gt;
</code></pre>
<h4 id="4创建spring配置文件">④创建Spring配置文件</h4>
<ul>
<li>applicationContext.xml</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721172818.png" alt="" loading="lazy"></figure>
<h4 id="5标识组件的常用注解">⑤标识组件的常用注解</h4>
<blockquote>
<p>@Component：将类标识为普通组件</p>
<p>@Controller：将类标识为控制层组件</p>
<p>@Service：将类标识为业务层组件</p>
<p>@Repository：将类标识为持久层组件</p>
</blockquote>
<p>问：以上四个注解有什么关系和区别？</p>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721173246.png" alt="" loading="lazy"></figure>
<ul>
<li>通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。</li>
<li>对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。</li>
<li>注意：虽然它们本质上一样，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。</li>
</ul>
<h4 id="6创建组件">⑥创建组件</h4>
<p>创建控制层组件</p>
<pre><code class="language-java">@Controller
public class UserController {

}
</code></pre>
<p>创建接口UserService</p>
<pre><code class="language-java">public interface UserService {

}
</code></pre>
<p>创建业务层组件UserServiceImpl</p>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {
  
}
</code></pre>
<p>创建接口UserDao</p>
<pre><code class="language-java">public interface UserDao {
  
}
</code></pre>
<p>创建持久层组件UserDaoImpl</p>
<pre><code class="language-java">@Repository
public class UserDaoImpl implements UserDao {

}
</code></pre>
<h4 id="7扫描组件">⑦扫描组件</h4>
<p>情况一：最基本的扫描方式</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;
&lt;/context:component-scan&gt;
</code></pre>
<p>情况二：指定要排除的组件</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;
    &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;
    &lt;!--
            type：设置排除或包含的依据
            type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名
            type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名
    --&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot;
                            expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.controller.UserController&quot;/&gt;--&gt;
&lt;/context:component-scan&gt;
</code></pre>
<p>情况三：仅扫描指定组件</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt;
    &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;
    &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;
    &lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt;
    &lt;!--
            type：设置排除或包含的依据
            type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名
            type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名
    --&gt;
    &lt;context:include-filter type=&quot;annotation&quot;
                            expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;!--&lt;context:include-filter type=&quot;assignable&quot;
        expression=&quot;com.atguigu.controller.UserController&quot;/&gt;--&gt;
&lt;/context:component-scan&gt;
</code></pre>
<h4 id="8测试">⑧测试</h4>
<pre><code class="language-java">@Test
public void testAutowireByAnnotation() {
    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    UserController userController = ioc.getBean(UserController.class);
    System.out.println(userController);
    UserService userService = ioc.getBean(UserService.class);
    System.out.println(userService);
    UserDao userDao = ioc.getBean(UserDao.class);
    System.out.println(userDao);
}
</code></pre>
<h4 id="9组件所对应的bean的id">⑨组件所对应的bean的id</h4>
<p>在我们使用XML方式管理bean的时候，每个bean都有一个唯一标识，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。</p>
<blockquote>
<p>默认情况</p>
<p>类名首字母小写就是bean的id。例如：UserController类对应的bean的id就是userController。</p>
<p>自定义bean的id</p>
<p>可通过标识组件的注解的value属性设置自定义的bean的id</p>
<p>@Service(&quot;userService&quot;)//默认为userServiceImpl public class UserServiceImpl implements UserService {}</p>
</blockquote>
<h3 id="232-实验二基于注解的自动装配">2.3.2、实验二：基于注解的自动装配</h3>
<h4 id="1场景模拟-2">①场景模拟</h4>
<blockquote>
<p>参考基于xml的自动装配</p>
<p>在UserController中声明UserService对象</p>
<p>在UserServiceImpl中声明UserDao对象</p>
</blockquote>
<h4 id="2-autowired注解">② @Autowired注解</h4>
<p>在成员变量上直接标记@Autowired注解即可完成自动装配，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。</p>
<pre><code class="language-java">@Controller
public class UserController {
  
    @Autowired
    private UserService userService;
  
    public void saveUser() {
        userService.saveUser();
    }
  
}
</code></pre>
<pre><code class="language-java">public interface UserService {
    void saveUser();
}
</code></pre>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {
  
    @Autowired
    private UserDao userDao;
  
    @Override
    public void saveUser() {
        userDao.saveUser();
    }
  
}
</code></pre>
<pre><code class="language-java">public interface UserDao {
    void saveUser();
}
</code></pre>
<pre><code class="language-java">@Repository
public class UserDaoImpl implements UserDao {
    @Override
    public void saveUser() {
        System.out.println(&quot;保存成功&quot;);
    }
}
</code></pre>
<h4 id="3-autowired注解其他细节">③ @Autowired注解其他细节</h4>
<blockquote>
<p>@Autowired注解可以标记在<code>构造器</code>和<code>set方法</code>上</p>
</blockquote>
<pre><code class="language-java">@Controller
public class UserController {
    private UserService userService;
    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }
    public void saveUser() {
        userService.saveUser();
    }
}
</code></pre>
<pre><code class="language-java">@Controller
public class UserController {
  
    private UserService userService;
  
    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
  
    public void saveUser() {
        userService.saveUser();
    }
}
</code></pre>
<h4 id="4-autowired工作流程">④ @Autowired工作流程</h4>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721193212.png" alt="" loading="lazy"></figure>
<ul>
<li>首先根据所需要的组件类型到IOC容器中查找
<ul>
<li>能够找到唯一的bean：直接执行装配</li>
<li>如果完全找不到匹配这个类型的bean：装配失败</li>
<li>和所需类型匹配的bean不止一个
<ul>
<li>没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配
<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
<li>使用@Qualifier注解：根据@Qualifier注解中指定的名称作为bean的id进行匹配
<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Controller
public class UserController {
  
    @Autowired
    @Qualifier(&quot;userServiceImpl&quot;)
    private UserService userService;
  
    public void saveUser() {
        userService.saveUser();
    }
}
</code></pre>
<blockquote>
<p><strong>佛系装配</strong></p>
<p>@Autowired中有属性required，默认值为true，因此在自动装配无法找到相应的bean时，会装配失败</p>
<p>可以将属性required的值设置为false，则表示能装就装，装不上就不装.</p>
<p>但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性。</p>
<p>如果类中同时存在装配属性的 setXxx() 方法会使 required = false 设定失效。</p>
</blockquote>
<blockquote>
<h3 id="注意">注意</h3>
<ul>
<li>在使用@Autowire的过程中会发现IDEA提示<code>不建议使用字段注入</code>，我们查看检查描述可以看到这样容易抛出 <code>NullPointerException</code>,提供的解决方案是将字段使用<code>final</code>修饰，通过<code>构造器</code>注入.</li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727184152.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727184929.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>我们点击自动修复</p>
<figure data-type="image" tabindex="13"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220727185722.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>在完成修复后我们注意到没有了任何注解，并且UserService能够正常的注入进来</p>
<p><code>UserController{userService=com.atguigu.service.impl.UserServiceImpl@4ac3c60d}</code></p>
</li>
<li>
<p>这是因为从 Spring Framework 4.3 开始，<code>@Autowired</code>如果<code>目标 bean 仅定义一个构造函数</code>，则<code>不再需要</code>对此类构造函数进行<code>注解声明</code>。</p>
<ul>
<li>即上述代码等价于</li>
</ul>
<pre><code class="language-java">@Controller
public class UserController {
  
    private final UserService userService;

    @Autowired //这里IDEA不会报警告
    public UserController(UserService userService) {
        this.userService = userService;
    }
  
}
</code></pre>
<ul>
<li>
<p>也即每个需要注入的属性需要<code>final</code>修饰且要有相应的<code>参数构造器</code>，自然当前类也只能有参数构造器不能有空参构造器。</p>
<p>假设当前类有两个需要注入的属性字段：</p>
<p>正确的代码：</p>
<pre><code class="language-java">private final CommonComponent commonComponent;
private final UserService userService;

public UserController(UserService userService, CommonComponent commonComponent) {
    this.userService = userService;
    this.commonComponent = commonComponent;
}
</code></pre>
<p>错误的代码:</p>
<pre><code class="language-java">private final CommonComponent commonComponent;
private final UserService userService;


//错误开始
public UserController() {
  
}
//错误结束


/*
a. 因为空参构造器会造成commonComponent或userService尚未初始化。（final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化）
b. 同理也不能有只含commonComponent或userService的单参构造器。
*/


public UserController(UserService userService, CommonComponent commonComponent) {
    this.userService = userService;
    this.commonComponent = commonComponent;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="5总结">⑤总结</h4>
<p>基于注解的自动装配</p>
<ul>
<li>
<p>方式一：使用<code>构造器注入</code></p>
<ul>
<li>使用IDEA自动修复功能完成</li>
</ul>
<pre><code class="language-java">@Controller
public class UserController {
  
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }
  
}
</code></pre>
</li>
<li>
<p>方式二：使用<code>@Resource</code>替代@Autowired</p>
<ul>
<li>@Resource和@Autowired和都可以用于来实现依赖注入，但前者为JDK（JSR-250标准）自带的，后者是Spring提供的。</li>
<li>使用这种方式IDEA不会抱警告，但这种方式本质仍然是Field注入。</li>
<li>Field注入的缺点很明显，比如不能像构造器注入那样注入不可变的对象，依赖对外部不可见（构造器和Setter可见，而private的属性不可见），会导致组件与IoC容器（比如Spring）紧密耦合，单元测试也需要使用IoC容器，依赖过多时相对构造器注入不能够明显的看出依赖过多（违反单一职责原则）。</li>
<li>既然Field注入这么多缺点，但为什么大家还是习惯使用呢？主要原因：太方便了，极大的缩减了代码。而且大多数业务并不需要用构造器强绑定，同时换IoC容器的可能性也极低。所以，虽然Spring及IDE一直强调和提醒，但貌似并没有阻止程序员的使用。</li>
<li>为什么只对@Autowired警告？</li>
<li>最主要的原因可能是：@Autowired是Spring提供的，是特定IoC提供的特定注解，与框架形成了强绑定，一旦换用其他IoC框架，是无法支持注入的。而@Resource是JSR-250提供的，IoC容器应当去兼容它，即使更换容器，也可以正常工作。</li>
</ul>
<pre><code class="language-java">@Resource
private UserService userService;
</code></pre>
</li>
<li>
<p>方式三：使用Lombok的<code>@RequiredArgsConstructor</code>配合<code>final field</code></p>
<pre><code class="language-java">@Controller
@RequiredArgsConstructor
public class UserController {
    
    private final UserService userService;

}
</code></pre>
</li>
</ul>
<h3 id="233-实验三完全注解开发">2.3.3、实验三：完全注解开发</h3>
<p>体验完全注解开发，是为了给将来学习 SpringBoot 打基础。因为在 SpringBoot 中，就是完全舍弃 XML 配置文件，全面使用注解来完成主要的配置。</p>
<h4 id="1创建配置类">①创建配置类</h4>
<p>使用 @Configuration 注解将一个普通的类标记为 Spring 的配置类。</p>
<pre><code class="language-java">package com.atguigu.ioc.configuration;
    
import org.springframework.context.annotation.Configuration;
    
@Configuration
public class MyConfiguration {
  
}
</code></pre>
<h4 id="2根据配置类创建ioc容器对象">②根据配置类创建IOC容器对象</h4>
<pre><code class="language-java">// ClassPathXmlApplicationContext 根据 XML 配置文件创建 IOC 容器对象
private ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象
private ApplicationContext ioc = new AnnotationConfigApplicationContext(MyConfiguration.class);
</code></pre>
<h4 id="3在配置类中配置bean">③在配置类中配置bean</h4>
<p>使用@Bean注解</p>
<pre><code class="language-java">@Configuration
public class MyConfiguration {
  
    // @Bean 注解相当于 XML 配置文件中的 bean 标签
    // @Bean 注解标记的方法的返回值会被放入 IOC 容器
    // 默认以方法名作为 bean 的 id
    @Bean
    public CommonComponent getComponent() {
      
        CommonComponent commonComponent = new CommonComponent();
      
        commonComponent.setComponentName(&quot;created by annotation config&quot;);
      
        return commonComponent;
    }
}
</code></pre>
<h4 id="4在配置类中配置自动扫描的包">④在配置类中配置自动扫描的包</h4>
<p>使用@ComponentScan注解</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.atguigu.ioc.component&quot;)
public class MyConfiguration {
    ……
}
</code></pre>
<h3 id="234-实验四整合junit4">2.3.4、实验四：整合junit4</h3>
<h4 id="1整合的好处">①整合的好处</h4>
<ul>
<li>好处1：不需要自己创建IOC容器对象了</li>
<li>好处2：任何需要的bean都可以在测试类中直接享受自动装配</li>
</ul>
<h4 id="2操作">②操作</h4>
<p>加入依赖</p>
<pre><code class="language-xml">&lt;!-- Spring的测试包 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>创建测试类</p>
<pre><code class="language-java">// junit的@RunWith注解：指定Spring为Junit提供的运行器
@RunWith(SpringJUnit4ClassRunner.class)

// Spring的@ContextConfiguration指定Spring配置文件的位置
@ContextConfiguration(value = {&quot;classpath:applicationContext.xml&quot;})
public class JunitIntegrationSpring {
    
    @Autowired
    private SoldierController soldierController;
    
    @Test
    public void testIntegration() {
        System.out.println(&quot;soldierController = &quot; + soldierController);
    }
    
}
</code></pre>
<h1 id="3-aop">3、AOP</h1>
<h2 id="31-场景模拟">3.1、场景模拟</h2>
<h3 id="311-声明接口">3.1.1、声明接口</h3>
<p>声明计算器接口Calculator，包含加减乘除的抽象方法</p>
<pre><code class="language-java">public interface Calculator {
    
    int add(int i, int j);
  
    int sub(int i, int j);
  
    int mul(int i, int j);
  
    int div(int i, int j);
    
}
</code></pre>
<h3 id="312-创建实现类">3.1.2、创建实现类</h3>
<figure data-type="image" tabindex="14"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721205610.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">public class CalculatorPureImpl implements Calculator {
    
    @Override
    public int add(int i, int j) {
        int result = i + j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        int result = i - j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        int result = i * j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        int result = i / j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
}
</code></pre>
<h3 id="313-创建带日志功能的实现类">3.1.3、创建带日志功能的实现类</h3>
<figure data-type="image" tabindex="15"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721205850.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">public class CalculatorLogImpl implements Calculator {
    
    @Override
    public int add(int i, int j) {
        System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);
        int result = i + j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        System.out.println(&quot;[日志] sub 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);
        int result = i - j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        System.out.println(&quot;[日志] sub 方法结束了，结果是：&quot; + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);
        int result = i * j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        System.out.println(&quot;[日志] div 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);
        int result = i / j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        System.out.println(&quot;[日志] div 方法结束了，结果是：&quot; + result);
        return result;
    }
  
}
</code></pre>
<h3 id="314-提出问题">3.1.4、提出问题</h3>
<h4 id="1现有代码缺陷">①现有代码缺陷</h4>
<p>针对带日志功能的实现类，我们发现有如下缺陷：</p>
<ul>
<li>对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力</li>
<li>附加功能分散在各个业务功能方法中，不利于统一维护</li>
</ul>
<h4 id="2解决思路">②解决思路</h4>
<p>解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。</p>
<h4 id="3困难">③困难</h4>
<p>解决问题的困难：要抽取的代码在方法内部，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。</p>
<h2 id="32-代理模式">3.2、代理模式</h2>
<h3 id="321-概念">3.2.1、概念</h3>
<h4 id="1介绍">①介绍</h4>
<p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类<strong>间接</strong>调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——<strong>解耦</strong>。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p>
<figure data-type="image" tabindex="16"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721210816.png" alt="" loading="lazy"></figure>
<p>使用代理后：</p>
<figure data-type="image" tabindex="17"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721210900.png" alt="" loading="lazy"></figure>
<h4 id="2生活中的代理">②生活中的代理</h4>
<ul>
<li>广告商找大明星拍广告需要经过经纪人</li>
<li>合作伙伴找大老板谈合作要约见面时间需要经过秘书</li>
<li>房产中介是买卖双方的代理</li>
</ul>
<h4 id="3相关术语">③相关术语</h4>
<ul>
<li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。</li>
<li>目标：<strong>被代理</strong>“套用”了非核心逻辑代码的类、对象、方法。</li>
</ul>
<h3 id="322-静态代理">3.2.2、静态代理</h3>
<p>创建静态代理类：</p>
<pre><code class="language-java">public class CalculatorStaticProxy implements Calculator {
  
    // 将被代理的目标对象声明为成员变量
    private Calculator target;
  
    public CalculatorStaticProxy(Calculator target) {
        this.target = target;
    }
  
    @Override
    public int add(int i, int j) {
      
        // 附加功能由代理类中的代理方法来实现
        System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);
      
        // 通过目标对象来实现核心业务逻辑
        int addResult = target.add(i, j);
      
        System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + addResult);
      
        return addResult;
    }
  
}
</code></pre>
<blockquote>
<p>静态代理确实实现了解耦，但是由于代码都<strong>写死了</strong>，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。</p>
<p>提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。</p>
</blockquote>
<h3 id="323-动态代理">3.2.3、动态代理</h3>
<figure data-type="image" tabindex="18"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721211704.png" alt="" loading="lazy"></figure>
<p>生产代理对象的工厂类：</p>
<pre><code class="language-java">public class ProxyFactory {
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    public Object getProxy() {

        /**
         * newProxyInstance()：创建一个代理实例
         * 其中有三个参数：
         * 1、classLoader：加载动态生成的代理类的类加载器
         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组
         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法
         */

        ClassLoader classLoader = target.getClass().getClassLoader();
        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();
        InvocationHandler invocationHandler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args)
                    throws Throwable {
                /**
                 * proxy：代理对象
                 * method：代理对象需要实现的方法，即其中需要重写的方法
                 * args：method所对应方法的参数
                 */
                Object result = null;
                try {
                    System.out.println(&quot;[动态代理][日志] &quot; + method.getName() + &quot;，参数：&quot; + Arrays.toString(args));
                    result = method.invoke(target, args);
                    System.out.println(&quot;[动态代理][日志] &quot; + method.getName() + &quot;，结果：&quot; + result);
                } catch (Exception e) {
                    e.printStackTrace();
                    System.out.println(&quot;[动态代理][日志] &quot; + method.getName() + &quot;，异常：&quot; + e.getMessage());
                } finally {
                    System.out.println(&quot;[动态代理][日志] &quot; + method.getName() + &quot;，方法执行完毕&quot;);
                }
                return result;
            }
        };
        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
    }
}
</code></pre>
<h3 id="324-测试">3.2.4、测试</h3>
<pre><code class="language-java">@Test
public void testDynamicProxy() {
    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());
    Calculator proxy = (Calculator) factory.getProxy();
    proxy.div(1, 0);
    //proxy.div(1,1);
}
</code></pre>
<h2 id="33-aop概念及相关术语">3.3、AOP概念及相关术语</h2>
<h3 id="331-概述">3.3.1、概述</h3>
<ul>
<li>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术。</li>
<li>AOP的核心套路</li>
</ul>
<figure data-type="image" tabindex="19"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721215952.png" alt="" loading="lazy"></figure>
<h3 id="332-相关术语">3.3.2、相关术语</h3>
<figure data-type="image" tabindex="20"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722120920.png" alt="" loading="lazy"></figure>
<h4 id="1横切关注点连接点">①横切关注点(连接点)</h4>
<ul>
<li>从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。</li>
<li>这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：<strong>有十个附加功能，就有十个横切关注点。</strong></li>
</ul>
<figure data-type="image" tabindex="21"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721220106.png" alt="" loading="lazy"></figure>
<h4 id="2通知记住">②通知【记住】</h4>
<p>每一个横切关注点上要做的事情都需要写一个方法（<strong>实际增强的逻辑部分</strong>）来实现，这样的方法就叫<strong>通知方法</strong>。</p>
<ul>
<li>前置通知：在被代理的目标方法<strong>前</strong>执行</li>
<li>返回通知：在被代理的目标方法<strong>成功结束</strong>后执行</li>
<li>异常通知：在被代理的目标方法<strong>异常结束</strong>后执行</li>
<li>后置通知：在被代理的目标方法<strong>最终结束</strong>后执行</li>
<li>环绕通知：使用try...catch...finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<figure data-type="image" tabindex="22"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721220834.png" alt="" loading="lazy"></figure>
<h4 id="3切面记住">③切面【记住】</h4>
<p>封装通知方法的<strong>类</strong>。</p>
<figure data-type="image" tabindex="23"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721221150.png" alt="" loading="lazy"></figure>
<h4 id="4目标">④目标</h4>
<p>被代理的<strong>目标对象</strong>。</p>
<h4 id="5代理">⑤代理</h4>
<p>向目标对象应用通知之后创建的<strong>代理对象</strong>。</p>
<h4 id="6连接点">⑥连接点</h4>
<ul>
<li><strong>类里面哪些方法可以被增强，这些方法称为连接点</strong></li>
</ul>
<p>这也是一个纯逻辑概念，不是语法定义的。</p>
<p>把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。</p>
<figure data-type="image" tabindex="24"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220721221557.png" alt="" loading="lazy"></figure>
<h4 id="7切入点记住">⑦切入点【记住】</h4>
<ul>
<li><strong>实际被增强的方法，称为切入点。</strong></li>
</ul>
<p>定位连接点的方式。</p>
<p>每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。</p>
<p>如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。</p>
<p>Spring 的 AOP 技术可以通过切入点定位到特定的连接点。</p>
<p>切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p>
<h4 id="8织入">⑧织入</h4>
<ul>
<li>织入是动作，就是把通知应用到切入点来创建代理对象的<strong>过程</strong>。</li>
</ul>
<h3 id="333-作用">3.3.3、作用</h3>
<ul>
<li>简化代码：把方法中固定位置的重复的代码<strong>抽取</strong>出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。</li>
<li>代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被<strong>套用</strong>了切面逻辑的方法就被切面给增强了。</li>
</ul>
<h2 id="34-基于注解的aop">3.4、基于注解的AOP</h2>
<h3 id="341-技术说明">3.4.1、技术说明</h3>
<img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722142959.png"/>
<ul>
<li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式）。</li>
<li>cglib：通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</li>
<li>AspectJ：本质上是静态代理，<strong>将代理逻辑“织入”被代理的目标类编译得到的字节码文件</strong>，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。</li>
</ul>
<h3 id="342-准备工作">3.4.2、准备工作</h3>
<h4 id="1添加依赖">①添加依赖</h4>
<p>在IOC所需依赖基础上再加入下面依赖即可：</p>
<pre><code class="language-xml">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;
&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
		&lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="2准备被代理的目标资源">②准备被代理的目标资源</h4>
<p>接口：</p>
<pre><code class="language-java">public interface Calculator {
    
    int add(int i, int j);
  
    int sub(int i, int j);
  
    int mul(int i, int j);
  
    int div(int i, int j);
    
}
</code></pre>
<p>实现类：</p>
<pre><code class="language-java">public class CalculatorPureImpl implements Calculator {
    
    @Override
    public int add(int i, int j) {
        int result = i + j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        int result = i - j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        int result = i * j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        int result = i / j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
}
</code></pre>
<h3 id="343-创建切面类并配置">3.4.3、创建切面类并配置</h3>
<pre><code class="language-java">// @Aspect表示这个类是一个切面类
@Aspect
// @Component注解保证这个切面类能够放入IOC容器
@Component
public class LogAspect {

    // @Before注解：声明当前方法是前置通知方法
    // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上
    @Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)
    public void printLogBeforeCore(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());
        System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot; + methodName + &quot;，参数：&quot; + args);
    }

    @Afterr(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)
    public void printLogFinallyEnd() {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot; + methodName);
    }

    @AfterReturningg(value = &quot;execution(*
            com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)

    public void printLogAfterException(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot; + methodName + &quot;，结果：&quot; + result);
    }


    @AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)
    public void printLogAfterSuccess(JoinPoint joinPoint, Throwable ex) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot; + methodName + &quot;，异常：&quot; + ex);
    }


    @Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)
    public Object aroundMethod(ProceedingJoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());
        Object result = null;
        try {
            System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);
            //目标对象（连接点）方法的执行
            result = joinPoint.proceed();
            System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);
        } finally {
            System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);
        }
        return result;
    }

}
</code></pre>
<p>在Spring的配置文件中配置：</p>
<pre><code class="language-xml">&lt;!--
基于注解的AOP的实现：
1、将目标对象和切面交给IOC容器管理（注解+扫描）
2、开启基于注解的AOP功能 (开启AspectJ的自动代理，为目标对象自动生成代理)
3、将切面类通过注解@Aspect标识
 --&gt;

&lt;!-- 配置自动扫描的包 --&gt;
&lt;context:component-scan base-package=&quot;com.atguigu.aop.annotation&quot;/&gt;

&lt;!-- 开启基于注解的AOP功能 --&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<h3 id="344-各种通知">3.4.4、各种通知</h3>
<ul>
<li>前置通知：使用@Before注解标识，在被代理的目标方法<strong>前</strong>执行</li>
<li>返回通知：使用@AfterReturning注解标识，在被代理的目标方法<strong>成功结束</strong>后执行</li>
<li>异常通知：使用@AfterThrowing注解标识，在被代理的目标方法<strong>异常结束</strong>后执行</li>
<li>后置通知：使用@After注解标识，在被代理的目标方法<strong>最终结束</strong>后执行</li>
<li>环绕通知：使用@Around注解标识，使用try...catch...finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<blockquote>
<h4 id="各种通知的执行顺序">各种通知的执行顺序：</h4>
<ul>
<li>Spring版本5.3.x以前：
<ul>
<li>前置通知</li>
<li>目标操作</li>
<li>后置通知</li>
<li>返回通知或异常通知</li>
</ul>
</li>
<li>Spring版本5.3.x以后：
<ul>
<li>前置通知</li>
<li>目标操作</li>
<li>返回通知或异常通知</li>
<li>后置通知</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="345-切入点表达式语法">3.4.5、切入点表达式语法</h3>
<h4 id="1作用">①作用</h4>
<figure data-type="image" tabindex="25"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722165001.png" alt="" loading="lazy"></figure>
<h4 id="2语法细节">②语法细节</h4>
<ul>
<li>用 * 号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限</li>
<li>在包名的部分，一个 * 号只能代表包的层次结构中的一层，表示这一层是任意的。
<ul>
<li>例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello</li>
</ul>
</li>
<li>在包名的部分，使用“*..”表示包名任意、包的层次深度任意</li>
<li>在类名的部分，类名部分整体用*号代替，表示类名任意</li>
<li>在类名的部分，可以使用*号代替类名的一部分
<ul>
<li>例如：*Service匹配所有名称以Service结尾的类或接口</li>
</ul>
</li>
<li>在方法名部分，可以使用*号表示方法名任意</li>
<li>在方法名部分，可以使用*号代替方法名的一部分
<ul>
<li>例如：*Operation匹配所有方法名以Operation结尾的方法</li>
</ul>
</li>
<li>在方法参数列表部分，使用(..)表示参数列表任意</li>
<li>在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头</li>
<li>在方法参数列表部分，基本数据类型和对应的包装类型是不一样的
<ul>
<li>切入点表达式中使用 int 和实际方法中 Integer 是不匹配的</li>
</ul>
</li>
<li>在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符
<ul>
<li>例如：execution(public int ..Service.*(.., int)) <code>正确</code></li>
<li>例如：execution(* int ..Service.*(.., int)) <code>错误</code></li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="26"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722170459.png" alt="" loading="lazy"></figure>
<blockquote>
<h4 id="tip">TIP</h4>
<p>虽然我们上面介绍过的切入点表达式语法细节很多，有很多变化，但是实际上具体在项目中应用时有比较固定的写法。</p>
<p>典型场景：在基于 XML 的声明式事务配置中需要指定切入点表达式。这个切入点表达式通常都会套用到所有 Service 类（接口）的所有方法。那么切入点表达式将如下所示：</p>
<p><code>execution(* *..*Service.*(..))</code></p>
</blockquote>
<h3 id="346-重用切入点表达式">3.4.6、重用切入点表达式</h3>
<h4 id="1声明">①声明</h4>
<pre><code class="language-java">@Pointcut(&quot;execution(* com.atguigu.aop.annotation.*.*(..))&quot;)
public void pointCut(){}
</code></pre>
<h4 id="2在同一个切面中使用">②在同一个切面中使用</h4>
<pre><code class="language-java">@Before(&quot;pointCut()&quot;)
public void beforeMethod(JoinPoint joinPoint) {
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot; + methodName + &quot;，参数：&quot; + args);
}
</code></pre>
<h4 id="3在不同切面中使用">③在不同切面中使用</h4>
<pre><code class="language-java">@Before(&quot;com.atguigu.aop.CommonPointCut.pointCut()&quot;)
public void beforeMethod(JoinPoint joinPoint) {
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot; + methodName + &quot;，参数：&quot; + args);
}
</code></pre>
<h3 id="347-获取通知的相关信息">3.4.7、获取通知的相关信息</h3>
<h4 id="1获取连接点信息">①获取连接点信息</h4>
<p>获取连接点信息可以在通知方法的参数位置设置<code>JoinPoint</code>类型的形参</p>
<pre><code class="language-java">@Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)
public void beforeMethod(JoinPoint joinPoint) {
    //获取连接点的签名信息
    String methodName = joinPoint.getSignature().getName();
    //获取目标方法到的实参信息
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot; + methodName + &quot;，参数：&quot; + args);
}
</code></pre>
<h4 id="2获取目标方法的返回值">②获取目标方法的返回值</h4>
<p><code>@AfterReturning</code>中的属性<code>returning</code>，用来将通知方法的某个形参，接收目标方法的返回值</p>
<pre><code class="language-java">@AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.* (..))&quot;, returning = &quot;result&quot;)
public void afterReturningMethod(JoinPoint joinPoint, Object result) {
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot; + methodName + &quot;，结果：&quot; + result);
}
</code></pre>
<h4 id="3获取目标方法的异常">③获取目标方法的异常</h4>
<p><code>@AfterThrowing</code>中的属性<code>throwing</code>，用来将通知方法的某个形参，接收目标方法的异常</p>
<pre><code class="language-java">@AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.* (..))&quot;, throwing = &quot;ex&quot;)
public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex) {
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot; + methodName + &quot;，异常：&quot; + ex);
}
</code></pre>
<h3 id="348-环绕通知">3.4.8、环绕通知</h3>
<ul>
<li>环绕通知类似于动态代理的具体实现</li>
<li>注意环绕通知的JoinPoint类型是<code>ProceedingJoinPoint</code></li>
</ul>
<pre><code class="language-java">@Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)
public Object aroundMethod(ProceedingJoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    Object result = null;
    try {
        System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);
        //目标对象（连接点）方法的执行
        result = joinPoint.proceed();
        System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);
    } catch (Throwable throwable) {
        throwable.printStackTrace();
        System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);
    } finally {
        System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);
    }
    return result;
}
</code></pre>
<h3 id="349-切面的优先级">3.4.9、切面的优先级</h3>
<h4 id="1概念-2">①概念</h4>
<p>相同目标方法上同时存在多个切面时，切面的优先级控制按照切面的<code>内外嵌套</code>顺序。</p>
<ul>
<li>优先级高的切面：外面</li>
<li>优先级低的切面：里面</li>
</ul>
<p>使用<code>@Order</code>注解可以控制切面的优先级：</p>
<ul>
<li>@Order(较小的数)：优先级高</li>
<li>@Order(较大的数)：优先级低</li>
</ul>
<figure data-type="image" tabindex="27"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722173445.png" alt="" loading="lazy"></figure>
<h4 id="2实际意义">②实际意义</h4>
<p>实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。</p>
<figure data-type="image" tabindex="28"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722174955.png" alt="" loading="lazy"></figure>
<p>此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。</p>
<figure data-type="image" tabindex="29"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722175037.png" alt="" loading="lazy"></figure>
<h3 id="3410-没有接口的情况">3.4.10、没有接口的情况</h3>
<ul>
<li>在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。为了证明这一点，我们做下面的测试：</li>
</ul>
<h4 id="1创建目标类">①创建目标类</h4>
<p>请确保这个类在自动扫描的包下，同时确保切面的切入点表达式能够覆盖到类中的方法。</p>
<pre><code class="language-java">@Service
public class EmployeeService {
    
    public void getEmpList() {
        System.out.println(&quot;方法内部 com.atguigu.aop.imp.EmployeeService.getEmpList&quot;);
    }
    
}
</code></pre>
<h4 id="2测试">②测试</h4>
<pre><code class="language-java">@Autowired
private EmployeeService employeeService;

@Test
public void testNoInterfaceProxy() {
    employeeService.getEmpList();
    System.out.println();
}
</code></pre>
<h4 id="3debug查看">③Debug查看</h4>
<ul>
<li>
<p>没有实现接口情况</p>
<figure data-type="image" tabindex="30"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722180742.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>有实现接口的情况</p>
<figure data-type="image" tabindex="31"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722180811.png" alt="" loading="lazy"></figure>
</li>
</ul>
<p>同时我们发现：Mybatis 调用的 Mapper 接口类型的对象其实也是动态代理机制</p>
<figure data-type="image" tabindex="32"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722180853.png" alt="" loading="lazy"></figure>
<h2 id="35-基于xml的aop了解">3.5、基于XML的AOP（了解）</h2>
<h3 id="351-准备工作">3.5.1、准备工作</h3>
<h4 id="1添加依赖-2">①添加依赖</h4>
<p>和基于注解的 AOP 时一样。</p>
<h4 id="2准备代码">②准备代码</h4>
<p>把测试基于注解功能时的Java类复制到新module中，去除所有注解。</p>
<h3 id="352-实现">3.5.2、实现</h3>
<pre><code class="language-xml">&lt;!-- 配置目标类的bean --&gt;
&lt;bean id=&quot;calculatorPure&quot; class=&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;/&gt;
    
&lt;!-- 配置切面类的bean --&gt;
&lt;bean id=&quot;logAspect&quot; class=&quot;com.atguigu.aop.aspect.LogAspect&quot;/&gt;
    
&lt;!-- 配置AOP --&gt;
&lt;aop:config&gt;
    
    &lt;!-- 配置切入点表达式 --&gt;
    &lt;aop:pointcut id=&quot;logPointCut&quot; expression=&quot;execution(* *..*.*(..))&quot;/&gt;
    
    &lt;!-- aop:aspect标签：配置切面 --&gt;
    &lt;!-- ref属性：关联切面类的bean --&gt;
    &lt;aop:aspect ref=&quot;logAspect&quot;&gt;
        &lt;!-- aop:before标签：配置前置通知 --&gt;
        &lt;!-- method属性：指定前置通知的方法名 --&gt;
        &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt;
        &lt;aop:before method=&quot;printLogBeforeCore&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;
    
        &lt;!-- aop:after-returning标签：配置返回通知 --&gt;
        &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt;
        &lt;aop:after-returning
                method=&quot;printLogAfterCoreSuccess&quot;
                pointcut-ref=&quot;logPointCut&quot;
                returning=&quot;targetMethodReturnValue&quot;/&gt;
    
        &lt;!-- aop:after-throwing标签：配置异常通知 --&gt;
        &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt;
        &lt;aop:after-throwing
                method=&quot;printLogAfterCoreException&quot;
                pointcut-ref=&quot;logPointCut&quot;
                throwing=&quot;targetMethodException&quot;/&gt;
    
        &lt;!-- aop:after标签：配置后置通知 --&gt;
        &lt;aop:after method=&quot;printLogCoreFinallyEnd&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;
    
        &lt;!-- aop:around标签：配置环绕通知 --&gt;
        &lt;!--&lt;aop:around method=&quot;……&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;--&gt;
    &lt;/aop:aspect&gt;
    
&lt;/aop:config&gt;
</code></pre>
<h3 id="352-测试">3.5.2、测试</h3>
<pre><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(value = {&quot;classpath:spring-context.xml&quot;})
public class AOPTest {
    
    @Autowired
    private Calculator calculator;
    
    @Test
    public void testLogAspect() {
        int add = calculator.add(10, 2);
        System.out.println(&quot;add = &quot; + add);
    }
}
</code></pre>
<h2 id="36-aop-对获取-bean-的影响">3.6、AOP 对获取 bean 的影响</h2>
<h3 id="351-实验">3.5.1、实验</h3>
<h4 id="1情景一">①情景一</h4>
<ul>
<li>声明一个接口</li>
<li>接口有一个实现类</li>
<li>创建一个切面类，对上面接口的实现类应用通知
<ul>
<li>测试：根据接口类型获取bean</li>
<li>测试：根据类获取bean</li>
</ul>
</li>
</ul>
<p>原因分析：</p>
<p>应用了切面后，真正放在IOC容器中的是代理类的对象</p>
<p>目标类并没有被放到IOC容器中，所以<code>根据目标类的类型从IOC容器中是找不到的</code></p>
<figure data-type="image" tabindex="33"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722191357.png" alt="" loading="lazy"></figure>
<p>从内存分析的角度来说，IOC容器中引用的是代理对象，代理对象引用的是目标对象。IOC容器并没有直接引用目标对象，所以根据目标类本身在IOC容器范围内查找不到。</p>
<figure data-type="image" tabindex="34"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722191614.png" alt="" loading="lazy"></figure>
<p>debug查看代理类的类型：</p>
<figure data-type="image" tabindex="35"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722191640.png" alt="" loading="lazy"></figure>
<h4 id="2情景二">②情景二</h4>
<ul>
<li>
<p>声明一个类</p>
</li>
<li>
<p>创建一个切面类，对上面的类应用通知</p>
<ul>
<li>测试：根据类获取 bean，能获取到。（实际上相当于根据父类类型获取子类bean，前提保证只有一个子类）</li>
</ul>
<figure data-type="image" tabindex="36"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722192250.png" alt="" loading="lazy"></figure>
<p>debug查看实际类型：</p>
<figure data-type="image" tabindex="37"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722192327.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h3 id="352-总结">3.5.2、总结</h3>
<h4 id="1对实现了接口的类应用切面">①对实现了接口的类应用切面</h4>
<p><code>应用切面后的代理类</code>放入IOC容器</p>
<figure data-type="image" tabindex="38"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722190152.png" alt="" loading="lazy"></figure>
<h4 id="2对没实现接口的类应用切面">②对没实现接口的类应用切面</h4>
<p><code>CGLIB生成的代理类</code>放入IOC容器</p>
<figure data-type="image" tabindex="39"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220722190211.png" alt="" loading="lazy"></figure>
<h1 id="4-声明式事务">4、声明式事务</h1>
<h2 id="41-jdbctemplate">4.1、JdbcTemplate</h2>
<h3 id="411-简介">4.1.1、简介</h3>
<p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p>
<h3 id="412-准备工作">4.1.2、准备工作</h3>
<h4 id="1加入依赖-2">①加入依赖</h4>
<pre><code class="language-xml">&lt;dependencies&gt;

    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Spring 持久化层支持jar包 --&gt;
    &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;
    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Spring 测试相关 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- MySQL驱动 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 数据源 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.0.31&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<h4 id="2创建jdbcproperties">②创建jdbc.properties</h4>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/ssm?characterEncoding=utf8&amp;useUnicode=true
jdbc.username=root
jdbc.password=
</code></pre>
<h4 id="3配置spring的配置文件">③配置Spring的配置文件</h4>
<p>spring-jdbc.xml</p>
<pre><code class="language-xml">&lt;!-- 导入外部属性文件 --&gt;
&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;

&lt;!-- 配置数据源 --&gt;
&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
		&lt;property name=&quot;url&quot; value=&quot;${atguigu.url}&quot;/&gt;
		&lt;property name=&quot;driverClassName&quot; value=&quot;${atguigu.driver}&quot;/&gt;
		&lt;property name=&quot;username&quot; value=&quot;${atguigu.username}&quot;/&gt;
		&lt;property name=&quot;password&quot; value=&quot;${atguigu.password}&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 配置 JdbcTemplate --&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
		&lt;!-- 装配数据源 --&gt;
		&lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="413-测试">4.1.3、测试</h3>
<h4 id="1在测试类装配-jdbctemplate">①在测试类装配 JdbcTemplate</h4>
<pre><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:spring-jdbc.xml&quot;)
public class JDBCTemplateTest {
  
    @Autowired
    private JdbcTemplate jdbcTemplate;
  
}
</code></pre>
<h4 id="2测试增删改功能">②测试增删改功能</h4>
<pre><code class="language-java">@Test
//测试增删改功能
public void testUpdate() {
    String sql = &quot;insert into t_emp values(null,?,?,?)&quot;;
    int result = jdbcTemplate.update(sql, &quot;张三&quot;, 23, &quot;男&quot;);
    System.out.println(result);
}
</code></pre>
<h4 id="3查询一条数据为实体类对象">③查询一条数据为实体类对象</h4>
<pre><code class="language-java">@Test
//查询一条数据为一个实体类对象
public void testSelectEmpById() {
    String sql = &quot;select * from t_emp where id = ?&quot;;
    Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class), 1);
    System.out.println(emp);
}
</code></pre>
<h4 id="4查询多条数据为一个list集合">④查询多条数据为一个list集合</h4>
<pre><code class="language-java">@Test
//查询多条数据为一个list集合
public void testSelectList() {
    String sql = &quot;select * from t_emp&quot;;
    List&lt;Emp&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class));
    list.forEach(emp -&gt; System.out.println(emp));
}
</code></pre>
<h4 id="5查询单行单列的值">⑤查询单行单列的值</h4>
<pre><code class="language-java">@Test
//查询单行单列的值
public void selectCount() {
    String sql = &quot;select count(id) from t_emp&quot;;
    Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
    System.out.println(count);
}
</code></pre>
<h2 id="42-声明式事务概念">4.2、声明式事务概念</h2>
<h3 id="421-编程式事务">4.2.1、编程式事务</h3>
<p>事务功能的相关操作全部通过自己编写代码来实现：</p>
<pre><code class="language-java">Connection conn = ...;
	
try {
	
	// 开启事务：关闭事务的自动提交
	conn.setAutoCommit(false);
	
	// 核心操作
	
	// 提交事务
	conn.commit();
	
}catch(Exception e){
	
	// 回滚事务
	conn.rollBack();
	
}finally{
	
	// 释放数据库连接
	conn.close();
	
}
</code></pre>
<p>编程式的实现方式存在缺陷：</p>
<ul>
<li>细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。</li>
<li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。</li>
</ul>
<h3 id="422-声明式事务">4.2.2、声明式事务</h3>
<p>既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。</p>
<p>封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。</p>
<ul>
<li>好处1：提高开发效率</li>
<li>好处2：消除了冗余的代码</li>
<li>好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化</li>
</ul>
<p>所以，我们可以总结下面两个概念：</p>
<ul>
<li><strong>编程式</strong>：<strong>自己写代码</strong>实现功能</li>
<li><strong>声明式</strong>：通过<strong>配置</strong>让<strong>框架</strong>实现功能</li>
</ul>
<h2 id="43-基于注解的声明式事务">4.3、基于注解的声明式事务</h2>
<h3 id="431-准备工作">4.3.1、准备工作</h3>
<h4 id="1加入依赖-3">①加入依赖</h4>
<pre><code class="language-xml">&lt;dependencies&gt;

    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Spring 持久化层支持jar包 --&gt;
    &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;
    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Spring 测试相关 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- MySQL驱动 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 数据源 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;version&gt;1.0.31&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<h4 id="2创建jdbcproperties-2">②创建jdbc.properties</h4>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
#jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3305/ssm?characterEncoding=utf8&amp;useUnicode=true
jdbc.username=root
jdbc.password=
</code></pre>
<h4 id="3配置spring的配置文件-2">③配置Spring的配置文件</h4>
<p>tx-annotation.xml</p>
<pre><code class="language-xml">&lt;!--扫描组件--&gt;
&lt;context:component-scan base-package=&quot;com.atguigu.spring.tx.annotation&quot;&gt;
&lt;/context:component-scan&gt;

&lt;!-- 导入外部属性文件 --&gt;
&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;

&lt;!-- 配置数据源 --&gt;
&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${atguigu.url}&quot;/&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${atguigu.driver}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${atguigu.username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${atguigu.password}&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 配置 JdbcTemplate --&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;!-- 装配数据源 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4创建表">④创建表</h4>
<pre><code class="language-sql">CREATE TABLE `t_book` (
	`book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
	`book_name` varchar(20) DEFAULT NULL COMMENT '图书名称',
	`price` int(11) DEFAULT NULL COMMENT '价格',
	`stock` int(10) unsigned DEFAULT NULL COMMENT '库存（无符号）',
PRIMARY KEY (`book_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,'斗破苍
穹',80,100),(2,'斗罗大陆',50,100);

CREATE TABLE `t_user` (
	`user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
	`username` varchar(20) DEFAULT NULL COMMENT '用户名',
	`balance` int(10) unsigned DEFAULT NULL COMMENT '余额（无符号）',
PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

insert into `t_user`(`user_id`,`username`,`balance`) values (1,'admin',50);
</code></pre>
<h4 id="5创建组件">⑤创建组件</h4>
<p>创建BookController</p>
<pre><code class="language-java">@Controller
public class BookController {
  
    @Autowired
    private BookService bookService;
  
    public void buyBook(Integer bookId, Integer userId) {
        bookService.buyBook(bookId, userId);
    }
  
}
</code></pre>
<p>创建接口BookService</p>
<pre><code class="language-java">public interface BookService {
  
    void buyBook(Integer bookId, Integer userId);
  
}
</code></pre>
<p>创建实现类BookServiceImpl</p>
<pre><code class="language-java">@Service
public class BookServiceImpl implements BookService {
  
    @Autowired
    private BookDao bookDao;
  
    @Override
    public void buyBook(Integer bookId, Integer userId) {
        //查询图书的价格
        Integer price = bookDao.getPriceByBookId(bookId);
        //更新图书的库存
        bookDao.updateStock(bookId);
        //更新用户的余额
        bookDao.updateBalance(userId, price);
    }
  
}
</code></pre>
<p>创建接口BookDao</p>
<pre><code class="language-java">public interface BookDao {

    Integer getPriceByBookId(Integer bookId);
    
    void updateStock(Integer bookId);
    
    void updateBalance(Integer userId, Integer price);
    
}
</code></pre>
<p>创建实现类BookDaoImpl</p>
<pre><code class="language-java">@Repository
public class BookDaoImpl implements BookDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Override
    public Integer getPriceByBookId(Integer bookId) {
        String sql = &quot;select price from t_book where book_id = ?&quot;;
        return jdbcTemplate.queryForObject(sql, Integer.class, bookId);
    }
    @Override
    public void updateStock(Integer bookId) {
        String sql = &quot;update t_book set stock = stock - 1 where book_id = ?&quot;;
        jdbcTemplate.update(sql, bookId);
    }
    @Override
    public void updateBalance(Integer userId, Integer price) {
        String sql = &quot;update t_user set balance = balance - ? where user_id = ? &quot;;
        jdbcTemplate.update(sql, price, userId);
    }
}
</code></pre>
<h3 id="432-测试无事务情况">4.3.2、测试无事务情况</h3>
<h4 id="1创建测试类">①创建测试类</h4>
<pre><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:tx-annotation.xml&quot;)
public class TxByAnnotationTest {
  
    @Autowired
    private BookController bookController;
  
    @Test
    public void testBuyBook() {
        bookController.buyBook(1, 1);
    }
 
}
</code></pre>
<h4 id="2模拟场景">②模拟场景</h4>
<ul>
<li>
<p>用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额</p>
</li>
<li>
<p>假设用户id为1的用户，购买id为1的图书</p>
</li>
<li>
<p>用户余额为50，而图书价格为80</p>
</li>
<li>
<p>购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段</p>
</li>
<li>
<p>此时执行sql语句会抛出SQLException</p>
</li>
</ul>
<h4 id="3观察结果">③观察结果</h4>
<ul>
<li>因为没有添加事务，图书的库存更新了，但是用户的余额没有更新</li>
<li>显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败</li>
</ul>
<h3 id="433-加入事务">4.3.3、加入事务</h3>
<h4 id="1添加事务配置">①添加事务配置</h4>
<p>在Spring的配置文件中添加配置：</p>
<pre><code class="language-xml">&lt;!--创建事务管理器bean--&gt;
&lt;bean id=&quot;transactionManager&quot;
      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!--
 开启事务的注解驱动
 通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务
--&gt;
&lt;!--
 transaction-manager属性的默认值是transactionManager，
 如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性
--&gt;
&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<p>注意：导入的名称空间需要 <strong>tx 结尾</strong>的那个。</p>
<figure data-type="image" tabindex="40"><img src="https://cdn.jsdelivr.net/gh/kuangyang828/jsDeliverCDN1/img/20220723004522.png" alt="" loading="lazy"></figure>
<blockquote>
<p>该配置对应的注解方式为</p>
<p><code>@EnableTransactionManagement //启用事务管理</code></p>
</blockquote>
<h4 id="2添加事务注解">②添加事务注解</h4>
<p>因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理 在BookServiceImpl的buybook()添加注解<code>@Transactional</code></p>
<h4 id="3观察结果-2">③观察结果</h4>
<p>由于使用了Spring的声明式事务，更新库存和更新余额都没有执行</p>
<h3 id="434-transactional注解标识的位置">4.3.4、@Transactional注解标识的位置</h3>
<ul>
<li>@Transactional标识在方法上，则只会影响该方法</li>
<li>@Transactional标识的类上，则会影响类中所有的方法</li>
</ul>
<blockquote>
<h4 id="tip-2">TIP</h4>
<p>Spring 环境下很多场合都有类似设定，一个注解如果标记了类的每一个方法那么通常就可以提取到类级别。</p>
</blockquote>
<h3 id="435-事务属性只读">4.3.5、事务属性：只读</h3>
<h4 id="1介绍-2">①介绍</h4>
<p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这 样数据库就能够针对查询操作来进行优化。</p>
<h4 id="2使用方式">②使用方式</h4>
<pre><code class="language-java">@Transactional(readOnly = true)
public void buyBook(Integer bookId, Integer userId) {
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}
</code></pre>
<h4 id="3注意">③注意</h4>
<ul>
<li>
<p>对增删改操作设置只读属性会抛出下面异常：</p>
</li>
<li>
<p>Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed</p>
</li>
</ul>
<h3 id="436-事务属性超时">4.3.6、事务属性：超时</h3>
<h4 id="1介绍-3">①介绍</h4>
<ul>
<li>
<p>事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间 占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。</p>
</li>
<li>
<p>此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p>
</li>
<li>
<p>概括来说就是一句话：超时就要回滚，释放资源。</p>
</li>
</ul>
<h4 id="2使用方式-2">②使用方式</h4>
<pre><code class="language-java">@Transactional(timeout = 3)
public void buyBook(Integer bookId, Integer userId) {
    try {
        TimeUnit.SECONDS.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
  
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}
</code></pre>
<h4 id="3观察结果-3">③观察结果</h4>
<ul>
<li>执行过程中抛出异常：</li>
<li>org.springframework.transaction.<strong>TransactionTimedOutException</strong>: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2022</li>
</ul>
<h3 id="437-事务属性回滚策略">4.3.7、事务属性：回滚策略</h3>
<h4 id="1介绍-4">①介绍</h4>
<p>声明式事务默认只针对运行时异常回滚，编译时异常不回滚。</p>
<p>可以通过@Transactional中相关属性设置回滚策略</p>
<ul>
<li><code>rollbackFor</code>属性：需要设置一个Class类型的对象</li>
<li><code>rollbackForClassName</code>属性：需要设置一个字符串类型的全类名</li>
<li><code>noRollbackFor</code>属性：需要设置一个Class类型的对象</li>
<li><code>noRollbackFoClassNamer</code>属性：需要设置一个字符串类型的全类名</li>
</ul>
<h4 id="2使用方式-3">②使用方式</h4>
<pre><code class="language-java">@Transactional(noRollbackFor = ArithmeticException.class)
//@Transactional(noRollbackForClassName = &quot;java.lang.ArithmeticException&quot;)
public void buyBook(Integer bookId, Integer userId) {
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
  
    //更新图书的库存
    bookDao.updateStock(bookId);
  
    //更新用户的余额
    bookDao.updateBalance(userId, price);
  
    System.out.println(1 / 0);
}
</code></pre>
<h4 id="3观察结果-4">③观察结果</h4>
<p>虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当出现ArithmeticException不发生回滚，因此购买图书的操作正常执行</p>
<h3 id="438-事务属性事务隔离级别">4.3.8、事务属性：事务隔离级别</h3>
<h4 id="1介绍-5">①介绍</h4>
<p>数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p>
<p>隔离级别一共有四种：</p>
<ul>
<li>
<p>读未提交：READ UNCOMMITTED</p>
<p>允许Transaction01读取Transaction02未提交的修改。</p>
</li>
<li>
<p>读已提交：READ COMMITTED</p>
<p>要求Transaction01只能读取Transaction02已提交的修改。</p>
</li>
<li>
<p>可重复读：REPEATABLE READ</p>
<p>确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。</p>
</li>
<li>
<p>串行化：SERIALIZABLE</p>
<p>确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。</p>
</li>
</ul>
<p>各个隔离级别解决并发问题的能力见下表：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>无</td>
<td>无</td>
<td>有（MySQL无）</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>各种数据库产品对事务隔离级别的支持程度：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>Oracle</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>√(默认)</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>×</td>
<td>√(默认)</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<h4 id="2使用方式-4">②使用方式</h4>
<pre><code class="language-java">@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别
@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交
@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交
@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读
@Transactional(isolation = Isolation.SERIALIZABLE)//串行化
</code></pre>
<h3 id="439-事务属性事务传播行为">4.3.9、事务属性：事务传播行为</h3>
<h4 id="1介绍-6">①介绍</h4>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<h4 id="2测试-2">②测试</h4>
<p>创建接口CheckoutService</p>
<pre><code class="language-java">public interface CheckoutService {

    void checkout(Integer[] bookIds, Integer userId);
    
}
</code></pre>
<p>创建实现类CheckoutServiceImpl</p>
<pre><code class="language-java">@Service
public class CheckoutServiceImpl implements CheckoutService {
  
    @Autowired
    private BookService bookService;
  
    @Override
    @Transactional
    //一次购买多本图书
    public void checkout(Integer[] bookIds, Integer userId) {
        for (Integer bookId : bookIds) {
            bookService.buyBook(bookId, userId);
        }
    }
  
}
</code></pre>
<p>在BookController中添加方法</p>
<pre><code class="language-java">@Autowired
private CheckoutService checkoutService;

public void checkout(Integer[] bookIds, Integer userId) {
    checkoutService.checkout(bookIds, userId);
}
</code></pre>
<p>在数据库中将用户的余额修改为100元</p>
<h4 id="3观察结果-5">③观察结果</h4>
<p>可以通过@Transactional中的<code>propagation属性</code>设置事务传播行为</p>
<p>修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性</p>
<ul>
<li>@Transactional(propagation = Propagation.<code>REQUIRED</code>)，<strong>默认</strong>情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，<strong>即只要有一本书买不了，就都买不了</strong></li>
<li>@Transactional(propagation = Propagation.<code>REQUIRES_NEW</code>)，<code>建议使用</code>。表示不管当前线程上是否有已经开启的事务，都要开启新事务。同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不影响，<strong>即能买几本就买几本</strong></li>
</ul>
<h2 id="44-基于xml的声明式事务">4.4、基于XML的声明式事务</h2>
<h3 id="431-场景模拟">4.3.1、场景模拟</h3>
<p>参考基于注解的声明式事务</p>
<h3 id="432-修改spring配置文件">4.3.2、修改Spring配置文件</h3>
<p>将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置</p>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;!-- 配置事务通知和切入点表达式 --&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot;
                 pointcut=&quot;execution(* com.atguigu.spring.tx.xml.service.impl.*.*(..))&quot;&gt;&lt;/aop:advisor&gt;
&lt;/aop:config&gt;
&lt;!-- tx:advice标签：配置事务通知 --&gt;
&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;
&lt;!-- transaction-manager属性：关联事务管理器 --&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!-- tx:method标签：配置具体的事务方法 --&gt;
        &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt;
        &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
        &lt;!-- read-only属性：设置只读属性 --&gt;
        &lt;!-- rollback-for属性：设置回滚的异常 --&gt;
        &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt;
        &lt;!-- isolation属性：设置事务的隔离级别 --&gt;
        &lt;!-- timeout属性：设置事务的超时属性 --&gt;
        &lt;!-- propagation属性：设置事务的传播行为 --&gt;
        &lt;tx:method name=&quot;save*&quot; read-only=&quot;false&quot; rollbackfor=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
        &lt;tx:method name=&quot;update*&quot; read-only=&quot;false&quot; rollbackfor=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
        &lt;tx:method name=&quot;delete*&quot; read-only=&quot;false&quot; rollbackfor=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<blockquote>
<p>注意：基于xml实现的声明式事务，必须引入aspectJ的依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
    &lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</blockquote>
<h1 id="5-spring5-新特性">5、Spring5 新特性</h1>
<h2 id="51-jsr305标准相关注解">5.1、JSR305标准相关注解</h2>
<h2 id="52-整合junit5">5.2、整合junit5</h2>
]]></content>
    </entry>
</feed>